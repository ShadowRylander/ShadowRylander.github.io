<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://alhassy.github.io/rss.xml"
      title="RSS feed for https://alhassy.github.io/"/>
<title>Life & Computing Science</title>

<link rel="stylesheet" type="text/css" href="https://alhassy.github.io/org-special-block-extras/tooltipster/dist/css/tooltipster.bundle.min.css"/>

<link rel="stylesheet" type="text/css" href="https://alhassy.github.io/org-special-block-extras/tooltipster/dist/css/plugins/tooltipster/sideTip/themes/tooltipster-sideTip-punk.min.css" />

<script type="text/javascript" src="https://code.jquery.com/jquery-1.10.0.min.js"></script>

 <script type="text/javascript"            src="https://alhassy.github.io/org-special-block-extras/tooltipster/dist/js/tooltipster.bundle.min.js"></script>

  <script>
         $(document).ready(function() {
             $('.tooltip').tooltipster({
                 theme: 'tooltipster-punk',
                 contentAsHTML: true,
                 animation: 'grow',
                 delay: [100,500],
                 // trigger: 'click'
                 trigger: 'custom',
                 triggerOpen: {
                     mouseenter: true
                 },
                 triggerClose: {
                     originClick: true,
                     scroll: true
                 }
 });
         });
     </script>

<style>
   abbr {color: red;}

   .tooltip { border-bottom: 1px dotted #000;
              color:red;
              text-decoration: none;}
</style>
<meta name="author" content="Musa Al-hassy">
<meta name="referrer" content="no-referrer">
<link href="usual-org-front-matter.css" rel="stylesheet" type="text/css" />
<link href="org-notes-style.css" rel="stylesheet" type="text/css" />
<link href="floating-toc.css" rel="stylesheet" type="text/css" />
<link href="blog-banner.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="images/favicon.png">

<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
,*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>

</head>
<body>
<div id="preamble" class="status"><div class="header">
  <a href="https://alhassy.github.io/" class="logo">Life & Computing Science</a>
  <br>
    <a href="https://alhassy.github.io/AlBasmala">AlBasmala</a>
    <a href="https://alhassy.github.io/archive">Archive</a>
    <a href="https://alhassy.github.io/tags">Tags</a>
    <a href="https://alhassy.github.io/rss.xml">RSS</a>
    <a href="https://alhassy.github.io/about">About</a>
</div></div>
<div id="content">
<h1 class="title">Posts tagged "lisp":</h1>
<h1 class="post-title"><div class="title" style="margin: 0 0 0 0 !important;"><a href="https://alhassy.github.io/TypedLisp.html">Typed Lisp, A Primer</a></h1></div><div style="text-align: center;">21 Aug 2019</div><center> <img src="images/emacs-birthday-present.png" alt="Article image"
  width="350" height="350" align="top" /> </center><br><center><strong>Abstract</strong></center>
<nav id="table-of-contents">
<h2>Ξ</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#inconsistent-love"><a href="#inconsistent-love">“Loving Haskell &amp; Lisp is Inconsistent”</a></a></li>
<li><a href="#terse-types-tutorial"><a href="#terse-types-tutorial">Why Bother with Types? A Terse Tutorial on Type Systems</a></a>
<ul>
<li><a href="#type-checking"><a href="#type-checking">Obtaining &amp; Checking Types</a></a></li>
<li><a href="#lisp-is-eval"><a href="#lisp-is-eval">Statics &amp; Dynamics of Lisp</a></a></li>
<li><a href="#lisp-is-dynamic"><a href="#lisp-is-dynamic">Variable Scope</a></a></li>
<li><a href="#lisp-is-strong"><a href="#lisp-is-strong">Casts &amp; Coercions</a></a></li>
<li><a href="#type-annotations"><a href="#type-annotations">Type Annotations</a></a></li>
<li><a href="#typecase"><a href="#typecase">Type-directed Computations</a></a></li>
<li><a href="#type-specifiers"><a href="#type-specifiers">Type Specifiers: On the nature of types in Lisp</a></a></li>
<li><a href="#deftype"><a href="#deftype">Making New Types with <code>deftype</code></a></a></li>
<li><a href="#adts"><a href="#adts">Algebraic Data Types a la Haskell</a></a></li>
</ul>
</li>
<li><a href="#why-dynamic"><a href="#why-dynamic">In Defence of Being Dynamically Checked</a></a></li>
<li><a href="#lisp-funny-history"><a href="#lisp-funny-history">With its hierarchy of types, why isn't Lisp statically typed?</a></a></li>
<li><a href="#lisp-is-typed"><a href="#lisp-is-typed">Lisp Actually Admits Static Typing!</a></a></li>
<li><a href="#elisp-types"><a href="#elisp-types">ELisp's Type Hierarchy</a></a>
<ul>
<li><a href="#Number"><a href="#Number">Number</a></a></li>
<li><a href="#Character"><a href="#Character">Character</a></a></li>
<li><a href="#Symbol"><a href="#Symbol">Symbol</a></a></li>
<li><a href="#Sequence"><a href="#Sequence">Sequence</a></a></li>
<li><a href="#Function"><a href="#Function">Function</a></a></li>
<li><a href="#Macro"><a href="#Macro">Macro</a></a></li>
<li><a href="#Record"><a href="#Record">Record</a></a></li>
</ul>
</li>
<li><a href="#typing-via-macros"><a href="#typing-via-macros">Typing via Macros &amp; Advice</a></a></li>
<li><a href="#Closing"><a href="#Closing">Closing</a></a></li>
<li><a href="#references"><a href="#references">References</a></a></li>
</ul>
</div>
</nav>

<p>
Let's explore Lisp's fine-grained type hierarchy!
</p>

<p>
We begin with a shallow comparison to Haskell, a rapid tour of type theory,
try in vain to defend dynamic approaches, give a somewhat humorous account of history,
note that you've been bamboozled &#x2014;type's have always been there&#x2014;,
then go into technical details of some Lisp types, and finally conclude by showing
how <i>macros permit typing</i>.
</p>

<p>
Goals for this article:
</p>

<ol class="org-ol">
<li>Multiple examples of type constructions in Lisp.</li>
<li>Comparing Lisp type systems with modern languages, such as Haskell.</li>
<li>Show how algebraic <a href="#org47d3d0a">polymorphic</a> types like <code>Pair</code> and <code>Maybe</code> can be defined in Lisp.
Including heterogeneously typed lists!</li>
<li>Convey a passion for an elegant language.</li>
<li>Augment Lisp with functional Haskell-like type declarations ;-)</li>
</ol>

<p>
Unless suggested otherwise, the phrase “Lisp” refers to
<a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#index-cl_002ddeftype-14">Common Lisp as supported by Emacs Lisp</a>. As such, the resulting discussion
is applicable to a number of Lisp dialects
&#x2014;I'm ignoring editing types such as buffers and keymaps, for now.
</p>

<small> <center>
<p>
( Original print by Baneen Al-hassy as a birthday present to me. )
</p>
</center> </small>
<style>

.figure-number {
    display: none;
}

.table-number {
    display: none;
}

/* Using source blocks “math” as aliaas for haskell */
pre.src-math:before { content: 'Mathematical! Algebraic! Axiomatic!'; }
/* Execute this for alias: (add-to-list 'org-src-lang-modes '("math" . haskell)) */

</style>

<div id="outline-container-orgb60ba22" class="outline-2">
<h2 id="inconsistent-love"><a href="#inconsistent-love">“Loving Haskell &amp; Lisp is Inconsistent”</a></h2>
<div class="outline-text-2" id="text-inconsistent-love">
<p>
I have convinced a number of my peers to use Emacs/Spacemacs/Doom-emacs,
but my efforts to get them to even consider trying Lisp have been met with
staunch rejection. These peers are familiar with Haskell, and almost all know Agda,
so you'd think they'd be willing to try Lisp &#x2014;it's there, part of their editor&#x2014;
but the superficial chasm in terms of syntax and types is more than enough apparently.
In this article, I aim to explore the type system of (Emacs) Lisp and occasionally
make comparisons to Haskell. Perhaps in the end some of my Haskell peers would be
willing to try it out.
</p>


<figure>
<img src="https://imgs.xkcd.com/comics/lisp_cycles.png" alt="lisp_cycles.png">

<figcaption><span class="figure-number">Figure 1: </span>xkcd - Lisp is a language of timeless elegance</figcaption>
</figure>

<ul class="org-ul">
<li><p>
↯ I almost never use Haskell for any day-to-day dealings.
</p>

<p>
✓ The ideas expressed by its community are why I try
       to keep updated on the language.
</p></li>

<li><p>
↯ No one around me knows anything about Lisp,
but they dislike it due to the parens.
</p>

<p>
✓ I love it and use it for Emacs configuration and recently
       to prototype my PhD research.
</p></li>
<li>⇅ I love that I can express a complicated procedure compactly in both
by using zips, unzips, filters, and maps <code>(งಠ_ಠ)ง</code>
<ul class="org-ul">
<li><p>
Lately, in Lisp, I'll write a nested loop (gasp!)
then, for fun, try to make it a one-liner!
Sometimes, I actually think the loop formulation is clearer
and I leave it as a loop &#x2014;Breaking news: Two Haskell readers just died.
</p>


<figure>
<img src="https://i.stack.imgur.com/jvSOG.png" alt="jvSOG.png">

<figcaption><span class="figure-number">Figure 2: </span>From the awesome “Land of Lisp” book</figcaption>
</figure></li>
</ul></li>
</ul>

<ul class="org-ul">
<li><p>
<b>What I like and why:</b>
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Haskell</td>
<td class="org-left">⇒</td>
<td class="org-left">Executable category theory; compact &amp; eloquent</td>
</tr>

<tr>
<td class="org-left">Lisp</td>
<td class="org-left">⇒</td>
<td class="org-left">Extensible language; malleable, uniform, beautiful</td>
</tr>
</tbody>
</table></li>

<li><p>
<b>Documentation?</b>
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Haskell</td>
<td class="org-left">⇒</td>
<td class="org-left">Hoogle; can search by type alone!</td>
</tr>

<tr>
<td class="org-left">Emacs Lisp</td>
<td class="org-left">⇒</td>
<td class="org-left">Self-documenting; <code>M-x apropos</code></td>
</tr>
</tbody>
</table></li>

<li><p>
<b>How has using the language affected me?</b>
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Haskell</td>
<td class="org-left">I almost always think in-terms compoistionality, functors, &amp; currying</td>
</tr>

<tr>
<td class="org-left">Lisp</td>
<td class="org-left">Documentation strings, units tests, and metaprogramming are second nature</td>
</tr>
</tbody>
</table></li>
</ul>

<p>
It may not be entirely accurate to say that
Lisp's type system is more expressive than Haskell's
as it's orthogonal in many respects; although it is closer to that of <a href="https://liquid.kosmikus.org/01-intro.html#/what-is-liquid-haskell">Liquid Haskell</a>.
</p>
</div>
</div>

<div id="outline-container-orgddd44ee" class="outline-2">
<h2 id="terse-types-tutorial"><a href="#terse-types-tutorial">Why Bother with Types? A Terse Tutorial on Type Systems</a></h2>
<div class="outline-text-2" id="text-terse-types-tutorial">
<p>
<i>Types allow us to treat objects according a similar structure
or interface.</i>
Unlike Haskell and other statically typed systems, in Lisp we have
that types can overlap.
As such, here's our working definition.
</p>
<div class="org-center">
<p>
A <b>type</b> is a collection of possible objects.
</p>

<p>
To say “\(e\) has type \(τ\)” one writes \(e : τ\), or in Lisp: <code>(typep e 'τ)</code>.
</p>
</div>

<p>
Haskellers and others may append to this definition the following,
which we will not bother with:
<i>Type membership is determined by inspecting
syntactic structure and so is decidable.</i>
</p>

<blockquote>
<p>
✓ Typing is one of the simplest forms of “assertion-comments”:
Documenting a property of your code in a way that the machine can verify.
</p>

<p>
If you're gonna comment on what kind of thing you're working with, why not have the
comment checked by the machine.
</p>
</blockquote>

<table>
<caption class="t-above"><span class="table-number">Table 1:</span> Lisp's type hierarchy is a “complemented lattice” ♥‿♥</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Common types</td>
<td class="org-left"><code>integer, number, string, keyword, array, cons, list, vector, macro, function, atom</code></td>
</tr>

<tr>
<td class="org-left">Top</td>
<td class="org-left"><code>t</code> has everything as an element</td>
</tr>

<tr>
<td class="org-left">Unit</td>
<td class="org-left"><code>null</code> has one element named <code>nil</code></td>
</tr>

<tr>
<td class="org-left">Bottom</td>
<td class="org-left"><code>nil</code> has no elements at all</td>
</tr>

<tr>
<td class="org-left">Union</td>
<td class="org-left"><code>(or τ₀ τ₁ … τₙ)</code>  has elements any element in any type <code>τᵢ</code></td>
</tr>

<tr>
<td class="org-left">Intersection</td>
<td class="org-left"><code>(and τ₀ τ₁ … τₙ)</code> has elements that are in all the types <code>τᵢ</code></td>
</tr>

<tr>
<td class="org-left">Complement</td>
<td class="org-left"><code>(not τ)</code> has elements that are <i>not</i> of type <code>τ</code></td>
</tr>

<tr>
<td class="org-left">Enumeration</td>
<td class="org-left"><code>(member x₀ … xₙ)</code> is the type consisting of only the elements <code>xᵢ</code></td>
</tr>

<tr>
<td class="org-left">Singleton</td>
<td class="org-left"><code>(eql x)</code> is the type with only the element <code>x</code></td>
</tr>

<tr>
<td class="org-left">Comprehension</td>
<td class="org-left"><code>(satisfies p)</code> is the type of values that satisfy predicate <code>p</code></td>
</tr>
</tbody>
</table>

<p>
Let's see some examples:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">The universal type &#8220;t&#8221;, has everything as its value.</span>
(<span style="color: #b58900;">typep</span> 'x '<span style="color: #268bd2;">t</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> 12 '<span style="color: #268bd2;">t</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">The empty type: nil</span>
(<span style="color: #b58900;">typep</span> 'x 'nil) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false; nil has no values.</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">The type &#8220;null&#8221; contains the one value &#8220;nil&#8221;.</span>
(<span style="color: #b58900;">typep</span> nil '<span style="color: #b58900;">null</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> () '<span style="color: #b58900;">null</span>)  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8220;(eql x)&#8221; is the singelton type consisting of only x.</span>
(<span style="color: #b58900;">typep</span> 3 '(<span style="color: #b58900;">eql</span> 3)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> 4 '(<span style="color: #b58900;">eql</span> 3)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8220;(member x&#8320; &#8230; x&#8345;)&#8221; denotes the enumerated type consisting of only the x&#7522;.</span>
(<span style="color: #b58900;">typep</span> 3 '(<span style="color: #b58900;">member</span> 3 x <span style="color: #2aa198;">"c"</span>))  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> 'x '(<span style="color: #b58900;">member</span> 3 x <span style="color: #2aa198;">"c"</span>)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> 'y '(<span style="color: #b58900;">member</span> 3 x <span style="color: #2aa198;">"c"</span>)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8220;(satisfies p)&#8221; is the type of values that satisfy predicate p.</span>
(<span style="color: #b58900;">typep</span> 12 '(satisfies (<span style="color: #859900; font-weight: bold;">lambda</span> (x) (<span style="color: #b58900;">oddp</span> x)))) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
(<span style="color: #b58900;">typep</span> 12 '(satisfies <span style="color: #b58900;">evenp</span>) )                <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Computation rule for comprehension types.</span>
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">(typep x '(satisfies p)) &#8776; (if (p x) t nil)</span>
</pre>
</div>

<p>
Here's a convenient one: <code>(booleanp x) ≈ (typep x '(member t nil))</code>.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">booleanp</span> 2)   <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
(<span style="color: #b58900;">booleanp</span> nil) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
</pre>
</div>

<p>
Strongly typed languages like Haskell allow only a number of the type formers listed
above. For example, Haskell does not allow unions but instead offers so-called sum
types. Moreover, unlike Haskell, Lisp is non-parametric:
We may pick a branch of computation according to the type of a value.
Such case analysis is available in languages such as C# &#x2014;c.f.,
<a href="https://blogs.msdn.microsoft.com/ericlippert/2010/09/16/is-is-as-or-is-as-is/">is is as or is as is</a>. Finally, it is important to realise that <code>cons</code> is a monomorphic
type
&#x2014;it just means an (arbitrary) element consisting of two parts called <code>car</code> and <code>cdr</code>&#x2014;
we show how to form a <a href="#org47d3d0a">polymorphic</a> product type below.
</p>

<p>
We may ask for <i>the</i> ‘primitive type’ of an object;
which is the simplest built-in type that it belongs to,
such as integer, string, cons, symbol, record, subr, and a few others.
As such, <i>Lisp objects come with an intrinsic primitive type</i>;
e.g., <code>'(1 "2" 'three)</code> is a list and can only be treated as a value of
another type if an explicit coercion is used.
In Lisp, rather than variables, it is values that are associated with a type.
One may optionally declare the types of variables, like in OCaml.
</p>
<div class="org-center">
<p>
<i>Lisp (primitive) types are inferred!</i>
</p>

<p>
“Values have types, not variables.” &#x2014;Paul Graham, ANSI Common Lisp
</p>
</div>

<p>
Let's review some important features of type systems and how they manifest themselves
in Lisp.
</p>
</div>

<div id="outline-container-org6fff291" class="outline-3">
<h3 id="type-checking"><a href="#type-checking">Obtaining &amp; Checking Types</a></h3>
<div class="outline-text-3" id="text-type-checking">
<p>
The typing relationship “:” is usually deterministic in its second argument for
static languages: <code>e : τ  ∧  e : τ′  ⇒  τ ≈ τ′</code>. However this is not the case with
Lisp's <code>typep</code>.
</p>

<table>
<caption class="t-above"><span class="table-number">Table 2:</span> Where are the types &amp; <i>when</i> are they checked?</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Style</th>
<th scope="col" class="org-left">Definition</th>
<th scope="col" class="org-left">Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Static</td>
<td class="org-left">Variables have a fixed type; compile time</td>
<td class="org-left">Haskell &amp; C#</td>
</tr>

<tr>
<td class="org-left">Dynamic</td>
<td class="org-left">Values have a fixed type; runtime</td>
<td class="org-left">Lisp &amp; Smalltalk</td>
</tr>
</tbody>
</table>

<p>
In some sense, dynamic languages make it easy to produce <a href="#org47d3d0a">polymorphic</a> functions.
Ironically, the previous sentences is only meaningful if you acknowledge the importance
of types and type variables.
</p>

<p>
In Lisp, types are inferred and needn't be declared.
However, the declaration serves as a nice documentation to further readers ;-)
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">setq</span> ellew 314)
(<span style="color: #b58900;">type-of</span> ellew) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; integer</span>

(<span style="color: #859900; font-weight: bold;">setq</span> ellew <span style="color: #2aa198;">"oh my"</span>)
(<span style="color: #b58900;">type-of</span> ellew) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; string</span>
</pre>
</div>
<ul class="org-ul">
<li>The <code>type-of</code> function returns the type of a given object.</li>
<li>Re variables: Static ⇒ only values can change; dynamic ⇒ both values and types change.</li>
</ul>

<p>
We may check the type of an item using <code>typep</code>, whose second argument
is a “type specifiers”
 &#x2014;an expressions whose value denotes a type; e.g., the <code>or</code> expression below
 forms a ‘union type’.
</p>

<p>
There's also <code>check-type</code>: It's like <code>typep</code> but instead of yielding true or
false, it stays quiet in the former and signals a type error in the latter.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">check-type</span> 12 integer)               <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil, i.e., no error</span>
(<span style="color: #859900; font-weight: bold;">check-type</span> 12   (<span style="color: #859900; font-weight: bold;">or</span> symbol integer)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">nil; i.e., no error</span>
(<span style="color: #859900; font-weight: bold;">check-type</span> <span style="color: #2aa198;">"12"</span> (<span style="color: #859900; font-weight: bold;">or</span> symbol integer)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Crash: Type error!</span>
</pre>
</div>

<p>
In summary:
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>(equal τ (type-of e))</code></td>
<td class="org-left"><code>≈</code></td>
<td class="org-left"><code>(typep e τ)</code></td>
</tr>

<tr>
<td class="org-left"><code>(check-type e τ)</code></td>
<td class="org-left"><code>≈</code></td>
<td class="org-left"><code>(unless (typep e 'τ) (error "⋯"))</code></td>
</tr>
</tbody>
</table>

<p>
( Note: (<code>unless x y) ≈ (when (not x) y)</code> .)
</p>
</div>
</div>
<div id="outline-container-org3063a33" class="outline-3">
<h3 id="lisp-is-eval"><a href="#lisp-is-eval">Statics &amp; Dynamics of Lisp</a></h3>
<div class="outline-text-3" id="text-lisp-is-eval">
<blockquote>
<p>
Types are the central organising principle of the theory of programming languages.
Language features are manifestations of type structure.
The syntax of a language is governed by the constructs that define its types, and
its semantics is determined by the interactions among those constructs.
</p>

<p>
&#x2014; Robert Harper, Practical Foundations for Programming Languages
</p>
</blockquote>

<p>
Besides atoms like numbers and strings,
the only way to form new terms in Lisp is using “modus ponens”,
or “function application”. Here's a first approximation:
</p>
<div class="org-src-container">
<pre class="src src-math">f : τ₁ → ⋯ → τₙ → τ   e₁ : τ₁  …  eₙ : τₙ
-----------------------------------------------------------------------------------------
           (f e₁ … eₙ) : τ
</pre>
</div>
<p>
One reads such a fraction as follows: If each part of the numerator &#x2014;the ‘hypothesises’&#x2014; is true, then so is the denominator &#x2014;the ‘conclusion’.
</p>

<p>
An <i>abstract syntax tree</i>, or ‘AST’, is a tree with operators for branches
and arguments for children. A tree is of kind τ if the topmost branching operator has τ as its resulting type. Here's an improved rule:
</p>
<div class="org-src-container">
<pre class="src src-math">f : τ₁ → ⋯ → τₙ → τ   e₁ : AST τ₁  …  eₙ : AST τₙ
-----------------------------------------------------------------------------------------
              (f e₁ … eₙ) : AST τ
</pre>
</div>

<p>
A Lisp top-level then may execute or interpret such a form to obtain a value:
When we write <code>e</code> at a top-level, it is essentially <code>(eval e)</code> that is invoked.
</p>
<div class="org-src-container">
<pre class="src src-math">   e : AST τ
-----------------------------------------------------------------------------------------
  (eval e) : τ
</pre>
</div>

<p>
However, we may also protect against evaluation.
</p>
<div class="org-src-container">
<pre class="src src-math">     e : AST τ
-----------------------------------------------------------------------------------------
  (quote e) : AST τ
</pre>
</div>

<p>
We have the following execution rules, where ‘⟿’ denotes “reduces to”.
</p>
<div class="org-src-container">
<pre class="src src-math">(eval a)         ⟿ a                        ;; for atom ‘a’
(eval (quote e))   ⟿ e
(eval (f e₁ … eₙ)) ⟿ (f (eval e₁) ⋯ (eval eₙ)) ;; Actually invoke ‘f’
</pre>
</div>

<div class="org-center">
<p>
<i>A conceptual model of Lisp is <code>eval</code>.</i>
</p>
</div>
</div>
</div>

<div id="outline-container-orgf1d8860" class="outline-3">
<h3 id="lisp-is-dynamic"><a href="#lisp-is-dynamic">Variable Scope</a></h3>
<div class="outline-text-3" id="text-lisp-is-dynamic">
<p>
There's also the matter of “scope”, or ‘life time’, of a variable.
</p>

<table>
<caption class="t-above"><span class="table-number">Table 3:</span> Local variables temporarily mask global names …</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Style</th>
<th scope="col" class="org-left">Definition</th>
<th scope="col" class="org-left">Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Lexical</td>
<td class="org-left">… only in visible code</td>
<td class="org-left">Nearly every language!</td>
</tr>

<tr>
<td class="org-left">Dynamic</td>
<td class="org-left">… every place imaginable</td>
<td class="org-left">Bash, Perl, &amp; allowable in some Lisps</td>
</tr>
</tbody>
</table>

<p>
That is, dynamic scope means a local variable not only acts as a global variable
for the rest of the scope but it does so even in the definitions of pre-defined methods
being invoked in the scope.
</p>
<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #859900; font-weight: bold;">setq</span> it <span style="color: #2aa198;">"bye"</span>)
(<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">go</span> () it)
(<span style="color: #859900; font-weight: bold;">let</span> ((it 3)) (<span style="color: #b58900;">go</span>)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 3; even though &#8220;it&#8221; does not occur textually!</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Temporarily enable lexical binding in Emacs Lisp</span>
(<span style="color: #859900; font-weight: bold;">setq</span> <span style="color: #268bd2;">lexical-binding</span> <span style="color: #268bd2;">t</span>)
(<span style="color: #859900; font-weight: bold;">let</span> ((it 3)) (<span style="color: #b58900;">go</span>)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; bye; as most languages would act</span>
</pre>
</div>

<div class="org-center">
<p>
<i>Dynamic scope lets bindings leak down into all constituents in its wake.</i>
</p>
</div>

<p>
That is fantastic when we want to do <a href="https://nullprogram.com/blog/2012/08/15/">unit tests</a> involving utilities with side-effects:
We simply locally re-define the side-effect component to, say, do nothing. (─‿‿─)
</p>
</div>
</div>

<div id="outline-container-org27b07c8" class="outline-3">
<h3 id="lisp-is-strong"><a href="#lisp-is-strong">Casts &amp; Coercions</a></h3>
<div class="outline-text-3" id="text-lisp-is-strong">
<table>
<caption class="t-above"><span class="table-number">Table 4:</span> The frequency of implicit type coercions</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Style</th>
<th scope="col" class="org-left">Definition</th>
<th scope="col" class="org-left">Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Strong</td>
<td class="org-left">Almost never</td>
<td class="org-left">Lisp &amp; Haskell</td>
</tr>

<tr>
<td class="org-left">Weak</td>
<td class="org-left">Try as best as possible</td>
<td class="org-left">JavaScript &amp; C</td>
</tr>
</tbody>
</table>

<p>
<i>Strong systems will not accidentally coerce terms.</i>
</p>

<p>
Lisp has a <a href="http://www.lispworks.com/documentation/lw51/CLHS/Body/f_coerce.htm#coerce">coerce</a> form; but coercion semantics is generally unsound
in any language and so should be used with tremendous caution.
( Though Haskell has some sensible coercions as well as unsafe one. )
</p>
<div class="org-src-container">
<pre class="src src-math">     e : α
----------------------------------------------------------------------------------------
(coerce e β) : β
</pre>
</div>
<p>
We have a magical way to turn elements of type α to elements of type β.
Some languages call this <i>type casting</i>.
</p>

<p>
Here's a cute example.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">coerce</span> '(76 105 115 112) '<span style="color: #b58900;">string</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; Lisp</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org37aac7e" class="outline-3">
<h3 id="type-annotations"><a href="#type-annotations">Type Annotations</a></h3>
<div class="outline-text-3" id="text-type-annotations">
<p>
We may perform type annotations using the form <code>the</code>; e.g.,
the Haskell expression <code>(1 :: Int) + 2</code> checks the type annotation,
and, if it passes, yields the value and the expression is computed.
Likewise, <code>(the type name)</code> yields <code>name</code> provided it has type <code>type</code>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">+</span> (<span style="color: #859900; font-weight: bold;">the</span> integer 1)
   (<span style="color: #859900; font-weight: bold;">the</span> integer 2)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 3</span>

(<span style="color: #b58900;">+</span> (<span style="color: #859900; font-weight: bold;">the</span> integer 1)
   (<span style="color: #859900; font-weight: bold;">the</span> integer <span style="color: #2aa198;">"2"</span>)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; Type error.</span>
</pre>
</div>

<p>
Computationally, using <code>or</code> as a control structure for lazy sequencing with left-unit <code>nil</code>:
</p>
<table>


<colgroup>
<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>(the τ e) ≈ (or (check-type e τ) e)</code></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org2fd4b43" class="outline-3">
<h3 id="typecase"><a href="#typecase">Type-directed Computations</a></h3>
<div class="outline-text-3" id="text-typecase">
<p>
Sometimes a value can be one of several types.
This is specified using union types; nested unions are essentially flattened
&#x2014;which is a property of ‘or’, as we shall come to see.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">typep</span> 12 'integer)  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
(<span style="color: #b58900;">typep</span> 'a 'symbol)   <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>

(<span style="color: #859900; font-weight: bold;">setq</span> woah 12)
(<span style="color: #b58900;">typep</span> woah '(<span style="color: #859900; font-weight: bold;">or</span> integer symbol)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>

(<span style="color: #859900; font-weight: bold;">setq</span> woah 'nice)
(<span style="color: #b58900;">typep</span> woah '(<span style="color: #859900; font-weight: bold;">or</span> integer symbol)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
</pre>
</div>

<p>
When given a union type, we may want to <i>compute according to the type of a value.</i>
</p>
<ul class="org-ul">
<li>Case along the possible types using <code>typecase</code>.</li>
<li>This returns a <code>nil</code> when no case fits; use <code>etypecase</code> to have an error instead of <code>nil</code>.</li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">typecase</span> woah
  (integer  (+1 woah))
  (symbol  'cool)
  (<span style="color: #268bd2;">t</span>       <span style="color: #2aa198;">"yikes"</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org0d9dc55" class="outline-3">
<h3 id="type-specifiers"><a href="#type-specifiers">Type Specifiers: On the nature of types in Lisp</a></h3>
<div class="outline-text-3" id="text-type-specifiers">
<blockquote>
<p>
Types are not objects in Common Lisp. There is no object that corresponds to the type
<code>integer</code>, for example. What we get from a function like <code>type-of</code>, and give as an argument
to a function like <code>typep</code>, is not a type, but a type specifier.
A type specifier is the name of a type. &#x2014;Paul Graham, ANSI Common Lisp
</p>
</blockquote>

<p>
Type specifiers are essentially transformed into predicates as follows.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">typep</span> x '&#964;)                &#8776; (&#964;p x)  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">E.g., &#964; &#8776; integer</span>
(<span style="color: #b58900;">typep</span> x '(<span style="color: #859900; font-weight: bold;">and</span> &#964;&#8321; &#8230; &#964;&#8345;))    &#8776; (<span style="color: #859900; font-weight: bold;">and</span> (<span style="color: #b58900;">typep</span> x &#964;&#8321;) &#8230; (<span style="color: #b58900;">typep</span> x &#964;&#8345;))
(<span style="color: #b58900;">typep</span> x '(<span style="color: #859900; font-weight: bold;">or</span> &#964;&#8321; &#8230; &#964;&#8345;))     &#8776; (<span style="color: #859900; font-weight: bold;">or</span> (<span style="color: #b58900;">typep</span> x &#964;&#8321;) &#8230; (<span style="color: #b58900;">typep</span> x &#964;&#8345;))
(<span style="color: #b58900;">typep</span> x '(<span style="color: #b58900;">not</span> &#964;))          &#8776; (<span style="color: #b58900;">not</span> (<span style="color: #b58900;">typep</span> x &#964;))
(<span style="color: #b58900;">typep</span> x '(<span style="color: #b58900;">member</span> e&#8321; &#8230; e&#8345;)) &#8776; (<span style="color: #859900; font-weight: bold;">or</span> (<span style="color: #b58900;">eql</span> x e&#8321;) &#8230; (<span style="color: #b58900;">eql</span> x e&#8345;))
(<span style="color: #b58900;">typep</span> x '(satisfies p))    &#8776; (p x)
</pre>
</div>

<p>
Type specifiers are thus essentially ‘characteristic functions’ from mathematics.
</p>
</div>
</div>

<div id="outline-container-org55b8f15" class="outline-3">
<h3 id="deftype"><a href="#deftype">Making New Types with <code>deftype</code></a></h3>
<div class="outline-text-3" id="text-deftype">
<p>
If we use a type specifier often, we may wish to abbreviate it using
the <a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#index-cl_002ddeftype-14">deftype</a> macro &#x2014;it is like <code>defmacro</code> but expands into a type specifier
instead of an expression.
</p>

<p>
We can define new types that will then work with <code>typecase</code> and friends
as follows:
</p>
<ol class="org-ol">
<li>Define a predicate <code>my-type-p</code>.</li>
<li>Test it out to ensure only the elements you want satisfy it.</li>
<li><p>
Register it using <a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#index-cl_002ddeftype-14">deftype</a>.
</p>

<p>
You could just do number 3 directly, but it's useful to have the
predicate form of a <a href="#org0c7dfd1">type descriptor</a>.
</p></li>
</ol>

<p>
<a href="https://lispcookbook.github.io/cl-cookbook/type.html">For example,</a> here's the three steps for a type of lists of numbers drawn from <code>(-∞..9]</code>.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Make the predicate</span>
(<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">small-number-seq-p</span> (thing)
  (<span style="color: #859900; font-weight: bold;">and</span> (<span style="color: #b58900;">sequencep</span> thing)
       (<span style="color: #b58900;">every</span> #'<span style="color: #b58900;">numberp</span> thing)
       (<span style="color: #b58900;">every</span> (<span style="color: #859900; font-weight: bold;">lambda</span> (x) (<span style="color: #b58900;">&lt;</span> x 10)) thing)))

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Test it</span>
(<span style="color: #859900; font-weight: bold;">setq</span> yes '(1 2  4))
(<span style="color: #859900; font-weight: bold;">setq</span> no  '(1 20 4))
(small-number-seq-p yes) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Register it</span>
(<span style="color: #859900; font-weight: bold;">deftype</span> small-number-seq ()
  '(satisfies small-number-seq-p))

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Use it</span>
(<span style="color: #b58900;">typep</span> yes 'small-number-seq) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> no 'small-number-seq)  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
</pre>
</div>

<p>
Arguments are processed the same as for <code>defmacro</code> except that optional
arguments without explicit defaults use <code>*</code> instead of <code>nil</code> as the default value.
<a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#index-cl_002ddeftype-14">From the deftype docs, here are some examples:</a>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">cl-deftype</span> <span style="color: #b58900; font-style: italic;">null</span> () '(satisfies <span style="color: #b58900;">null</span>))    <span style="color: #96A7A9; font-style: italic;">; </span><span style="color: #96A7A9; font-style: italic;">predefined</span>
(<span style="color: #859900; font-weight: bold;">cl-deftype</span> <span style="color: #b58900; font-style: italic;">list</span> () '(<span style="color: #859900; font-weight: bold;">or</span> <span style="color: #b58900;">null</span> <span style="color: #b58900;">cons</span>))      <span style="color: #96A7A9; font-style: italic;">; </span><span style="color: #96A7A9; font-style: italic;">predefined</span>

(<span style="color: #859900; font-weight: bold;">cl-deftype</span> <span style="color: #b58900; font-style: italic;">unsigned-byte</span> (<span style="color: #b58900; font-style: italic;">&amp;optional</span> bits)
  (<span style="color: #b58900;">list</span> 'integer 0 (<span style="color: #859900; font-weight: bold;">if</span> (<span style="color: #b58900;">eq</span> bits '<span style="color: #b58900;">*</span>) bits (<span style="color: #b58900;">1-</span> (<span style="color: #b58900;">lsh</span> 1 bits)))))

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Some equivalences</span>
(unsigned-byte 8)  &#8801;  (integer 0 255)
(unsigned-byte)    &#8801;  (integer 0 <span style="color: #b58900;">*</span>)
unsigned-byte      &#8801;  (integer 0 <span style="color: #b58900;">*</span>)
</pre>
</div>

<ul class="org-ul">
<li>Notice that type specifiers essentially live in their own namespace; e.g., <code>null</code> is the
predicate that checks if a list is empty yet <code>null</code> is the type specifying such lists.</li>
</ul>

<p>
Let's form a type of pairs directly &#x2014;which is not ideal!
This is a <a id="org47d3d0a">polymorphic</a> datatype: It takes two type arguments, called <code>a</code> and <code>b</code> below.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">deftype</span> pair (a b <span style="color: #b58900; font-style: italic;">&amp;optional</span> type)
  `(satisfies (<span style="color: #859900; font-weight: bold;">lambda</span> (x) (<span style="color: #859900; font-weight: bold;">and</span>
      (<span style="color: #b58900;">consp</span> x)
      (<span style="color: #b58900;">typep</span> (<span style="color: #b58900;">car</span> x) (<span style="color: #859900; font-weight: bold;">quote</span> ,a))
      (<span style="color: #b58900;">typep</span> (<span style="color: #b58900;">cdr</span> x) (<span style="color: #859900; font-weight: bold;">quote</span> ,b))))))

(<span style="color: #b58900;">typep</span> '(<span style="color: #2aa198;">"x"</span> . 2) '(pair <span style="color: #b58900;">string</span> integer)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> '(<span style="color: #2aa198;">"x"</span> . 2) '(pair symbol integer)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
(<span style="color: #b58900;">typep</span> nil '(pair integer integer))       <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
(<span style="color: #b58900;">typep</span> 23 '(pair integer integer))        <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>

(<span style="color: #859900; font-weight: bold;">setq</span> ss <span style="color: #2aa198;">"nice"</span> nn 114)
(<span style="color: #b58900;">typep</span> `(,ss . ,nn) '(pair <span style="color: #b58900;">string</span> integer)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> (<span style="color: #b58900;">cons</span> ss nn) '(pair <span style="color: #b58900;">string</span> integer)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">The following are false since ss and nn are quoted symbols!</span>
(<span style="color: #b58900;">typep</span> '(ss . nn)    '(pair <span style="color: #b58900;">string</span> integer)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
(<span style="color: #b58900;">typep</span> `(<span style="color: #b58900;">cons</span> ss nn) '(pair <span style="color: #b58900;">string</span> integer)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
</pre>
</div>

<p>
<b>Exercise:</b> Define the <a href="#org47d3d0a">polymorphic</a> <code>maybe</code> type
such that <code>(maybe τ)</code> has elements being either <code>nil</code> or a value of <code>τ</code>.
</p>
<p>
Let's define type <code>list-of</code> such that <code>(list-of τ)</code> is the type of lists
whose elements are all values of type <code>τ</code>.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Make the predicate</span>
(<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">list-of-p</span> (&#964; thing)
  (<span style="color: #859900; font-weight: bold;">and</span> (<span style="color: #b58900;">listp</span> thing) (<span style="color: #b58900;">every</span> (<span style="color: #859900; font-weight: bold;">lambda</span> (x) (<span style="color: #b58900;">typep</span> x &#964;)) thing)))

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Test it</span>
(list-of-p 'integer '(1 2   3)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(list-of-p 'integer '(1 two 3)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
(list-of-p '<span style="color: #b58900;">string</span> '())         <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(list-of-p '<span style="color: #b58900;">string</span> '(no))       <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Register it</span>
(<span style="color: #859900; font-weight: bold;">deftype</span> list-of (&#964;)
  `(satisfies (<span style="color: #859900; font-weight: bold;">lambda</span> (thing) (list-of-p (<span style="color: #859900; font-weight: bold;">quote</span> ,&#964;) thing))))

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Use it</span>

(<span style="color: #b58900;">typep</span> '(1 2  ) '<span style="color: #b58900;">list</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> '(1 two) '<span style="color: #b58900;">list</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>

(<span style="color: #b58900;">typep</span> '(1 2)   '(list-of integer)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> '(1 <span style="color: #2aa198;">"2"</span>) '(list-of <span style="color: #b58900;">string</span>))  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
(<span style="color: #b58900;">typep</span> '(1 <span style="color: #2aa198;">"2"</span>) '(list-of (<span style="color: #859900; font-weight: bold;">or</span> integer <span style="color: #b58900;">string</span>)))  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
</pre>
</div>

<p>
Notice that by the last example we can <b>control the degree of heterogeneity</b> in our lists!
So cool!
</p>

<p>
Here's some more exercises. The first should be nearly trivial, the second a bit more
work, and the last two have made me #sad.
</p>

<ol class="org-ol">
<li>Define a type <code>(rose τ)</code> whose elements are either τ values or rose trees of type τ.</li>

<li>Define a type <code>record</code> so that <code>(record τ₁ … τₙ)</code> denotes a record type whose iᵗʰ
component has type <code>τᵢ</code>.</li>

<li><p>
Define a type constructor <code>∃</code> such that, for example, <code>(∃ τ (pair integer τ)</code>
denotes the type of pairs where the first components are integers and the second
components all have the same type <code>τ</code>, but we do not know which one.
</p>

<p>
My idea was to let <code>τ</code> denote the type of the first occurrence of a value
at that location, then all subsequent checks now refer to this value of <code>τ</code>.
</p>

<p>
Sadly, I could not define this type :'(
</p>

<p>
Upon further reading, this may be doable using a <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Watching-Variables.html#Watching-Variables">variable watcher</a>.
</p></li>

<li><p>
Produce a record for monoids and keep-track of the monoid instances produced.
Define a the predicate <code>(monoid τ)</code> to check if any of the monoid instances
has <code>τ</code> as its carrier type. In this way we could simulate Haskell typeclasses.
</p></li>
</ol>

<p>
Let me know if you do cool things!
</p>
</div>
</div>
<div id="outline-container-org646dad0" class="outline-3">
<h3 id="adts"><a href="#adts">Algebraic Data Types a la Haskell</a></h3>
<div class="outline-text-3" id="text-adts">
<p>
Consider the Haskell expression type, example, and integer evaluator.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">data</span> <span style="color: #b58900; font-style: italic;">Expr</span> a <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Var</span> a <span style="color: #268bd2;">|</span> <span style="color: #b58900; font-style: italic;">Expr</span> a <span style="color: #b58900; font-style: italic;">:+:</span> <span style="color: #b58900; font-style: italic;">Expr</span> a <span style="color: #268bd2;">|</span> <span style="color: #b58900; font-style: italic;">Neg</span> (<span style="color: #b58900; font-style: italic;">Expr</span> a) <span style="color: #859900; font-weight: bold;">deriving</span> <span style="color: #b58900; font-style: italic;">Show</span>

<span style="color: #b58900;">ex</span> <span style="color: #268bd2;">::</span> <span style="color: #b58900; font-style: italic;">Expr</span> <span style="color: #b58900; font-style: italic;">Int</span>
<span style="color: #b58900;">ex</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Var</span> 5 <span style="color: #b58900; font-style: italic;">:+:</span> (<span style="color: #b58900; font-style: italic;">Var</span> 6 <span style="color: #b58900; font-style: italic;">:+:</span> <span style="color: #b58900; font-style: italic;">Neg</span> (<span style="color: #b58900; font-style: italic;">Var</span> 7))

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">::</span> <span style="color: #b58900; font-style: italic;">Expr</span> <span style="color: #b58900; font-style: italic;">Int</span> <span style="color: #268bd2;">-&gt;</span> <span style="color: #b58900; font-style: italic;">Int</span>
<span style="color: #b58900;">int</span> (<span style="color: #b58900; font-style: italic;">Var</span> n)    <span style="color: #268bd2;">=</span> n
<span style="color: #b58900;">int</span> (l <span style="color: #b58900; font-style: italic;">:+:</span> r)  <span style="color: #268bd2;">=</span> int l <span style="color: #268bd2;">+</span> int r
<span style="color: #b58900;">int</span> (<span style="color: #b58900; font-style: italic;">Neg</span> e)    <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">-</span> (int e)

<span style="color: #96A7A9; font-style: italic;">{- </span><span style="color: #96A7A9; font-style: italic;">int ex &#8658; 4 -}</span>
</pre>
</div>

<p>
If we view a constructor declaration <code>C a₁ … aₙ</code> with superfluous parenthesis
as <code>(C a₁ … aₙ)</code>, then a translation to Lisp immediately suggests itself:
</p>
<div class="org-center">
<p>
<i>Haskell constructors ≅ Lisp lists whose <code>car</code> are constructor names</i>
</p>
</div>

<p>
A nearly direct translation follows.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">exprp</span> (&#964; thing)
    (pcase thing
       (`(var ,n)    (typep n &#964;))
       (`(add ,l ,r) (and (exprp &#964; l) (exprp &#964; r)))
       (`(neg ,e)    (exprp &#964; e))))

(setq ex '(add (var 5) (add (var 6) (neg (var 7)))))
(exprp 'integer ex) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>

<span style="color: #96A7A9; font-style: italic;">; </span><span style="color: #96A7A9; font-style: italic;">This declarion &#8220;declare-type&#8221; is defined near the end of this article.</span>
(declare-type int : (expr-of integer) integer)
(<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">int</span> (thing)
    (pcase thing
       (`(var ,n)    n)
       (`(add ,l ,r) (+ (int l) (int r)))
       (`(neg ,e)    (- (int e)))))

(int ex) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 4</span>
</pre>
</div>

<p>
There are of-course much better ways to do this in Lisp; e.g.,
use <code>identity, +, -</code> in-place of the <code>var, add, neg</code> tags
to produce “syntax that carries its semantics”
or express the interpreter <code>int</code> as a one liner
by replacing the formal tags with their interpretations then
invoking Lisps <code>eval</code>. I doubt either of these are new ideas,
but the merit of the former seems neat &#x2014;at a first glance, at least.
</p>

<p>
Support for ADTs in Common Lisp along with seemingly less clunky pattern matching
can be found <a href="https://github.com/stylewarning/cl-algebraic-data-type">here</a> &#x2014;which I have only briefly looked at.
</p>

<p>
The Haskell presentation has type-checking baked into it, yet our
Lisp interpreter <code>int</code> does not! This seems terribly worrying, but
that <a href="#org7d207a3"><code>declare-type</code></a> declaration actually handles type checking for us!
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Register the type</span>
(<span style="color: #859900; font-weight: bold;">deftype</span> <span style="color: #b58900; font-style: italic;">expr-of</span> (&#964;)
  `(satisfies (<span style="color: #859900; font-weight: bold;">lambda</span> (thing) (exprp (quote ,&#964;) thing))))

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Try it out</span>
(typep '(1 2)   '(expr-of integer)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil</span>
(typep ex   '(expr-of integer))     <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">This invocation, for example, now yields a helpful error message.</span>
(int '(var 6 4))
<span style="color: #96A7A9; font-style: italic;">;;</span>
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; int: Type mismatch! Expected (expr-of integer) for argument 0 &#8800; Given cons (var 6 4).</span>
<span style="color: #96A7A9; font-style: italic;">;;</span>
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Which is reasonable since the &#8216;</span><span style="color: #6c71c4; font-weight: bold; font-style: italic;">var</span><span style="color: #96A7A9; font-style: italic;">&#8217; constructor only takes a single argument.</span>
</pre>
</div>
<p>
Notice that invalid cases yield a helpful (run-time) error message!
</p>
</div>
</div>
</div>

<div id="outline-container-orgefbcbac" class="outline-2">
<h2 id="why-dynamic"><a href="#why-dynamic">In Defence of Being Dynamically Checked</a></h2>
<div class="outline-text-2" id="text-why-dynamic">
<div class="org-center">
<p>
<i>Lisp gets a bad rap for being untyped; let's clarify this issue further!</i>
</p>
</div>

<p>
It is important to realise that nearly every language is typed &#x2014;albeit the checking
may happen at different stages&#x2014; and so, as <a href="http://www.cis.upenn.edu/~bcpierce/tapl/index.html">Benjamin Pierce</a> says:
<i>Terms like “dynamically typed” are arguably misnomers and should probably be replaced by “dynamically checked,” but the usage is standard.</i>
</p>

<p>
In particular, dynamically typed is <i>not</i> synonymous with untyped, though some people use
it that way since nearly <a href="https://www.williamjbowman.com/blog/2018/01/19/untyped-programs-don-t-exist/#related">every language is typed</a> &#x2014;possibly with a single anonymous
type.
</p>

<p>
Some people in the Haskell community, which I love, say things like
<i>“if it typechecks, ship it”</i> which is true more often than not, but it leads some
people to avoid producing unit tests. For example, the following type checks but
should be unit tested.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900;">mcbride</span> <span style="color: #268bd2;">::</span> [<span style="color: #b58900; font-style: italic;">Int</span>] <span style="color: #268bd2;">-&gt;</span> <span style="color: #b58900; font-style: italic;">Int</span>
<span style="color: #b58900;">mcbride</span> xs <span style="color: #268bd2;">=</span> <span style="color: #859900; font-weight: bold;">if</span> null xs <span style="color: #859900; font-weight: bold;">then</span> head xs <span style="color: #859900; font-weight: bold;">else</span> 666
</pre>
</div>

<p>
Regardless, I love static type checking and static analysis in general.
However, the shift to a dynamically checked setting has resulted in greater
interest in unit testing. For example, Haskell's solution to effectful computation
is delimited by types, as any Haskeller will proudly say (myself included);
but ask how are such computations unit tested and the room is
silent (myself included).
</p>

<p>
Interestingly some unit tests check the typing of inputs and output, which is
a mechanical process with no unknowns and so it should be possible to produce a syntax
for it using Lisp macros. This is one of the goals of this article and we'll return to
it later.
</p>

<p>
Even though I like Lisp, I'm not sure why dynamic typing is the way to go
&#x2014;c.f. <a href="https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/">Dynamic Languages are Static Languages</a> which mentions the unjust tyranny of
unityped systems.
Below are two reasons why people may dislike static types.
</p>

<p>
<b>First</b>: The de-facto typing rule do binary choice is usually:
</p>
<div class="org-src-container">
<pre class="src src-math">     T : 𝔹     E : α     B : α -----------------------------------------------------------------------------------------
     if T then E else B : α
</pre>
</div>

<p>
That means valid programs such as <code>if True then 1 else "two"</code> are rejected;
even though the resulting type will always be an integer there is no way to know
that statically &#x2014;the choice needs to be rewritten, evaluated at run time.
</p>

<p>
Indeed, in Haskell, we would write
<code>if True then Left 1 else Right "two"</code> which has type <code>Either Int String</code>,
and to use the resulting value means we need to pattern match or use
the eliminator <code>(|||</code>) &#x2014;from Haskell's <code>Control.Arrow</code>.
</p>

<p>
<b>Second:</b>
Some statically typed languages have super weak type systems and ruin the rep
for everyone else.
For example, <code>C</code> is great and we all love it of-course, but it's a shame that we can only
express the <a href="#org47d3d0a">polymorphic</a> identity function \(id : ∀{α}. α → α \;=\; λ x → x\),
by using the C-preprocessor &#x2014;or dismiss the types by casting pointers around.
</p>

<p>
Maybe this video is helpful, maybe not:
<a href="https://games.greggman.com/game/dynamic-typing-static-typing/">The Unreasonable Effectiveness of Dynamic Typing for Practical Programs</a>
</p>

<blockquote>
<p>
( For the algebraist: Dynamic typing is like working in a monoid whose
composition operation is partial and may abruptly crash; whereas static typing
is working in a category whose composition is proudly typed. )
</p>
</blockquote>

<p>
Overall I haven't presented a good defence for being dynamically checked, but you
should ignore my blunder and consider trying Lisp yourself to see how awesome it is.
</p>
</div>
</div>

<div id="outline-container-orgfa91f03" class="outline-2">
<h2 id="lisp-funny-history"><a href="#lisp-funny-history">With its hierarchy of types, why isn't Lisp statically typed?</a></h2>
<div class="outline-text-2" id="text-lisp-funny-history">
<div class="org-center">
<p>
<i>I haven't a clue. Here are two conjectures.</i>
</p>
</div>

<p>
<b>First</b>: Code that manipulates code is difficult to type.
</p>

<p>
Is the type of <code>'(+ x 2)</code> a numeric code expression?
Or just an arbitrary code expression? Am I allowed to “look inside”
to inspect its structure or is it a black box? What about the nature of
its constituents? If I'm allowed to look at them, can I ask if they're even defined?
</p>

<p>
What if <code>c</code> is a code element that introduces an identifier, say <code>it</code>.
What is type of <code>c</code>? What if it doesn't introduce and thus avoids accidentally
capturing identifiers? Are we allowed only one form or both? Which do we select
and why?
</p>

<p>
I may be completely wrong, but below I mention a <a href="#org37d3bcd">bunch of papers</a> that suggest
it's kind hard to type this stuff.
</p>

<p>
<b>Second</b>: The type theory just wasn't in place at the time Lisp was created.
</p>

<p>
Here's a probably wrong account of how it went down.
</p>

<dl class="org-dl">
<dt>1913ish</dt><dd>Bertrand Russel introduces a hierarchy of types to avoid barber trouble;
e.g., <code>Typeᵢ : Typeᵢ₊₁</code>.</dd>
<dt>1920s</dt><dd>A Polish guy &amp; British guy think that's dumb and collapse the hierarchy.</dd>
<dt>1940s</dt><dd>Alonzo Church says arrows are cool.</dd>
<dt>1958 </dt><dd><p>
With his awesome hairdo, John McCarthy gifts the world an elegant
piece of art: Lisp (•̀ᴗ•́)و
</p>
<ul class="org-ul">
<li>Lisp is currently the 2ⁿᵈ oldest high-level language still
in use after Fortran.</li>
<li>Maxwell's equations <a href="https://queue.acm.org/detail.cfm?id=1039523">get</a> <a href="http://www.michaelnielsen.org/ddi/lisp-as-the-maxwells-equations-of-software/">jealous</a>.</li>
</ul>

<p>
Lisp introduces a bunch of zany ideas to CS:
</p>
<ul class="org-ul">
<li>Introduced if-then-else “McCarthy's Conditional”; 1ˢᵗ class functions &amp; recursion</li>
<li>macros ≈ compiler plugins</li>
<li>symbols ≈ raw names which needn't have values</li>
<li>variables ≈ pointers</li>
<li>code ≈ data; statements ≈ expressions</li>
<li><code>read, eval, load, compile, print</code> are all functions!</li>
</ul></dd>

<dt>1959</dt><dd>My man JM thinks manual memory is lame &#x2014;invents garbage collection!
<ul class="org-ul">
<li>Later, 2001, he writes <a href="https://web.archive.org/web/20130814213421/http://www-formal.stanford.edu/jmc/robotandbaby/robotandbaby.html">The Robot &amp; The Baby</a>.</li>
</ul></dd>
<dt>1960s</dt><dd>Simula says OOPs!</dd>
<dt>1970s</dt><dd>Smalltalk popularises the phrase “oop”. ( B has a child named C. )</dd>
<dt>1970s</dt><dd>Simple λ-calculus is a fashion model for sets and functions.</dd>
<dt>1970s</dt><dd>Milner and friends demand
<i>variables are for types too, not just terms!</i></dd>
<dt>1970s</dt><dd>Per Martin-Löf tells us it's okay to depend on one another; <code>Π, Σ</code> types.</dd>
<dt>1982 </dt><dd>A Lisp <a href="https://en.wikipedia.org/wiki/Ummah">ummah</a> is formed: <a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node1.html">“Common Lisp the Language”</a> ♥‿♥
<ul class="org-ul">
<li>In order to be hip &amp; modern, it's got <a href="https://extravagaria.com/Files/LASC-Overview.pdf">class</a> with <a href="https://en.wikipedia.org/wiki/Common_Lisp_Object_System">CLOS</a>.</li>
<li>Other shenanigans: Scheme 1975, Elisp 1985, Racket 1995, Clojure 2007</li>
</ul></dd>
<dt>1984</dt><dd>A script of sorcerous schemes lords lisp over mere mortals</dd>
<dt>1990s</dt><dd>A committee makes a sexy <a href="https://en.wiktionary.org/wiki/a_camel_is_a_horse_designed_by_a_committee">camel</a> named Haskell; Professor X's school make their own camel.
<ul class="org-ul">
<li>Their kids get on steroids and fight to this day; Agda ↯↯↯ Coq.</li>
</ul></dd>
<dt>2000s</dt><dd><p>
X's camel .&lt;becomes .~(self .&lt;aware&gt;.)&gt;.
&#x2014;the other camel [does| the same].
</p>
<ul class="org-ul">
<li>In 2015, the cam ls married Lisp and <a href="https://luxlang.gitbooks.io/the-lux-programming-language/content/">Lux</a> was born.</li>
<li>In 2016, Haskell &amp; Lisp get involved with Prolog; <a href="https://shen-language.github.io/">Shen</a> is born.</li>
</ul>

<p>
2019: Coq is <a href="https://github.com/MetaCoq/metacoq">self-aware</a>; Agda is <a href="https://github.com/alhassy/gentle-intro-to-reflection">playing</a> <a href="https://alhassy.github.io/next-700-module-systems-proposal/prototype/PackageFormer.html">catch-up</a>.
</p></dd>
</dl>

<p>
A more informative historical account of Lisp &amp; its universal reverence can be read at:
<a href="https://twobithistory.org/2018/10/14/lisp.html">How Lisp Became God's Own Programming Language</a>.
</p>

<figure>
<img src="https://imgs.xkcd.com/comics/lisp.jpg" alt="lisp.jpg">

<figcaption><span class="figure-number">Figure 3: </span>xkcd</figcaption>
</figure>
</div>
</div>

<div id="outline-container-orgf50385b" class="outline-2">
<h2 id="lisp-is-typed"><a href="#lisp-is-typed">Lisp Actually Admits Static Typing!</a></h2>
<div class="outline-text-2" id="text-lisp-is-typed">
<p>
Besides Common Lisp, “Typed Lisps” include <a href="https://github.com/clojure/core.typed">an optional type system for Clojure</a>
&#x2014;see also <a href="https://circleci.com/blog/why-were-no-longer-using-core-typed/">Why we're no longer using Core.typed</a>&#x2014;
<a href="https://docs.racket-lang.org/ts-guide/">Typed Racket</a>, and, more recently, <a href="https://github.com/LuxLang/lux">Lux</a> ≈ Haskell + ML + Lisp
and  <a href="https://shen-language.github.io/">Shen</a> ≈ Haskell + Prolog + Lisp.
</p>

<p>
<a href="https://news.ycombinator.com/item?id=8593261">For example,</a> Common Lisp admits strong static typing, in <a href="http://www.lispforum.com/viewtopic.php?f=2&amp;t=191">SBCL</a>, as follows.
</p>
<div class="org-src-container">
<pre class="src src-common-lisp">  <span style="color: #96A7A9; font-style: italic;">; Type declaration then definition.</span>
  (<span style="color: #859900; font-weight: bold;">declaim</span> (ftype (function (fixnum)) num-id))
  (<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">num-id</span> (n) n)

  (<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">string-id</span> (s) (<span style="color: #859900; font-weight: bold;">declare</span> (string s)) (num-id s))
  <span style="color: #96A7A9; font-style: italic;">; in: DEFUN STRING-ID</span>
  <span style="color: #96A7A9; font-style: italic;">;     (NUM-ID S)</span>
  <span style="color: #96A7A9; font-style: italic;">;</span>
  <span style="color: #96A7A9; font-style: italic;">; caught WARNING:</span>
  <span style="color: #96A7A9; font-style: italic;">;   Derived type of S is</span>
  <span style="color: #96A7A9; font-style: italic;">;     (VALUES STRING &amp;OPTIONAL),</span>
  <span style="color: #96A7A9; font-style: italic;">;   conflicting with its asserted type</span>
  <span style="color: #96A7A9; font-style: italic;">;     FIXNUM.</span>
</pre>
</div>

<p>
Such annotations mostly serve as compiler optimisation annotations and,
unfortunately, Emacs Lisp <a href="https://www.gnu.org/software/emacs/manual/html_node/cl/Declarations.html">silently ignores Common Lisp declarations such as ftype</a>
&#x2014;which provides <a href="http://www.lispworks.com/documentation/lw51/CLHS/Body/d_ftype.htm#ftype">function type</a> declarations.
However,
Emacs Lisp does provide a method of <a href="http://www.p-cos.net/documents/filtered-dispatch.pdf">dispatch</a> filtered by <a href="http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html">classes</a> rather than by
simple types. Interestingly, Lisp methods are more like Haskell typeclass constituents
or C# extensible methods
rather than like Java object methods &#x2014;in that, <i>Lisp methods specialise on classes</i>
whereas Java's approach is <i>classes have methods</i>.
</p>

<p>
Here's an example.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">defmethod</span> <span style="color: #b58900;">doit</span> ((n integer)) <span style="color: #35a69c; font-style: italic;">"I'm an integer!"</span>)
(<span style="color: #859900; font-weight: bold;">defmethod</span> <span style="color: #b58900;">doit</span> ((s <span style="color: #b58900;">string</span>)) <span style="color: #35a69c; font-style: italic;">"I'm a string!"</span>)
(<span style="color: #859900; font-weight: bold;">defmethod</span> <span style="color: #b58900;">doit</span> ((type (<span style="color: #b58900;">eql</span> <span style="color: #d33682; font-style: italic;">:hero</span>)) thing) <span style="color: #35a69c; font-style: italic;">"I'm a superhero!"</span>)

(doit 2)             <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; I'm an integer!</span>
(doit <span style="color: #2aa198;">"2"</span>)           <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; I'm a string!</span>
(doit 'x)            <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; Error: No applicable method</span>
(doit <span style="color: #d33682; font-style: italic;">:hero</span> 'bobert) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; I'm a superhero!</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">C-h o cl-defmethod &#8658; see extensible list of specialisers Elisp supports.</span>
</pre>
</div>

<p>
We can of-course make our own classes:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">defclass</span> <span style="color: #b58900; font-style: italic;">person</span>  () ((name)))
(<span style="color: #859900; font-weight: bold;">defmethod</span> <span style="color: #b58900;">speak</span> ((x person)) (<span style="color: #b58900;">format</span> <span style="color: #2aa198;">"My name is %s."</span> (<span style="color: #b58900;">slot-value</span> x 'name)))
(<span style="color: #859900; font-weight: bold;">setq</span> p (<span style="color: #b58900;">make-instance</span> 'person))
(<span style="color: #859900; font-weight: bold;">setf</span> (<span style="color: #b58900;">slot-value</span> p 'name) <span style="color: #2aa198;">"bobert"</span>)
(speak p) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; My name is bobert.</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Inherits from &#8216;</span><span style="color: #6c71c4; font-weight: bold; font-style: italic;">person</span><span style="color: #96A7A9; font-style: italic;">&#8217; and has accessor &amp; constructor methods for a new slot</span>
(<span style="color: #859900; font-weight: bold;">defclass</span> <span style="color: #b58900; font-style: italic;">teacher</span> (person) ((topic <span style="color: #d33682; font-style: italic;">:accessor</span> teacher-topic <span style="color: #d33682; font-style: italic;">:initarg</span> <span style="color: #d33682; font-style: italic;">:studying</span>)))

(<span style="color: #859900; font-weight: bold;">defmethod</span> <span style="color: #b58900;">speak</span> ((x teacher))
  (<span style="color: #b58900;">format</span> <span style="color: #2aa198;">"My name is %s,and I study %s."</span> (<span style="color: #b58900;">slot-value</span> x 'name) (teacher-topic x)))

(<span style="color: #859900; font-weight: bold;">setq</span> ins (<span style="color: #b58900;">make-instance</span> 'teacher <span style="color: #d33682; font-style: italic;">:studying</span> <span style="color: #2aa198;">"mathematics"</span>))
(<span style="color: #859900; font-weight: bold;">setf</span> (<span style="color: #b58900;">slot-value</span> ins 'name) <span style="color: #2aa198;">"Robert"</span>)
(speak ins) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; My name is Robert, and I study mathematics.</span>
</pre>
</div>

<p>
Later in this article, we'll make something like the <code>declaim</code> above
but have it be effectful at run-time. <i>Typing as Macros!</i>
</p>

<blockquote>
<p>
(
If you happen to be interested in looking under the hood to see what compiler generated
code looks like use <code>disassemble</code>. For example, declare <code>(defun go (x) (+ 1 x) 'bye)</code>
then invoke <code>(disassemble 'go)</code> to see something like
<code>varref x⨾ add1⨾ discard ⨾ constant bye⨾ return</code>.
)
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgd79ea63" class="outline-2">
<h2 id="elisp-types"><a href="#elisp-types">ELisp's Type Hierarchy</a></h2>
<div class="outline-text-2" id="text-elisp-types">
<p>
⇨ Each primitive type has a corresponding Lisp function that checks whether an object is a
  member of that type. Usually, these are the type name appended with <code>-p</code>, for multi-word
  names, and <code>p</code> for single word names. E.g., <code>string</code> type has the predicate <code>stringp</code>.
</p>

<dl class="org-dl">
<dt><a id="org0c7dfd1">Type Descriptor</a></dt><dd><p>
Objects holding information about types.
</p>

<p>
This is a <code>record</code>; the <code>type-of</code> function returns the first slot of records.
</p></dd>
</dl>

<p>
This section is based <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Lisp-Data-Types.html#Lisp-Data-Types">GNU Emacs Lisp Reference Manual</a>, §2.3 “Programming Types”.
</p>
</div>

<div id="outline-container-orgfd1ef15" class="outline-3">
<h3 id="Number"><a href="#Number">Number</a></h3>
<div class="outline-text-3" id="text-Number">
<p>
<i>Numbers, including fractional and non-fractional types.</i>
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>integer</code></td>
<td class="org-left"><code>float</code></td>
<td class="org-left"><code>number</code></td>
<td class="org-left"><code>natnum</code></td>
<td class="org-left"><code>zero</code></td>
<td class="org-left"><code>plus</code></td>
<td class="org-left"><code>minus</code></td>
<td class="org-left"><code>odd</code></td>
<td class="org-left"><code>even</code></td>
</tr>
</tbody>
</table>

<p>
The relationships between these types are as follows:
</p>
<table>


<colgroup>
<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>(numberp x) ≈ (or (integerp x) (floatp x))</code></td>
</tr>

<tr>
<td class="org-left"><code>(natnump x) ≈ (and (integerp x) (≤ 0 x))</code></td>
</tr>

<tr>
<td class="org-left"><code>(zerop   x) ≈ (equal 0 x)</code></td>
</tr>

<tr>
<td class="org-left"><code>(plusp   x) ≈ (&lt; 0 x)</code></td>
</tr>

<tr>
<td class="org-left"><code>(minusp  x) ≈ (&gt; 0 x)</code></td>
</tr>

<tr>
<td class="org-left"><code>(evenp    x) ≈ (zerop (mod x 2))</code></td>
</tr>

<tr>
<td class="org-left"><code>(oddp     x) ≈ (not (oddp x))</code></td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li><p>
<b>Integer</b>: Numbers without fractional parts.
</p>

<p>
There is no overflow checking.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">expt</span> 2 60) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 1,152,921,504,606,846,976</span>
(<span style="color: #b58900;">expt</span> 2 61) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; -2,305,843,009,213,693,952</span>
(<span style="color: #b58900;">expt</span> 2 62) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 0</span>
</pre>
</div>

<p>
Numbers are written with an optional sign ‘+’ or ‘-’ at the beginning and
  an optional period at the end.
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>-1 ≈ -1.</code></td>
<td class="org-left"><code>1 ≈ +1 ≈ 1.</code></td>
</tr>
</tbody>
</table>

<p>
They may also take <i>inclusive</i> (and exclusive) ranges:
The type list <code>(integer LOW HIGH)</code> represents all integers between
 <code>LOW</code> and <code>HIGH</code>, inclusive.  Either bound may be a list of a single
 integer to specify an exclusive limit, or a <code>*</code> to specify no
 limit.  The type <code>(integer * *)</code> is thus equivalent to <code>integer</code>.
 Likewise, lists beginning with <code>float</code>, <code>real</code>, or <code>number</code>
 represent numbers of that type falling in a particular range.
 ( <a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#Predicates">The Emacs Common Lisp Documentation</a> )
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">    (<span style="color: #b58900;">typep</span> 4 '(integer 1 5)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true since 1 &#8804; 4 &#8804; 5.</span>
    (<span style="color: #b58900;">typep</span> 4 '(integer 1 3)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil  since 1 &#8804; 4 &#8816; 3.</span>

    (<span style="color: #b58900;">typep</span> 12 'integer) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
    (<span style="color: #b58900;">typep</span> 12 'number) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>

    (<span style="color: #b58900;">typep</span> 23 'odd)  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>

    (<span style="color: #b58900;">typep</span> 12 '(integer <span style="color: #b58900;">*</span> 14)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t, since 12 &#8804; 14, but no lower bound.</span>
    (<span style="color: #b58900;">typep</span> 12 '(integer 0 <span style="color: #b58900;">*</span>)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t; the &#8216;*&#8217; denotes a wild-card; anything.</span>

   (<span style="color: #b58900;">typep</span> -1 '(<span style="color: #b58900;">not</span> (integer 0 <span style="color: #b58900;">*</span>))) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
   (<span style="color: #b58900;">typep</span>  1 '(<span style="color: #b58900;">not</span> (integer 0 <span style="color: #b58900;">*</span>))) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil</span>

   (<span style="color: #b58900;">typep</span> 1 '(integer  1 2))   <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t, including lower bound</span>
   (<span style="color: #b58900;">typep</span> 1 '(integer (1) 2))  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil, excluding lower bound</span>

   (<span style="color: #b58900;">typep</span> 1.23 '(<span style="color: #b58900;">float</span> 1.20 1.24)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>

   <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Here's a slighly organised demonstration:</span>

   (<span style="color: #b58900;">typep</span> 1.23 'number) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
   (<span style="color: #b58900;">typep</span> 123  'number) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
   (<span style="color: #b58900;">typep</span> 1.23 'real) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
   (<span style="color: #b58900;">typep</span> 123  'real) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>

   (<span style="color: #b58900;">typep</span> 1.23 'integer) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil</span>
   (<span style="color: #b58900;">typep</span> 123  'integer) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
   (<span style="color: #b58900;">typep</span> 1.23 'fixnum) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil</span>
   (<span style="color: #b58900;">typep</span> 123  'fixnum) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>

   (<span style="color: #b58900;">typep</span> 1.23 '<span style="color: #b58900;">float</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
   (<span style="color: #b58900;">typep</span> 123 '<span style="color: #b58900;">float</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil</span>
   (<span style="color: #b58900;">typep</span> 123.0 '<span style="color: #b58900;">float</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
</pre>
</div></li>

<li><b>Floating-Point</b>: Numbers with fractional parts; expressible using scientific notation.
For example, <code>15.0e+2 ≈ 1500.0</code> and <code>-1.0e+INF</code> for negative infinity.</li>

<li><b>Aliases:</b>
The type symbol <code>real</code> is a synonym for <code>number</code>, <code>fixnum</code> is a
 synonym for <code>integer</code>, and <code>wholenum</code> is a synonym for <code>natnum</code>.</li>

<li><p>
The smallest and largest values <i>representable</i> in a Lisp integer are in the
constants <code>most-negative-fixnum</code> and <code>most-postive-fixnum</code>
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Relationship with infinities</span>
(<span style="color: #b58900;">&lt;</span> -1e+INF <span style="color: #268bd2;">most-negative-fixnum</span> <span style="color: #268bd2;">most-positive-fixnum</span> 1e+INF) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org36322b9" class="outline-3">
<h3 id="Character"><a href="#Character">Character</a></h3>
<div class="outline-text-3" id="text-Character">
<p>
<i>Representation of letters, numbers, and control characters.</i>
</p>

<p>
A character is just a small integers, up to 22 bits;
e.g., character <code>A</code> is represented as the integer 65.
</p>

<p>
One writes the character ‘A’ as <code>?A</code>, which is identical to 65.
Punctuations <code>()[]\;"|'`#</code> must be &#x00ad;escaped; e.g.,
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>?\( ≈ 40</code></td>
<td class="org-left"><code>?\\ ≈ 92</code></td>
</tr>
</tbody>
</table>
<p>
Whereas <code>?. ≈ 46</code>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">characterp</span> ?f) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
(<span style="color: #b58900;">characterp</span> <span style="color: #268bd2;">t</span>)  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil</span>
</pre>
</div>

<p>
Emacs specfic characters control-g <code>C-g</code>, backspace <code>C-h</code>, tab <code>C-i</code>, newline <code>C-j</code>, space,
return, del, and escape are expressed by ?\a, ?\b, ?\t, ?\n, ?\s, ?\r, ?\d, ?\e.
</p>

<p>
Generally, control characters can be expressed as <code>?\^𝓍 ≈ ?\C-𝓍</code>,
and meta characters by <code>?\M-𝓍</code>; e.g., <code>C-M-b</code> is expressed
<code>?\M-\C-b ≈ ?\C-\M-b</code>.
</p>

<p>
Finally, <code>?\S-𝓍</code> denotes shifted-𝓍 characters.
There are also <code>?\H-𝓍, ?\A-𝓍, ?\s-𝓍</code> to denote Hyper- Alt- or Super-modified keys;
note that lower case ‘s’ is for super whereas capital is for shift,
and lower case with no dash is a space character.
</p>
</div>
</div>

<div id="outline-container-org555757f" class="outline-3">
<h3 id="Symbol"><a href="#Symbol">Symbol</a></h3>
<div class="outline-text-3" id="text-Symbol">
<p>
<i>A multi-use object that refers to functions and variables, and more.</i>
</p>

<p>
A symbol is an object with a name; different objects have different names.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">typep</span> 'yes 'symbol) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">symbolp</span> 'yes)       <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>

(<span style="color: #b58900;">typep</span> 12   'symbol) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
(<span style="color: #b58900;">symbolp</span> 12)         <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
</pre>
</div>

<table>


<colgroup>
<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>symbol</code> ≈ Is it a symbol?</td>
</tr>

<tr>
<td class="org-left"><code>bound</code>  ≈ Does it refer to anything?</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">typep</span> 'xyz 'bound) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil</span>

(<span style="color: #859900; font-weight: bold;">setq</span> xyz 123)
(<span style="color: #b58900;">typep</span> 'xyz 'bound) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
</pre>
</div>
<p>
See this short <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Void-Variables.html#Void-Variables">docs</a> page for more info on when a variable is void.
</p>

<p>
<span class="underline">Names have a tremendously flexible syntax.</span>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">setq</span> +*/-_~!<span style="color: #b58900;">@$%^&amp;</span>:&lt;&gt;{}? 23)
(<span style="color: #859900; font-weight: bold;">setq</span> \+1            23) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Note +1 &#8776; 1, a number.</span>
(<span style="color: #859900; font-weight: bold;">setq</span> \12            23)
(<span style="color: #859900; font-weight: bold;">setq</span> this\ is\ woah 23) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Escaping each space!</span>
(<span style="color: #b58900;">+</span> this\ is\ woah 1)     <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 24</span>
</pre>
</div>

<p>
If the symbbol name starts with a colon ‘:’, it's called a keyword symbol
     and automatically acts as a constant.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">typep</span> <span style="color: #d33682; font-style: italic;">:hello</span> 'keyword) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
</pre>
</div>

<p>
Symbols generally act as names for variables and functions, however there are
some names that have <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Variables-with-Restricted-Values.html#Variables-with-Restricted-Values">fixed values</a> and any attempt to reset their values signals an error.
Most notably, these include <code>t</code> for true or the top-most type,
<code>nil</code> for false or the bottom-most type, and keywords.
These three evaluate to themselves.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #268bd2;">t</span>      <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
nil    <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil</span>
<span style="color: #d33682; font-style: italic;">:hello</span> <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; :hello</span>

(<span style="color: #859900; font-weight: bold;">setq</span> <span style="color: #268bd2;">t</span>   12) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; Error: Attempt to set a constant symbol</span>
(<span style="color: #859900; font-weight: bold;">setq</span> nil 12) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; Error: Attempt to set a constant symbol</span>
(<span style="color: #859900; font-weight: bold;">setq</span> <span style="color: #d33682; font-style: italic;">:x</span>  12) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; Error: Attempt to set a constant symbol</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">:x &#8800; 'x</span>
(<span style="color: #b58900;">set</span> 'x 12) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 12</span>
x           <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 12</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">They're self-evaluating</span>
(<span style="color: #b58900;">equal</span> <span style="color: #268bd2;">t</span>   '<span style="color: #268bd2;">t</span>)   <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
(<span style="color: #b58900;">equal</span> nil 'nil) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
(<span style="color: #b58900;">equal</span> <span style="color: #d33682; font-style: italic;">:x</span>  '<span style="color: #d33682; font-style: italic;">:x</span>)  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>

(<span style="color: #b58900;">equal</span> <span style="color: #d33682; font-style: italic;">:x</span> 'x)  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil</span>
</pre>
</div>

<p>
In particular, <code>:x ≠ 'x</code>!
</p>
</div>
</div>

<div id="outline-container-org0365cda" class="outline-3">
<h3 id="Sequence"><a href="#Sequence">Sequence</a></h3>
<div class="outline-text-3" id="text-Sequence">
<p>
<i>The interface for ordered collections</i>; e.g.,
the <code>(elt sequence index)</code> function can be applied to any sequence
to extract an element at the given index.
</p>

<div class="org-center">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>sequence</code></td>
<td class="org-left"><code>seq</code></td>
</tr>
</tbody>
</table>
</div>

<p>
The latter is an extensible variant of the former
&#x2014;for when we declare our own sequential data types.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">typep</span> '(1 2 3) 'sequence) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
</pre>
</div>

<p>
There are two immediate subtypes: <code>array</code> and <code>cons</code>, the latter has <code>list</code>
as a subtype.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">typep</span>  [1 2 3] 'array)       <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
(<span style="color: #b58900;">typep</span> '(1 2 3) '<span style="color: #b58900;">cons</span>)        <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
(<span style="color: #b58900;">typep</span> '(1 <span style="color: #2aa198;">"2"</span> 'three) '<span style="color: #b58900;">list</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
</pre>
</div>

<dl class="org-dl">
<dt>Array</dt><dd><p>
Arrays include strings and vectors.
</p>
<dl class="org-dl">
<dt>Vector</dt><dd>One-dimensional arrays.</dd>
<dt>Char-Table</dt><dd>One-dimensional sparse arrays indexed by characters.</dd>
<dt>Bool-Vector</dt><dd>One-dimensional arrays of <code>t</code> or <code>nil</code>.</dd>
<dt>Hash Table</dt><dd>Super-fast lookup tables.</dd>
</dl>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">typep</span> <span style="color: #2aa198;">"hi"</span> '<span style="color: #b58900;">string</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> 'hi  '<span style="color: #b58900;">string</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
</pre>
</div></dd>

<dt>Cons cell type</dt><dd><p>
Cons cells and lists, which are chains of cons cells.
</p>

<p>
These are objects consisting of two Lisp objects, called <code>car</code> and <code>cdr</code>.
That is they are pairs of Lisp objects.
</p>

<div class="org-src-container">
<pre class="src src-math">      '(x₀ x₁ x₂)
    ≈ '(x₀ . (x₁ . (x₂ . nil)))
    ≠ '(x₀ x₁ . x₂)
    ≈ '(x₀ . (x₁ . x₂))
</pre>
</div>

<p>
Notice that when there is no ‘.’, then a list
is just a nested cons chain ending in ‘nil’.
Note that <code>'(x₀ . x₁ . x₂)</code> is meaningless.
</p>

<p>
Cons cells are central to Lisp and so objects which are not a cons
cell are called <i>atoms</i>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">An atom is not a cons.</span>
(<span style="color: #b58900;">typep</span> 123 '<span style="color: #b58900;">atom</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
(<span style="color: #b58900;">typep</span> 'ni '<span style="color: #b58900;">atom</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
</pre>
</div>

<p>
Computationally:
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>(atom x)</code></td>
</tr>

<tr>
<td class="org-left">≈</td>
<td class="org-left"><code>(typep x 'atom)</code></td>
</tr>

<tr>
<td class="org-left">≈</td>
<td class="org-left"><code>(not (consp x))</code></td>
</tr>

<tr>
<td class="org-left">≈</td>
<td class="org-left"><code>(not (typep x 'cons))</code></td>
</tr>

<tr>
<td class="org-left">≈</td>
<td class="org-left"><code>(typep x '(not cons))</code></td>
</tr>
</tbody>
</table>

<p>
Interestingly, one writes <code>atom</code>, not <code>atomp</code>.
</p></dd>
</dl>
</div>
</div>

<div id="outline-container-org4fb3d81" class="outline-3">
<h3 id="Function"><a href="#Function">Function</a></h3>
<div class="outline-text-3" id="text-Function">
<p>
<i>Piece of executable code.</i>
</p>

<p>
A non-compiled function in Lisp is a lambda expression: A list whose
first element is the symbol <code>lambda</code>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">consp</span>     (<span style="color: #859900; font-weight: bold;">lambda</span> (x) x))        <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">functionp</span> (<span style="color: #859900; font-weight: bold;">lambda</span> (x) x))        <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>

(<span style="color: #b58900;">functionp</span> (<span style="color: #859900; font-weight: bold;">lambda</span> is <span style="color: #b58900;">the</span> <span style="color: #b58900;">first</span>)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> (<span style="color: #859900; font-weight: bold;">lambda</span> stuff) '<span style="color: #b58900;">function</span>)  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
</pre>
</div>

<p>
It may help to know that a <code>defun</code> just produces an alias for a function:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">  (<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">name</span> (args) <span style="color: #35a69c; font-style: italic;">"docs"</span> body)
&#8776; (<span style="color: #859900; font-weight: bold;">defalias</span> (<span style="color: #859900; font-weight: bold;">quote</span> name) (<span style="color: #859900; font-weight: bold;">function</span> (<span style="color: #859900; font-weight: bold;">lambda</span> (args) docs body)))
</pre>
</div>

<p>
Here's some more examples.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">typep</span> #'<span style="color: #b58900;">+</span>   '<span style="color: #b58900;">function</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> 'nice '<span style="color: #b58900;">function</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>

(<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">it</span> (x) (<span style="color: #b58900;">format</span> <span style="color: #2aa198;">"%s"</span> (+1 x)))
(<span style="color: #b58900;">typep</span> #'it   '<span style="color: #b58900;">function</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">functionp</span> #'it)         <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcb20049" class="outline-3">
<h3 id="Macro"><a href="#Macro">Macro</a></h3>
<div class="outline-text-3" id="text-Macro">
<p>
<i>A method of expanding an expression into another expression.</i>
</p>

<p>
Like functions, any list that begins with <code>macro</code>, and whose <code>cdr</code>
is a function, is considered a macro as long as Emacs Lisp is concerned.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">macrop</span> '(macro (<span style="color: #859900; font-weight: bold;">lambda</span> (x) x))) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
</pre>
</div>

<p>
Since <code>defmacro</code> produces an alias, as follows,
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">  (<span style="color: #859900; font-weight: bold;">defmacro</span> <span style="color: #b58900;">name</span> (args) <span style="color: #35a69c; font-style: italic;">"docs"</span> body)
&#8776; (<span style="color: #859900; font-weight: bold;">defalias</span> (<span style="color: #859900; font-weight: bold;">quote</span> name) (<span style="color: #b58900;">cons</span> (<span style="color: #859900; font-weight: bold;">quote</span> macro) (<span style="color: #859900; font-weight: bold;">function</span> (<span style="color: #859900; font-weight: bold;">lambda</span> (args) docs body))))
</pre>
</div>

<p>
You may be concerned that <code>(macrop x) ≟ (equal 'macro (car x))</code>, and so if a user
gives you a macro you might think its a cons cell of data.
Fortunately this is not the case:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">defmacro</span> <span style="color: #b58900;">no-op</span> () )

(<span style="color: #b58900;">macrop</span> #'no-op)    <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">consp</span>  #'no-op)    <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false; whence it's also not a list.</span>
(<span style="color: #b58900;">functionp</span> #'no-op) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>

(<span style="color: #b58900;">typep</span> #'no-op '
       (satisfies (<span style="color: #859900; font-weight: bold;">lambda</span> (x) (<span style="color: #859900; font-weight: bold;">and</span> (<span style="color: #b58900;">listp</span> x) (<span style="color: #b58900;">equal</span> 'macro (<span style="color: #b58900;">car</span> x)))))) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
</pre>
</div>

<p>
Why not? Well, you could think of a macro as a ‘record’ whose label is <code>macro</code> and
its only element is the associated function.
</p>
</div>
</div>

<div id="outline-container-org75d337b" class="outline-3">
<h3 id="Record"><a href="#Record">Record</a></h3>
<div class="outline-text-3" id="text-Record">
<p>
<i>Compound objects with programmer-defined types.</i>
</p>

<p>
They are the underlying representation of <code>defstruct</code> and <code>defclass</code> instances.
</p>

<p>
For example:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">defstruct</span> person
  name age)
</pre>
</div>

<p>
The <code>type-of</code> operator yields the <code>car</code> of instances of such declartions.
</p>
<table>


<colgroup>
<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>(record τ e₀ … eₙ) ≈ #s(τ e₀ … eₙ)</code></td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">setq</span> bobert (make-person <span style="color: #d33682; font-style: italic;">:name</span> <span style="color: #2aa198;">"bobby"</span> <span style="color: #d33682; font-style: italic;">:age</span> 'too-much))
(<span style="color: #b58900;">type-of</span> bobert) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; person</span>
</pre>
</div>

<p>
Componenets may be indexed with <code>aref</code>.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">aref</span> bobert 1)      <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; bobby</span>
(person-name bobert) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; bobby</span>
</pre>
</div>

<p>
A record is considered a constant for evaulation: Evaluating it yields itself.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">type-of</span> #s(person <span style="color: #2aa198;">"mark"</span> twelve)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; person</span>
(<span style="color: #b58900;">recordp</span> #s(nice))                 <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org5306c0e" class="outline-2">
<h2 id="typing-via-macros"><a href="#typing-via-macros">Typing via Macros &amp; Advice</a></h2>
<div class="outline-text-2" id="text-typing-via-macros">
<p>
Checking the type of inputs is tedious and so I <a href="https://www.reddit.com/r/emacs/comments/cct5hp/functional_type_declarations_in_elisp/">guessed</a> it could be done using
macros and advice. Looking at <a href="https://docs.racket-lang.org/ts-guide/types.html">Typed Racket</a> for inspiration, the following
fictitious syntax would add advice to <code>f</code> that checks the optional arguments <code>xᵢ</code>
have type <code>σᵢ</code> and the mandatory positional arguments have type <code>τᵢ</code> according
to position, and the result of the computation is of type <code>τ</code>.
To the best of my knowledge, no one had done this for Emacs Lisp &#x2014;I don't know why.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(declare-type 'f ((<span style="color: #d33682; font-style: italic;">:x&#8321;</span> &#963;&#8321;) &#8230; (<span style="color: #d33682; font-style: italic;">:x&#8344;</span> &#963;&#8344;)) (&#964;&#8321; &#8230; &#964;&#8345; &#964;))
</pre>
</div>

<p>
To modify a variable, or function, we may simply redefine it; but a much more elegant and powerful
approach is to <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Advising-Functions.html">“advise”</a> the current entity with some new behaviour. In our case of interest, we will
<i>advise functions to check their arguments before executing their bodies</i>.
</p>

<p>
Below is my attempt: <a id="org7d207a3"><code>declare-type</code></a>. Before you get scared or think it's horrendous, be charitable and
note that about a third of the following is documentation and a third is local declarations.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">cl-defmacro</span> <span style="color: #b58900;">declare-type</span> (f key-types <span style="color: #b58900; font-style: italic;">&amp;rest</span> types)
  <span style="color: #35a69c; font-style: italic;">"Attach the given list of types to the function &#8216;f&#8217;</span>
<span style="color: #35a69c; font-style: italic;">   by advising the function to check its arguments&#8217; types</span>
<span style="color: #35a69c; font-style: italic;">   are equal to the list of given types.</span>

<span style="color: #35a69c; font-style: italic;">   We name the advice &#8216;&#10218;f&#10219;-typing-advice&#8217; so that further</span>
<span style="color: #35a69c; font-style: italic;">   invocations to this macro overwrite the same advice function</span>
<span style="color: #35a69c; font-style: italic;">   rather than introducing additional, unintended, constraints.</span>

<span style="color: #35a69c; font-style: italic;">   Using type specifiers we accommodate for unions of types</span>
<span style="color: #35a69c; font-style: italic;">   and subtypes, etc &#9829;&#8255;&#9829;.</span>

<span style="color: #35a69c; font-style: italic;">   &#8216;</span><span style="color: #6c71c4; font-weight: bold; font-style: italic;">key-types</span><span style="color: #35a69c; font-style: italic;">&#8217; should be of the shape (:x&#8320; t&#8320; &#8943; :x&#8345; t&#8345;);</span>
<span style="color: #35a69c; font-style: italic;">    when there are no optional types, use symbol &#8220;:&#8221;.</span>

<span style="color: #35a69c; font-style: italic;">    E.g., (declare-type my-func (:z string :w integer) integer symbol string)</span>
<span style="color: #35a69c; font-style: italic;">  "</span>

  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Basic coherency checks. When there aren't optional types, key-types is the &#8220;:&#8221; symbol.</span>
  (should (<span style="color: #859900; font-weight: bold;">and</span> (<span style="color: #b58900;">listp</span> types) (<span style="color: #859900; font-weight: bold;">or</span> (<span style="color: #b58900;">listp</span> key-types) (<span style="color: #b58900;">symbolp</span> key-types))))

  (<span style="color: #859900; font-weight: bold;">letf*</span> ((pairify (<span style="color: #859900; font-weight: bold;">lambda</span> (xs) (<span style="color: #859900; font-weight: bold;">loop</span> for i in xs by #'<span style="color: #b58900;">cddr</span>         <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Turn a list of flattenned pairs</span>
                                      for j in (<span style="color: #b58900;">cdr</span> xs) by #'<span style="color: #b58900;">cddr</span>   <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">into a list of explicit pairs.</span>
                                      collect (<span style="color: #b58900;">cons</span> i j))))         <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #dc8cc3;">MA</span><span style="color: #96A7A9; font-style: italic;">: No Lisp method for this!?</span>
         (result-type  (<span style="color: #b58900;">car</span> (<span style="color: #b58900;">-take-last</span> 1 types)))
         (types        (<span style="color: #b58900;">-drop-last</span> 1 types))
         (num-of-types (<span style="color: #b58900;">length</span> types))
         (key-types-og (<span style="color: #859900; font-weight: bold;">unless</span> (<span style="color: #b58900;">symbolp</span> key-types) key-types))
         (key-types    (<span style="color: #b58900;">funcall</span> pairify key-types-og))
         (advice-name  (<span style="color: #b58900;">intern</span> (<span style="color: #b58900;">format</span> <span style="color: #2aa198;">"%s-typing-advice"</span> f)))
         (notify-user  (<span style="color: #b58900;">format</span> <span style="color: #2aa198;">"%s now typed %s &#8594; %s &#8594; %s."</span>
                               `,f key-types-og types result-type)))

      `(<span style="color: #859900; font-weight: bold;">progn</span>
         (<span style="color: #859900; font-weight: bold;">defun</span> ,advice-name (orig-fun <span style="color: #b58900; font-style: italic;">&amp;rest</span> args)

           <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Split into positional and key args; optionals not yet considered.</span>
           (<span style="color: #859900; font-weight: bold;">letf*</span> ((all-args
                     (<span style="color: #b58900;">-split-at</span>
                       (<span style="color: #859900; font-weight: bold;">or</span> (<span style="color: #859900; font-weight: bold;">--find-index</span> (<span style="color: #b58900;">not</span> (<span style="color: #b58900;">s-blank?</span> (<span style="color: #b58900;">s-shared-start</span> <span style="color: #2aa198;">":"</span> (<span style="color: #b58900;">format</span> <span style="color: #2aa198;">"%s"</span> it)))) args) ,num-of-types)
                        args)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">The &#8220;or&#8221; is for when there are no keywords provided.</span>
                  (pos-args  (<span style="color: #b58900;">car</span> all-args))
                  (key-args  (<span style="color: #b58900;">funcall</span> ,pairify (<span style="color: #b58900;">cadr</span> all-args)))
                  (fun-result nil)
                  ((<span style="color: #b58900;">symbol-function</span> 'shucks)
                     (<span style="color: #859900; font-weight: bold;">lambda</span> (e&#964; e g)
                       (<span style="color: #859900; font-weight: bold;">unless</span> (<span style="color: #b58900;">typep</span> g e&#964;)
                         (<span style="color: #b58900;">error</span> <span style="color: #2aa198;">"%s: Type mismatch! Expected %s %s &#8800; Given %s %s."</span>
                                (<span style="color: #859900; font-weight: bold;">function</span> ,f) e&#964; e (<span style="color: #b58900;">type-of</span> g) (<span style="color: #b58900;">prin1-to-string</span> g))))))

         <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Check the types of positional arguments.</span>
         (<span style="color: #859900; font-weight: bold;">unless</span> (<span style="color: #b58900;">equal</span> ,num-of-types (<span style="color: #b58900;">length</span> pos-args))
           (<span style="color: #b58900;">error</span> <span style="color: #2aa198;">"%s: Insufficient number of arguments; given %s, %s, but %s are needed."</span>
                  (<span style="color: #859900; font-weight: bold;">function</span> ,f) (<span style="color: #b58900;">length</span> pos-args) pos-args ,num-of-types))
         (<span style="color: #859900; font-weight: bold;">loop</span> for (ar ty pos) in (<span style="color: #b58900;">-zip</span> pos-args (<span style="color: #859900; font-weight: bold;">quote</span> ,types) (<span style="color: #b58900;">number-sequence</span> 0 ,num-of-types))
               <span style="color: #b58900;">do</span> (shucks ty (<span style="color: #b58900;">format</span> <span style="color: #2aa198;">"for argument %s"</span> pos) ar))

         <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Check the types of *present* keys.</span>
         (<span style="color: #859900; font-weight: bold;">loop</span> for (k . v) in key-args
               <span style="color: #b58900;">do</span> (shucks (<span style="color: #b58900;">cdr</span> (<span style="color: #b58900;">assoc</span> k (<span style="color: #859900; font-weight: bold;">quote</span> ,key-types))) k v))

         <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Actually execute the orginal function on the provided arguments.</span>
         (<span style="color: #859900; font-weight: bold;">setq</span> fun-result (<span style="color: #b58900;">apply</span> orig-fun args))
         (shucks (<span style="color: #859900; font-weight: bold;">quote</span> ,result-type) <span style="color: #2aa198;">"for the result type (!)"</span> fun-result)

         <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Return-value should be given to caller.</span>
         fun-result))

      <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Register the typing advice and notify user of what was added.</span>
      (<span style="color: #b58900;">advice-add</span> (<span style="color: #859900; font-weight: bold;">function</span> ,f) <span style="color: #d33682; font-style: italic;">:around</span> (<span style="color: #859900; font-weight: bold;">function</span> ,advice-name))
      ,notify-user )))
</pre>
</div>

<pre class="example">
declare-type
</pre>


<p>
There are some notable shortcomings: Lack of support for type variables and, for now, no support for
optional arguments. Nonetheless, I like it &#x2014;of course.
( Using <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Watching-Variables.html#Watching-Variables">variable watchers</a> we could likely add support for type variables as well as
function-types. )
</p>

<p>
<b>We accidentally forgot to consider an argument.</b>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(declare-type f&#8321; (<span style="color: #d33682; font-style: italic;">:z</span> <span style="color: #b58900;">string</span> <span style="color: #d33682; font-style: italic;">:w</span> <span style="color: #b58900;">list</span>) integer symbol <span style="color: #b58900;">string</span>)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; f&#8321; now typed (:z string :w integer) &#8594; (integer symbol) &#8594; string.</span>

(<span style="color: #859900; font-weight: bold;">cl-defun</span> <span style="color: #b58900;">f&#8321;</span> (x y <span style="color: #b58900; font-style: italic;">&amp;key</span> z w) (<span style="color: #b58900;">format</span> <span style="color: #2aa198;">"%s"</span> x))
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; f&#8321; now defined</span>

(f&#8321; 'x) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; f&#8321;: Insufficient number of arguments; given 2, (x), but 3 are needed.</span>
</pre>
</div>
<p>
The type declaration said we needed 3 arguments, but we did not consider one of them.
</p>

<p>
<b>We accidentally returned the wrong value.</b>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(declare-type f&#8322; (<span style="color: #d33682; font-style: italic;">:z</span> <span style="color: #b58900;">string</span> <span style="color: #d33682; font-style: italic;">:w</span> <span style="color: #b58900;">list</span>) integer symbol <span style="color: #b58900;">string</span>)
(<span style="color: #859900; font-weight: bold;">cl-defun</span> <span style="color: #b58900;">f&#8322;</span> (x y <span style="color: #b58900; font-style: italic;">&amp;key</span> z w) x)

(f&#8322; 144 'two)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; f&#8322;: Type mismatch! Expected string for the result type (!) &#8800; Given integer 144.</span>
</pre>
</div>

<p>
<b>We accidentally forgot to supply an argument.</b>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(declare-type f&#8323; (<span style="color: #d33682; font-style: italic;">:z</span> <span style="color: #b58900;">string</span> <span style="color: #d33682; font-style: italic;">:w</span> <span style="color: #b58900;">list</span>) integer symbol <span style="color: #b58900;">string</span>)
(<span style="color: #859900; font-weight: bold;">cl-defun</span> <span style="color: #b58900;">f&#8323;</span> (x y <span style="color: #b58900; font-style: italic;">&amp;key</span> z w) (<span style="color: #b58900;">format</span> <span style="color: #2aa198;">"%s"</span> x))

(f&#8323; 144)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; f&#8323;: Insufficient number of arguments; given 1, (144), but 2 are needed.</span>
</pre>
</div>

<p>
<b>A positional argument is supplied of the wrong type.</b>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(f&#8323; 'one <span style="color: #2aa198;">"two"</span>)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658;  f&#8323;: Type mismatch! Expected integer for argument 0 &#8800; Given symbol one.</span>

(f&#8323; 144 <span style="color: #2aa198;">"two"</span>)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; f&#8323;: Type mismatch! Expected symbol for argument 1 &#8800; Given string "two".</span>
</pre>
</div>
<p>
Notice: When multiple positional arguments have type-errors, the errors are reported one at a time.
</p>

<p>
<b>A keyword argument is supplied of the wrong type.</b>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(f&#8323; 1 'two <span style="color: #d33682; font-style: italic;">:z</span> 'no&#8320; <span style="color: #d33682; font-style: italic;">:w</span> 'no&#8321;)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; f&#8323;: Type mismatch! Expected string :z &#8800; Given symbol no&#8320;.</span>

(f&#8323; 1 'two <span style="color: #d33682; font-style: italic;">:z</span> <span style="color: #2aa198;">"ok"</span> <span style="color: #d33682; font-style: italic;">:w</span> 'no&#8321;)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; f&#8323;: Type mismatch! Expected string :w &#8800; Given symbol no&#8321;.</span>

(f&#8323; 1 'two <span style="color: #d33682; font-style: italic;">:z</span> <span style="color: #2aa198;">"ok"</span> <span style="color: #d33682; font-style: italic;">:w</span> 23)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; f&#8323;: Type mismatch! Expected string :w &#8800; Given integer 23.</span>

(f&#8323; 1 'two <span style="color: #d33682; font-style: italic;">:z</span> <span style="color: #2aa198;">"ok"</span> <span style="color: #d33682; font-style: italic;">:w</span> '(a b 1 2)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; okay; no type-error.</span>
</pre>
</div>

<p>
<b>We have no optional arguments.</b>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(declare-type f&#8324; : integer symbol <span style="color: #b58900;">string</span>)
(<span style="color: #859900; font-weight: bold;">cl-defun</span> <span style="color: #b58900;">f&#8324;</span> (x y <span style="color: #b58900; font-style: italic;">&amp;key</span> z w) (<span style="color: #b58900;">format</span> <span style="color: #2aa198;">"%s"</span> x))

(f&#8324; 144 'two <span style="color: #d33682; font-style: italic;">:z</span> <span style="color: #2aa198;">"bye"</span>)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658;  f&#8324;: Type mismatch! Expected nil :z &#8800; Given string "bye".</span>
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">( We shouldn't have any keyword :z according to the type declaration! )</span>

(f&#8324; 144 'two) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; "144"</span>
</pre>
</div>

<p>
<b>We can incorporate type specfiers such as unions!</b>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(declare-type f&#8325; : (<span style="color: #859900; font-weight: bold;">or</span> integer <span style="color: #b58900;">string</span>) <span style="color: #b58900;">string</span>)
(<span style="color: #859900; font-weight: bold;">cl-defun</span> <span style="color: #b58900;">f&#8325;</span> (x) (<span style="color: #b58900;">format</span> <span style="color: #2aa198;">"%s"</span> x))

(f&#8325; 144)     <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; "144"</span>
(f&#8325; <span style="color: #2aa198;">"neato"</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; "neato"</span>

(f&#8325; 'shaka-when-the-walls-fell)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; f&#8325;: Type mismatch! Expected (or integer string) for argument 0</span>
<span style="color: #96A7A9; font-style: italic;">;;       </span><span style="color: #96A7A9; font-style: italic;">&#8800; Given symbol shaka-when-the-walls-fell.</span>
</pre>
</div>

<p>
<b>No positional arguments but a complex optional argument!</b>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(declare-type f&#8326; (<span style="color: #d33682; font-style: italic;">:z</span> (satisfies (<span style="color: #859900; font-weight: bold;">lambda</span> (it) (<span style="color: #859900; font-weight: bold;">and</span> (<span style="color: #b58900;">integerp</span> it) (<span style="color: #b58900;">=</span> 0 (<span style="color: #b58900;">mod</span> it 5))))))
                 character)
(<span style="color: #859900; font-weight: bold;">cl-defun</span> <span style="color: #b58900;">f&#8326;</span> (<span style="color: #b58900; font-style: italic;">&amp;key</span> z) ?A)

(f&#8326; 'hi)     <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658;  Keyword argument 144 not one of (:z)</span>
(f&#8326;)         <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 65; i.e., the character &#8216;A&#8217;</span>
(f&#8326; <span style="color: #d33682; font-style: italic;">:z</span> 6)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658;  f&#8326;: Type mismatch!</span>
<span style="color: #96A7A9; font-style: italic;">;;    </span><span style="color: #96A7A9; font-style: italic;">Expected (satisfies (lambda (it) (and (integerp it) (= 0 (mod it 5))))) :z</span>
<span style="color: #96A7A9; font-style: italic;">;;    </span><span style="color: #96A7A9; font-style: italic;">&#8800; Given integer 6.</span>

(f&#8326; <span style="color: #d33682; font-style: italic;">:z</span> 10) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 65; i.e., the expected output since 10 mod 5 &#8776; 0 &amp; so 10 is valid input.</span>
</pre>
</div>

<p>
<b>Preconditions!</b> The previous example had a complex type on a keyword, but that was
essentially a pre-condition; we can do the same on positional arguments.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(declare-type f&#8327; : (satisfies (<span style="color: #859900; font-weight: bold;">lambda</span> (it) (<span style="color: #b58900;">=</span> it 5)))
                   integer)
(<span style="color: #859900; font-weight: bold;">cl-defun</span> <span style="color: #b58900;">f&#8327;</span> (n) n)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">The identity on 5 function; and undefined otherwise.</span>

(f&#8327; 4)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; f&#8327;: Type mismatch! Expected (satisfies (lambda (it) (= it 5))) for argument 0</span>
<span style="color: #96A7A9; font-style: italic;">;;       </span><span style="color: #96A7A9; font-style: italic;">&#8800; Given integer 4.</span>

(f&#8327; 5) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 5</span>
</pre>
</div>

<p>
<b>Postconditions!</b>
Given an integer greater than 5, we present an integer greater than 2; i.e.,
this is a constructive proof that \(∀ n • n > 5 ⇒ n > 2\).
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(declare-type f&#8328; : (satisfies (<span style="color: #859900; font-weight: bold;">lambda</span> (in)  (<span style="color: #b58900;">&gt;</span> in 5)))
                   (satisfies (<span style="color: #859900; font-weight: bold;">lambda</span> (out) (<span style="color: #b58900;">&gt;</span> out 2))))
(<span style="color: #859900; font-weight: bold;">cl-defun</span> <span style="color: #b58900;">f&#8328;</span> (n) n)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">The identity on 5 function; and undefined otherwise.</span>

(f&#8328; 4)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658;  f&#8328;: Type mismatch! Expected (satisfies (lambda (in) (&gt; in 5))) for argument 0</span>
<span style="color: #96A7A9; font-style: italic;">;;        </span><span style="color: #96A7A9; font-style: italic;">&#8800; Given integer 4.</span>

(f&#8328; 72) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 72; since indeed 72 &gt; 5 for the input, and clearly 72 &gt; 2 for the output.</span>
</pre>
</div>

<p>
As it currently stands we cannot make any explicit references between the inputs
and the output, but that's an easy fix: Simply add a local function <code>old</code> to the
<a href="#org7d207a3"><code>declare-type</code></a> macro which is intentionally exposed so that it can be used in the
type declarations to refer to the ‘old’, or initial, values provided to the function.
Additionally, one could also add keyword arguments <code>:requires</code> and <code>:ensures</code>
for a more sophisticated pre- and post-condition framework.
<a href="https://github.com/sellout/quid-pro-quo">Something</a> along these lines is implemented for Common Lisp.
</p>

<p>
Here's a fun exercise: Recast the <a href="https://liquid.kosmikus.org/01-intro.html#/what-is-liquid-haskell">Liquid Haskell</a> examples in Lisp using this
<a href="#org7d207a3"><code>declare-type</code></a> form.
</p>
</div>
</div>

<div id="outline-container-orgbf457a7" class="outline-2">
<h2 id="Closing"><a href="#Closing">Closing</a></h2>
<div class="outline-text-2" id="text-Closing">
<blockquote>
<p>
<i>I have heard more than one LISP advocate state such subjective comments as, "LISP is the most powerful and elegant programming language in the world" and expect such comments to be taken as objective truth. I have never heard a Java, C++, C, Perl, or Python advocate make the same claim about their own language of choice.</i>
</p>

<p>
---<a href="http://www.paulgraham.com/quotes.html">A guy on slashdot</a>
</p>
</blockquote>

<p>
I learned a lot of stuff, hope you did too ^_^
</p>
</div>
</div>

<div id="outline-container-orgc1700bc" class="outline-2">
<h2 id="references"><a href="#references">References</a></h2>
<div class="outline-text-2" id="text-references">
<p>
Neato web articles:
</p>
<ul class="org-ul">
<li><a href="http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html">What to know before debating type systems</a>
<ul class="org-ul">
<li>Debunks a number of fallacies such as
“dynamic typing provides no way to find bugs” and
“static types need type declarations”.</li>
</ul></li>
<li><a href="http://steve-yegge.blogspot.com/2008/05/dynamic-languages-strike-back.html">Dynamic Languages Strike Back</a>
<ul class="org-ul">
<li>Everything you might wanna know about dynamically checked languages.</li>
</ul></li>
<li><a href="http://www.ai.sri.com/~delacaze/alu-site/alu/table/contents.htm">The Association of Lisp Users</a>
<ul class="org-ul">
<li>Abundant resource relating to Lisp.</li>
</ul></li>
<li><a href="https://www.williamjbowman.com/blog/2018/01/19/untyped-programs-don-t-exist/#related">Untyped Programs Don’t Exist</a>
<ul class="org-ul">
<li>It's not a matter of typing but of pragmatics.</li>
</ul></li>
<li><a href="http://homes.sice.indiana.edu/jsiek/what-is-gradual-typing/">What is Gradual Typing</a>:
<ul class="org-ul">
<li>Discusses how static and dynamic typing can be used together hamroniously.</li>
</ul></li>
<li><a href="https://www.cliki.net/">CLiki &#x2014; The Common Lisp Wiki</a>
<ul class="org-ul">
<li>Contains resources for learning about
and using the   programming language Common Lisp.</li>
<li>The humour section is delightful.</li>
</ul></li>
<li><a href="http://www.cs.utexas.edu/users/boyer/ftp/diss/akers.pdf">Strong Static Type Checking for Functional Common Lisp</a>
<ul class="org-ul">
<li>PhD thesis regarding strong static type checking in an applicative subset of CL.</li>
</ul></li>
<li><a href="http://www.paulgraham.com/avg.html">Beating the Averages</a>
<ul class="org-ul">
<li>Paul Graham discusses “the most powerful language available” &#x2014;Lisp.</li>
<li>Other articles he's written about Lisp can be found <a href="http://www.paulgraham.com/lisp.html">here</a>.</li>
</ul></li>
<li><a href="http://www.marktarver.com/bipolar.html">The Bipolar Lisp Programmer</a>
<ul class="org-ul">
<li>“Lisp is, like life, what you make of it.”
Lisps attract a certain kind of personality.</li>
</ul></li>

<li>A <a id="org37d3bcd">bunch of papers</a> on <a href="#org47d3d0a">polymorphic</a> (modal) type systems
for Lisp-like multi-staged languages:
<a href="http://ropas.snu.ac.kr/lib/dock/KiYiCa2005.pdf">This</a> is generic, <a href="https://www.iro.umontreal.ca/~monnier/typer-jfla2019.pdf">this</a> is ML + Scheme, <a href="https://link.springer.com/chapter/10.1007/978-1-4615-2836-4_8">this</a> for compile-time typing,
and <a href="https://hal.archives-ouvertes.fr/hal-01380792/document">this</a> one “allows the programmer to declaratively express the types of
 heterogeneous sequences in a way which is natural in the Common Lisp language.”</li>

<li><a href="http://lambda-the-ultimate.org/node/5426">Type Systems as Macros</a>
<ul class="org-ul">
<li><p>
After defining <a href="#org7d207a3"><code>declare-type</code></a> I thought the slogan “types by macros” sounded nifty;
Googling it led me to this paper where the Racket is endowed with types.
</p>

<p>
Lisp is great lol.
</p></li>
</ul></li>

<li><a href="https://twobithistory.org/2018/10/14/lisp.html">How Lisp Became God's Own Programming Language</a>
<ul class="org-ul">
<li>History and venerance of Lisp.</li>
</ul></li>

<li><a href="http://www.lispworks.com/documentation/lw51/CLHS/Body/04_bc.htm">Common Lisp HyperSpec</a> &#x2013; Type Specifiers</li>
</ul>
</div>
</div>
<div class="taglist"><a href="https://alhassy.github.io/tags.html">Tags</a>: <a href="https://alhassy.github.io/tag-types.html">types</a> <a href="https://alhassy.github.io/tag-lisp.html">lisp</a> <a href="https://alhassy.github.io/tag-program-proving.html">program-proving</a> <a href="https://alhassy.github.io/tag-emacs.html">emacs</a> </div><div id="archive">
<a href="https://alhassy.github.io/archive.html">Other posts</a>
</div>
</div>
<div id="postamble" class="status"><div id="archive">
  <a href="https://alhassy.github.io/archive.html">Other posts</a>
</div>
<center><a rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a><br /><span xmlns:dct="https://purl.org/dc/terms/" href="https://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">Life and Computing Science</span> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://alhassy.github.io/" property="cc:attributionName" rel="cc:attributionURL">Musa Al-hassy</a> is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.</center>

<div id="archive"><a href="archive.html">Other posts</a></div>
              <div id="disqus_thread"></div>
              <script type="text/javascript">
              /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
              var disqus_shortname = 'life-and-computing-science';
              /* * * DON'T EDIT BELOW THIS LINE * * */
              (function() {
                var dsq = document.createElement('script');
                dsq.type = 'text/javascript';
                dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                  })();
              </script>
              <noscript>Please enable JavaScript to view the
                  <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
              <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></div>
</body>
</html>
