<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.56 in css mode. -->
<html>
  <head>
    <title>PathCat.org</title>
    <style type="text/css">
    <!--
      body {
        color: #757c85968807;
        background-color: #FDF6E3;
      }
      .bold {
        /* bold */
        font-weight: bold;
      }
      .comment {
        /* font-lock-comment-face */
        color: #aae2b70db515;
        font-style: italic;
      }
      .comment-delimiter {
        /* font-lock-comment-delimiter-face */
        color: #96A7A9;
        font-style: italic;
      }
      .custom {
      }
      .custom-1 {
        /* (:strike-through t) */
        text-decoration: line-through;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #c75b9e3a3ea0;
      }
      .haskell-constructor {
        /* haskell-constructor-face */
        color: #b58900;
        font-style: italic;
      }
      .haskell-definition {
        /* haskell-definition-face */
        color: #b58900;
      }
      .haskell-keyword {
        /* haskell-keyword-face */
        color: #859900;
        font-weight: bold;
      }
      .haskell-operator {
        /* haskell-operator-face */
        color: #268bd2;
      }
      .haskell-type {
        /* haskell-type-face */
        color: #b58900;
        font-style: italic;
      }
      .italic {
        /* italic */
        font-style: italic;
      }
      .org-block {
        /* org-block */
        background-color: #faf1d9;
      }
      .org-block-begin-line {
        /* org-block-begin-line */
        background-color: #f7edd0;
      }
      .org-block-end-line {
        /* org-block-end-line */
        background-color: #f7edd0;
      }
      .org-code {
        /* org-code */
        color: #dbd66f703fa7;
      }
      .org-document-info {
        /* org-document-info */
        color: #dfcf6542953f;
      }
      .org-document-info-keyword {
        /* org-document-info-keyword */
        color: #D6D6D6;
      }
      .org-document-title {
        /* org-document-title */
        color: #dfcf6542953f;
        font-weight: bold;
      }
      .org-drawer {
        /* org-drawer */
        color: #71c1591ffc4f;
      }
      .org-formula {
        /* org-formula */
        color: #630db2c3a731;
      }
      .org-hide {
        /* org-hide */
        color: #fdfdf6f5e3e3;
      }
      .org-latex-and-related {
        /* org-latex-and-related */
        color: #7f9186688300;
        font-weight: bold;
      }
      .org-level-1 {
        /* org-level-1 */
        color: #268bd2;
        font-weight: bold;
      }
      .org-level-2 {
        /* org-level-2 */
        color: #d33682;
        font-weight: bold;
      }
      .org-level-3 {
        /* org-level-3 */
        color: #6c71c4;
        font-weight: bold;
      }
      .org-link {
        /* org-link */
        color: #268bd2;
        font-weight: bold;
        text-decoration: underline;
      }
      .org-list-dt {
        /* org-list-dt */
        color: #689d9fc3d6df;
      }
      .org-macro {
        /* org-macro */
        color: #626C6C;
        font-weight: bold;
      }
      .org-meta-line {
        /* org-meta-line */
        color: #68c6b6d1aa74;
      }
      .org-property-value {
        /* org-property-value */
        color: #68c6b6d1aa74;
      }
      .org-quote {
        /* org-quote */
        background-color: #F2E6CE;
        font-style: italic;
      }
      .org-special-keyword {
        /* org-special-keyword */
        color: #68c6b6d1aa74;
      }
      .org-table {
        /* org-table */
        color: #8cc08a6acbae;
      }
      .org-tag {
        /* org-tag */
        color: #68c6b6d1aa74;
      }
      .string {
        /* font-lock-string-face */
        color: #630db2c3a731;
      }
      .underline {
        /* underline */
        text-decoration: underline;
      }
      .writegood-duplicates {
        /* writegood-duplicates-face */
        text-decoration: underline;
      }
      .writegood-passive-voice {
        /* writegood-passive-voice-face */
        text-decoration: underline;
      }
      .writegood-weasels {
        /* writegood-weasels-face */
        text-decoration: underline;
      }

      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
<span class="org-document-info-keyword">#+title:</span> <span class="org-document-title">Graphs are to categories as lists are to monoids
</span><span class="org-document-info-keyword">#+date:</span> <span class="org-document-info">&lt;2018-12-24 19:29&gt;
</span><span class="org-document-info-keyword">#+author:</span> <span class="org-document-info">Musa Al-hassy
</span><span class="org-document-info-keyword">#+email:</span> <span class="org-document-info">alhassy@gmail.com
</span><span class="org-meta-line">#+description: A fast-paced introduction to Category Theory based on the notion of graphs.</span>
<span class="org-meta-line">#+description: Claims </span><span class="org-meta-line"><span class="writegood-passive-voice">are proven</span></span><span class="org-meta-line"> in the Haskell-like proof assistant Agda.</span>
<span class="comment"># Numbers are the lengths of lists which are the flattenings of trees which are</span>
<span class="comment"># the spannings of graphs.</span>

<span class="org-meta-line">#+filetags: category-theory agda types</span>
<span class="org-meta-line">#+fileimage: PathCat.png </span><span class="org-meta-line"><span class="writegood-duplicates">300 300</span></span>

<span class="org-meta-line">#+include: ../MathJaxPreamble.org</span>

<span class="comment"># We shall use &#8216;haskell&#8217; blocks to obtain </span><span class="comment"><span class="writegood-weasels">some</span></span><span class="comment"> syntax colouring.</span>
<span class="comment"># In Agda, syntax colouring is tantamount to parsing!</span>
<span class="org-block-begin-line">#+begin_export html
</span><span class="org-block">&lt;</span><span class="org-block"><span class="function-name">style</span></span><span class="org-block">&gt; pre.src-haskell:before { content: 'Agda' !important; }&lt;/</span><span class="org-block"><span class="function-name">style</span></span><span class="org-block">&gt;
</span><span class="org-block-end-line">#+end_export
</span>
<span class="org-meta-line">#+macro: newline @@html: &lt;br&gt;@@</span>

<span class="org-level-1">* Abstract                                                           </span><span class="org-level-1"><span class="org-tag">:ignore:</span></span>
<span class="org-drawer">  :PROPERTIES:...
</span>
<span class="org-meta-line">#+TOC: headlines 2</span>

Numbers are the lengths of lists which are the flattenings of trees which are
the spannings of graphs.
Unlike the first three, graphs have <span class="italic">two</span> underlying types of interest
--the vertices and the edges-- and it is getting to grips with this complexity
that we attempt to tackle by considering their &#8216;algebraic&#8217; counterpart: Categories.

<span class="comment"># trees are just those graphs for which arbitrary points </span><span class="comment"><span class="writegood-passive-voice">are connected</span></span><span class="comment"> by a unique undirected path.</span>

In our exploration of what graphs could possibly be and their relationships to lists are,
we shall <span class="italic">mechanise,</span> or <span class="italic">implement,</span> our claims since there will be <span class="writegood-weasels">many</span> details and it is <span class="writegood-weasels">easy</span>
to make mistakes --moreover as a self-learning project, I'd feel more confident to make
<span class="bold">bold</span> claims when I have a proof assistant checking my work <img src="../../.emacs.d/emojis/emojione-v2.2.6-22/1f609.png" alt=";-)" />

Assuming slight familiarity with the Agda programming language, we motivate the need for
basic concepts of category theory with the aim of discussing adjunctions with
a running example of a detailed construction and proof of a free functor.
Moreover, the article contains a host of <span class="org-code">exercises</span> whose solutions can <span class="writegood-passive-voice">be found</span> in the
literate source file. Raw Agda code can <span class="writegood-passive-voice">be found</span> <span class="org-link"><a href="https://github.com/alhassy/AgdaCheatSheet/blob/master/PathCat.agda">here</a></span>.

Since the read time for this article is more than two hours, excluding the interspersed
exercises, it may help to occasionally consult a <span class="writegood-weasels">some</span> reference sheets:
<span class="org-block-begin-line">#+begin_center
</span><span class="org-link"><a href="badge:Category_Theory|CheatSheet|success|https://alhassy.github.io/CatsCheatSheet/CheatSheet.pdf|gimp">badge:Category_Theory|CheatSheet|success|https://alhassy.github.io/CatsCheatSheet/CheatSheet.pdf|gimp</a></span>
<span class="org-link"><a href="badge:Agda|CheatSheet|success|https://alhassy.github.io/AgdaCheatSheet/CheatSheet.pdf|haskell">badge:Agda|CheatSheet|success|https://alhassy.github.io/AgdaCheatSheet/CheatSheet.pdf|haskell</a></span>
<span class="org-block-end-line">#+end_center
</span>
Coming from a background in order theory, I love Galois Connections and so
our categorical hammer will not be terminal objects nor limits, but rather adjunctions.
As such, <span class="italic">everything is an adjunction</span> is an apt slogan for us <img src="../../.emacs.d/emojis/emojione-v2.2.6-22/1f642.png" alt=":-)" />

<span class="comment"># ?universal algebra: signatures, graphs, monoids, cats</span>

<span class="comment"># ?However, similar to nearly everything else in this document, we can leave the setoid-approach as an exercises</span>
<span class="comment"># for the reader, which of course has solutions being in the literate source.</span>

<span class="comment"># ?instance resolution, difference from typeclass, look at tp.</span>

<span class="org-meta-line">#
# The approach taken here is to motivate categories from posets and the main</span>
<span class="comment"># tools used there are indirect reasoning (yoneda) and galois connections (adjunctions).</span>

<span class="comment"># \tableofcontents</span>

<span class="org-block-begin-line">#+BEGIN_SRC haskell :tangle "PathCat.agda"
</span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">This file has </span></span><span class="org-block"><span class="comment"><span class="writegood-passive-voice">been extracted</span></span></span><span class="org-block"><span class="comment"> from <a href="https://alhassy.github.io/PathCat/">https://alhassy.github.io/PathCat/</a>
</span></span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Type checks with Agda version 2.6.0.
</span></span><span class="org-block-end-line">#+END_SRC
</span><span class="org-level-1">* Photograph Credit                                                  </span><span class="org-level-1"><span class="org-tag">:ignore:</span></span>
<span class="org-drawer">  :PROPERTIES:...
</span>
<span class="org-meta-line">#+LaTeX: \iffalse</span>
<span class="org-meta-line">#+HTML: &lt;small&gt; &lt;center&gt;</span>
( Photo by
<span class="org-link"><a href="https://unsplash.com/@miklevasilyev">Mikhail Vasilyev</a></span>
on <span class="org-link"><a href="https://unsplash.com/">Unsplash</a></span> )
<span class="org-meta-line">#+HTML: &lt;/center&gt; &lt;/small&gt;</span>
<span class="org-meta-line">#+LaTeX: \fi</span>

<span class="comment"># "Download free do whatever you want high-resolution photos from Unsplash."</span>

<span class="org-level-1">* Introduction</span>
<span class="org-drawer">:PROPERTIES:...
</span>
<span class="org-hide">*</span><span class="org-level-2">* Motivation                                                       </span><span class="org-level-2"><span class="org-tag">:ignore:</span></span>
<span class="org-drawer">   :PROPERTIES:...
</span>
Lists give free monoids<span class="org-latex-and-related"> $&#8466;\, A = (\List\, A, </span><span class="custom-1"><span class="org-latex-and-related">\!</span></span><span class="org-latex-and-related">, [])$
</span>---a monoid<span class="org-latex-and-related"> $&#119982; = (S, &#8853;, 0_&#8853;)$ </span>is a triple consisting of a set<span class="org-latex-and-related"> $S$ </span>with a binary operation<span class="org-latex-and-related">
$&#8853;$ </span>on it that is associative and has a unit,<span class="org-latex-and-related"> $0_&#8853;$.</span>
That it is &#8216;free&#8217; means that to define a structure-preserving map between monoids<span class="org-latex-and-related">
$(\List\, A, </span><span class="custom-1"><span class="org-latex-and-related">\!</span></span><span class="org-latex-and-related">, []) \,&#10230;\, (S, &#8853;, 0_&#8853;)$ </span>it suffices to only provide a map between their
carriers<span class="org-latex-and-related"> $\List\, A &#8594; S$ </span>---freedom means that plain old maps between types freely,
at no cost or effort, give rise to maps that preserve monoid structure.
Moreover, the converse also holds and in-fact we have a bijection:
<span class="org-latex-and-related">\[
  (&#8466;\, A &#10230; &#119982;) \qquad&#8773;\qquad (A &#10230; &#119984;\, &#119982;)
\]</span>
Where we write<span class="org-latex-and-related"> $&#119984;\, (S, &#8853;, 0_&#8853;) = S$ </span>for the operation that gives us the &#119984;nderlying carrier
of a monoid.

Loosely put, one says we have an &#8216;adjunction&#8217;, written<span class="org-latex-and-related"> $&#8466; &#8867; &#119984;$.</span>

Observe that natural numbers <span class="org-code">&#8469; &#8773; List Unit</span> are a monoid whose operation is commutative.
By using different kinds of elements <span class="org-code">A</span> --and, importantly, still not imposing any equations--
we lose commutativity with <span class="org-code">List A</span>.
Then by generalising further to binary trees <span class="org-code">BinTree A</span>, we lose associtivity and identity
<span class="writegood-duplicates">are are</span> only left with a set and an operation on it ---a structure called a &#8216;magma&#8217;.

This is the order that one usually learns about these inductively built structures.
One might be curious as to what the next step up is in this hierarchy of generalisations.
It is a non-inductive type called a &#8216;graph&#8217; and in this note we investigate them by
comparison to lists.
Just as we shifted structures in the hierarchy, we will
move to a setting called a &#8216;category&#8217; ---such are more structured than magmas
but less restrictive than monoids.

For those who know category theory, this article essentially formalises the
<span class="writegood-weasels">often</span> seen phrase &#8220;consider the category generated by this diagram, or graph&#8221;.
Indeed every category is essentially a free category over a graph but with
additional equations that &#8216;confuse&#8217; two paths thereby declaring, e.g., that
one edge is the composition of two other edges.

<span class="org-hide">*</span><span class="org-level-2">* Imports</span>
<span class="org-drawer">:PROPERTIES:...
</span>
In our exploration of what graphs could possibly be and their relationships to lists are,
we shall <span class="italic">mechanise</span> or <span class="italic">implement</span> our claims since there will be <span class="writegood-weasels">many</span> details and it is <span class="writegood-weasels">easy</span>
to make mistakes --moreover as a self-learning project, I'd feel more confident to make
<span class="bold">bold</span> claims when I have a proof assistant checking my work ;-)

Before reading any further please ingrain into your mind that the Agda keyword
<span class="org-code">Set</span> <span class="writegood-passive-voice">is read</span> &#8220;type&#8221;! This disparity is a historical accident.

Since the Agda prelude is so <span class="writegood-weasels">simple</span>, the core language doesn&#8217;t even come with Booleans or numbers by default
---they must <span class="writegood-passive-voice">be imported</span> from the standard library. This is a pleasant feature.
As a result, Agda code tends to begin with a host of imports.

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">PathCat</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">

</span><span class="org-block"><span class="haskell-definition">open</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">import</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Level</span></span><span class="org-block"> using (</span><span class="org-block"><span class="haskell-constructor">Level</span></span><span class="org-block">) renaming (zero to &#8467;&#8320; ; suc to &#8467;suc ; </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#8852;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> to </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#8845;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">)

</span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Numbers
</span></span><span class="org-block"><span class="haskell-definition">open</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">import</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Data.Fin</span></span><span class="org-block">
  using (</span><span class="org-block"><span class="haskell-constructor">Fin</span></span><span class="org-block"> ; to&#8469; ; from&#8469; ; from&#8469;</span><span class="org-block"><span class="haskell-operator">&#8804;</span></span><span class="org-block"> ; reduce</span><span class="org-block"><span class="haskell-operator">&#8805;</span></span><span class="org-block"> ; inject</span><span class="org-block"><span class="haskell-operator">&#8804;</span></span><span class="org-block">)
  renaming (</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&lt;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> to _f</span><span class="org-block"><span class="haskell-operator">&lt;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> ; zero to fzero ; suc to fsuc)
</span><span class="org-block"><span class="haskell-definition">open</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">import</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Data.Nat</span></span><span class="org-block">
</span><span class="org-block"><span class="haskell-definition">open</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">import</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Relation.Binary</span></span><span class="org-block"> using (</span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">DecTotalOrder</span></span><span class="org-block">)
</span><span class="org-block"><span class="haskell-definition">open</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">import</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Data.Nat.Properties</span></span><span class="org-block"> using(</span><span class="org-block"><span class="haskell-operator">&#8804;-</span></span><span class="org-block">decTotalOrder ; </span><span class="org-block"><span class="haskell-operator">&#8804;-</span></span><span class="org-block">refl)
</span><span class="org-block"><span class="haskell-definition">open</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">DecTotalOrder</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">Data.Nat.Properties.&#8804;-</span></span><span class="org-block">decTotalOrder

</span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Z-notation for sums
</span></span><span class="org-block"><span class="haskell-definition">open</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">import</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Data.Product</span></span><span class="org-block"> using (</span><span class="org-block"><span class="haskell-constructor">&#931;</span></span><span class="org-block"> ; proj&#8321; ; proj&#8322; ; </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#215;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> ; </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">,</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">)
</span><span class="org-block"><span class="haskell-constructor">&#931;</span></span><span class="org-block"><span class="haskell-definition">&#8758;&#8226;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> {a b </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Level</span></span><span class="org-block">} (</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block"> a) (</span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block"> b) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block"> (a </span><span class="org-block"><span class="haskell-operator">&#8845;</span></span><span class="org-block"> b)
</span><span class="org-block"><span class="haskell-constructor">&#931;</span></span><span class="org-block"><span class="haskell-definition">&#8758;&#8226;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#931;</span></span><span class="org-block">
</span><span class="org-block"><span class="haskell-keyword">infix</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-definition">-</span></span><span class="org-block">666 </span><span class="org-block"><span class="haskell-constructor">&#931;</span></span><span class="org-block"><span class="haskell-operator">&#8758;&#8226;</span></span><span class="org-block">
</span><span class="org-block"><span class="haskell-definition">syntax</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#931;</span></span><span class="org-block"><span class="haskell-operator">&#8758;&#8226;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> (&#955; x </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#931;</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8226;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block">

</span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Equalities
</span></span><span class="org-block"><span class="haskell-definition">open</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">import</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Relation.Binary.PropositionalEquality</span></span><span class="org-block"> using (</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#8791;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> ; </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">)
  renaming (sym to </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">sym ; refl to </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl ; trans to </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">&#10216;</span><span class="org-block"><span class="haskell-operator">&#8801;&#8801;</span></span><span class="org-block">&#10217;</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">
           ; cong to </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">cong ; cong&#8322; to </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">cong&#8322;
           ; subst to </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">subst ; subst&#8322; to </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">subst&#8322; ; setoid to </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">setoid)
</span><span class="org-block-end-line">#+END_SRC
</span>
Notice that we renamed transitivity to be an infix combinator.

Let us make equational-style proofs available for any type.
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> {i} {</span><span class="org-block"><span class="haskell-constructor">S</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block"> i} </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
    open </span><span class="org-block"><span class="haskell-keyword">import</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Relation.Binary.EqReasoning</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">setoid </span><span class="org-block"><span class="haskell-constructor">S</span></span><span class="org-block">) public
</span><span class="org-block-end-line">#+END_SRC
</span>
We intend our proofs to be sequences of formulae interleaved with
justifications for how the formulae <span class="writegood-passive-voice">are related</span>. At times, the justifications
are by definition and so may <span class="writegood-passive-voice">be omitted</span>, but we may want to mention them
for presentational --pedagogical?-- purposes. Hence, we introduce the
combinator notation <span class="org-code">lhs &#8801;&#10216;" by definition of something "&#10217;&#8242; rhs</span>.
<span class="comment"># --note that this combinator </span><span class="comment"><span class="writegood-passive-voice">is intended</span></span><span class="comment"> to only </span><span class="comment"><span class="writegood-passive-voice">be used</span></span><span class="comment"> in calculations.</span>

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="haskell-definition">open</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">import</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Agda.Builtin.String</span></span><span class="org-block">

defn</span><span class="org-block"><span class="haskell-definition">-</span></span><span class="org-block">chasing </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {i} {</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block"> i} (x </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">String</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block">
defn</span><span class="org-block"><span class="haskell-definition">-</span></span><span class="org-block">chasing x reason supposedly</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">x</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">again </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> supposedly</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">x</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">again

</span><span class="org-block"><span class="haskell-definition">syntax</span></span><span class="org-block"> defn</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">chasing x reason xish </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216; reason &#10217;</span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block"> xish

</span><span class="org-block"><span class="haskell-keyword">infixl</span></span><span class="org-block"> 3 defn</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">chasing
</span><span class="org-block-end-line">#+END_SRC
</span>
While we&#8217;re making synonyms for readability, let&#8217;s make another:
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">_even</span><span class="org-block"><span class="haskell-definition">-</span></span><span class="org-block">under_ </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {a b} {</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block"> a} {</span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block"> b} {x y} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> y </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (f </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> f x </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> f y
_even</span><span class="org-block"><span class="haskell-definition">-</span></span><span class="org-block">under_ </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; eq f </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">cong f eq
</span><span class="org-block-end-line">#+END_SRC
</span>
Example usage would be to prove
<span class="org-code">mor G (mor F Id) &#8801; mor G Id</span> directly by <span class="org-code">&#8801;-cong (mor G) (id F)</span>
which can <span class="writegood-passive-voice">be written</span> more <span class="writegood-weasels">clearly</span> as
<span class="org-code">functor F preserves-identities even-under (mor G)</span>,
while longer it is also much clearer and easier to read and understand
--self-documenting in <span class="writegood-weasels">some</span> sense.

<span class="writegood-weasels">Interestingly</span>, our first calculational proof is in section 5 when
we introduced an large &#119966;&#119990;&#120009;egory.

<span class="org-level-1">* </span><span class="org-level-1"><span class="italic">Graph me to the moon!</span></span>
<span class="org-drawer">:PROPERTIES:...
</span>
<span class="org-block-begin-line">#+BEGIN_CENTER
</span><span class="italic">What's a graph? Let's motivate categories!</span>
<span class="org-block-end-line">#+END_CENTER
</span>
<span class="org-hide">*</span><span class="org-level-2">* Intro                                                             </span><span class="org-level-2"><span class="org-tag">:ignore:</span></span>
<span class="org-drawer">   :PROPERTIES:...
</span>A &#8216;graph&#8217; is just a parallel-pair of maps,
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="haskell-definition">record</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
  field
    </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">   </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block">
    </span><span class="org-block"><span class="haskell-constructor">E</span></span><span class="org-block">   </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block">
    src </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">E</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">
    tgt </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">E</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">
</span><span class="org-block-end-line">#+END_SRC
</span>This of-course captures the usual notion of a set of nodes <span class="org-code">V</span> and a set of directed and labelled
edges <span class="org-code">E</span> where an edge <span class="org-code">e</span> begins at <span class="org-code">src e</span> and concludes at <span class="org-code">tgt e</span>.

What is good about this definition is that it can <span class="writegood-passive-voice">be phrased</span> in any category: <span class="org-code">V</span> and <span class="org-code">E</span> are
any two objects and <span class="org-code">src, tgt</span> are a parallel pair of morphisms between them.
How wonderful! We can study the notion of graphs in arbitrary categories!
---This idea will <span class="writegood-passive-voice">be made</span> clearer when categories and functors are formally introduced.

However, the notion of structure-preserving map between graphs, or &#8216;graph-maps&#8217; for short,
then becomes:

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="haskell-definition">record</span></span><span class="org-block"> _&#119970;</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">&#8320;</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block">&#8320;) </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
  open </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block">&#8320;
  field
    vertex </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">(</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">(</span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">)
    edge   </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">E</span></span><span class="org-block">(</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">E</span></span><span class="org-block">(</span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">)
    src</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">preservation </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> e </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> src(</span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">) (edge e) </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">  vertex (src(</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">) e)
    tgt</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">preservation </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> e </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> tgt(</span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">) (edge e) </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">  vertex (tgt(</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">) e)
</span><span class="org-block-end-line">#+END_SRC
</span>( The fancy &#119970; and &#10230; <span class="writegood-passive-voice">are obtained</span> in Agda input mode by <span class="org-code">\McG</span> and <span class="org-code">\--&gt;</span>, respectively. )

This is a bit problematic in that we have two proof obligations and at a first glance it is not
at all clear their motivation besides &#8216;&#8216;structure-preserving&#8217;&#8217;.

However, our aim is in graphs in usual type theory, and as such we can use a definition that is
equivalent in this domain: A graph is a
type <span class="org-code">V</span> of vertices and a &#8216;type&#8217; <span class="org-code">v &#10230; v&#8217;</span> of edges for each pair of vertices <span class="org-code">v</span> and <span class="org-code">v&#8217;</span>.
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">&#8216;small graphs&#8217; , since we are not using levels
</span></span><span class="org-block"><span class="haskell-definition">record</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
  field
    </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">    </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block">
    </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block">

</span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">i.e., Graph &#8776; &#931; V &#8758; Set &#8226; (V &#8594; V)
</span></span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Graphs are a dependent type!
</span></span><span class="org-block-end-line">#+END_SRC
</span>
Now the notion of graph-map, and the meaning of structure-preserving, come to the forefront:

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="haskell-definition">record</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">GraphMap</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
    private
      open </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block"> using (</span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">)
      </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">g_ </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> Graph._</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">
      </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">h_ </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> Graph._</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">
    field
      ver  </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">(</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">(</span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">)                                </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">vertex morphism
</span></span><span class="org-block">      edge </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> {x y </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">(</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">)} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">g y) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (ver x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">h ver y) </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">arrow preservation
</span></span><span class="org-block">
</span><span class="org-block"><span class="haskell-definition">open</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">GraphMap</span></span><span class="org-block">
</span><span class="org-block-end-line">#+END_SRC
</span>
Note <span class="org-code">edge</span> essentially says that <span class="org-code">mor</span> &#8216;shifts&#8217;, or &#8216;translates&#8217;, types
<span class="org-code">x &#10230;g y</span> into types <span class="org-code">ver x &#10230;h ver y</span>.

While equivalent, this two-piece definition is preferable over the four-piece one given
earlier since it means less proof-obligations and less constructions in general, but the same
expressiblity. Yay!

Before we move on, let us give an example of a <span class="writegood-weasels">simple</span> chain-graph.
For clarity, we present it in both variations.
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">embedding: j &lt; n &#8658; j &lt; suc n
</span></span><span class="org-block">`</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{n} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Fin</span></span><span class="org-block"> n </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Fin</span></span><span class="org-block"> (suc n)
` j </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> inject</span><span class="org-block"><span class="haskell-operator">&#8804;</span></span><span class="org-block"> j (</span><span class="org-block"><span class="haskell-operator">&#8804;-</span></span><span class="org-block">step </span><span class="org-block"><span class="haskell-operator">&#8804;-</span></span><span class="org-block">refl) </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block"> open </span><span class="org-block"><span class="haskell-keyword">import</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Data.Nat.Properties</span></span><span class="org-block"> using (</span><span class="org-block"><span class="haskell-operator">&#8804;-</span></span><span class="org-block">step)
</span><span class="org-block-end-line">#+END_SRC
</span>This' an example of a &#8216;forgetful functor&#8217;, keep reading!

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">[</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">]&#8320; </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#8469;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block">&#8320;
[ n ]&#8320; </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> record
    { </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Fin</span></span><span class="org-block"> (suc n)                  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">&#8776; {0, 1, ..., n - 1, n}
</span></span><span class="org-block">    ; </span><span class="org-block"><span class="haskell-constructor">E</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Fin</span></span><span class="org-block"> n                        </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">&#8776; {0, 1, ..., n - 1}
</span></span><span class="org-block">    ; src </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; j </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> ` j
    ; tgt </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; j </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> fsuc j
    }
</span><span class="org-block-end-line">#+END_SRC
</span>That is, we have <span class="org-code">n+1</span> vertices named <span class="org-code">0, 1, &#8230;, n</span> and <span class="org-code">n</span> edges named <span class="org-code">0, 1, &#8230;, n-1</span>
with one typing axiom being <span class="org-code">j : j &#10230; (j+1)</span>. Alternatively,

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">[</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">] </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#8469;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block">
[ n ] </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> record {</span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Fin</span></span><span class="org-block"> (suc n) ; </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; x y </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> fsuc x </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> ` y }
</span><span class="org-block-end-line">#+END_SRC
</span>
<span class="org-hide">*</span><span class="org-level-2">* Types Require Casting</span>
<span class="org-drawer">   :PROPERTIES:...
</span>However, we must admit that a slight downside of the typed approach
--the two-piece definition-- is now
we may need to use the following &#8216;shifting&#8217; combinators:
They shift, or slide, the edge types.

<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">-- casting
_&#10219;_ : &#8704;{x </span><span class="custom"><span class="writegood-duplicates">y y</span></span><span class="custom">&#8217;} &#8594;  (x &#10230; y) &#8594; (y &#8801; y&#8217;) &#8594; (x &#10230; y&#8217;)
e &#10219; &#8801;-refl = e

-- Casting leaves the edge the same, only type information changes
&#8773;-&#10219; : &#8704;{x </span><span class="custom"><span class="writegood-duplicates">y y</span></span><span class="custom">&#8217;} {e : x &#10230; y} (y&#8776;y&#8217; : y &#8801; y&#8217;) &#8594; e &#8773; (e &#10219; y&#8776;y&#8217;)
&#8773;-&#10219; &#8801;-refl = &#8773;-refl
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>
Such is the cost of using a typed-approach.

Even worse, if we use homogeneous equality then we&#8217;d have the ghastly operator
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">&#8801;-&#10219; : &#8704;{x </span><span class="custom"><span class="writegood-duplicates">y y</span></span><span class="custom">&#8217;} {e : x &#10230; y} (y&#8776;y&#8217; : y &#8801; y&#8217;) &#8594; e &#10219; y&#8776;y&#8217; &#8801; (&#8801;-subst (&#955; &#969; &#8594; x &#10230; &#969;) y&#8776;y&#8217; e)
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>
However, it seems that our development does not even make use of these.
Lucky us! However, it is something to be aware of.

<span class="org-hide">*</span><span class="org-level-2">* Signatures</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
A <span class="italic">signature</span> consists of &#8216;sort symbols&#8217; and &#8216;function symbols&#8217; each of which <span class="writegood-passive-voice">is associated</span> source-sorts
and a target-sort --essentially it is an interface in the programming sense of the word thereby providing
a lexicon for a language.
A <span class="italic">model</span> or <span class="italic">algebra</span> of a language is an interpretation of the sort symbols as sets and an interpretation of the
function symbols as functions between those sets; i.e., it is an <span class="italic">implementation</span> in programming terms.
Later you may note that instead of sets and functions we may use the objects and morphisms of
a fixed category instead, and so get a model in that category.

<span class="org-block-begin-line">#+BEGIN_CENTER
</span><span class="org-table">| </span><span class="org-table"><span class="underline">Math</span></span><span class="org-table">           | &#8773; | </span><span class="org-table"><span class="underline">Coding</span></span><span class="org-table">                             |</span>
<span class="org-table">| Signature      |   | Interface, record type, class      |</span>
<span class="org-table">| Algebra        |   | Implementation, instance, object   |</span>
<span class="org-table">| Language Term  |   | Syntax                             |</span>
<span class="org-table">| Interpretation |   | Semantics, i.e., an implementation |</span>
<span class="org-block-end-line">#+END_CENTER
</span>
Formally, one-sorted signatures <span class="writegood-passive-voice">are defined</span>:
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="haskell-definition">open</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">import</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Data.Vec</span></span><span class="org-block">
  using (</span><span class="org-block"><span class="haskell-constructor">Vec</span></span><span class="org-block">)
  renaming (</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#8759;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> to </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">,,</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> ; </span><span class="org-block"><span class="haskell-constructor">[]</span></span><span class="org-block"> to nil) </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">, already in use for products :/
</span></span><span class="org-block">
</span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">one sorted
</span></span><span class="org-block"><span class="haskell-definition">record</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Signature</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
    field
     </span><span class="org-block"><span class="haskell-constructor">&#119977;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#8469;</span></span><span class="org-block">        </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">How </span></span><span class="org-block"><span class="comment"><span class="writegood-weasels">many</span></span></span><span class="org-block"><span class="comment"> function symbols there are
</span></span><span class="org-block">     ar </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Vec</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#8469;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119977;</span></span><span class="org-block"> </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Their arities: lookup i ar == arity of i-th function symbol
</span></span><span class="org-block">
</span><span class="org-block"><span class="haskell-definition">open</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Signature</span></span><span class="org-block"> &#10627;</span><span class="org-block"><span class="haskell-operator">...</span></span><span class="org-block">&#10628; </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">&#119977; now refers to the number of function symbols in a signature
</span></span><span class="org-block-end-line">#+END_SRC
</span>
For example, the signature of monoids consists of a single sort symbol <span class="org-code">C</span> --which can <span class="writegood-passive-voice">be
interpreted</span> as the carrier of the monoid-- and two function symbols <span class="org-code">m , u</span>
--which can <span class="writegood-passive-voice">be interpreted</span> as the monoid multiplication and unit-- with source-target
sort lists <span class="org-code">((),C) , ((C,C), C)</span> ---<span class="writegood-weasels">some</span> would notate this by <span class="org-code">u :&#8594; C , m : C &#215; C &#8594; C</span>.
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="haskell-constructor">MonSig</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-definition">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Signature</span></span><span class="org-block">
</span><span class="org-block"><span class="haskell-constructor">MonSig</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> record { </span><span class="org-block"><span class="haskell-constructor">&#119977;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> 2 ; ar </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> 0 ,, 2 ,, nil }
</span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">unit u : X&#8304; &#8594; X and multiplication m : X&#178; &#8594; X
</span></span><span class="org-block-end-line">#+END_SRC
</span>
Generalising on monoids by typing the multiplication we obtain
the signature of categories which consists of three sort symbols <span class="org-code">O, A, C</span> --which can <span class="writegood-passive-voice">be
interepreted</span> as objects, arrows, and composable pairs of arrows-- and four function symbols
<span class="org-code">&#10814; , src, tgt, id</span> with source-target sort lists <span class="org-code">(C,A) , (A,O) , (A,O) , (O,A)</span>
---notice that only a language of symbols
has <span class="writegood-passive-voice">been declared</span> without any properties besides those of typing. If we discard <span class="org-code">C, &#10814;, id</span> we
then obtain the signature of graphs. Without knowing what categories are, we have seen that their
signatures are similar to both the graph and monoid signatures and so expect their logics to
also be similar. Moreover we now have a <span class="writegood-weasels">few</span> slogans,
<span class="org-latex-and-related">\[\color{green}{\text{Categories are precisely typed monoids!}}\]</span>
<span class="org-latex-and-related">\[\color{green}{\text{Categories are precisely graphs with a monoidal structure!}}\]</span>
<span class="org-latex-and-related">\[\color{green}{\text{Categories are precisely coherently constructive lattices!}}\]</span>

( The last one is <span class="writegood-weasels">completely</span> unmotivated from our discussion, but it's a good place for the slogan and
  will <span class="writegood-passive-voice">be touched</span> on when we look at examples of categories. )

A signature can <span class="writegood-passive-voice">be visualised</span> in the plane by associating a dot for each sort symbol and an arrow
for each function symbol such that the arrow has a tail from each sort in the associated function
symbols source sorts list and the end of the arrow is the target sort of the sort symbol.
That is, a signature can <span class="writegood-passive-voice">be visualised</span> as a hyper-graph.

+ A signature whose function symbols each have only one sort symbol for source-sorts <span class="writegood-passive-voice">is called</span> a
  &#8216;graph signature&#8217; since it corresponds to ---or can <span class="writegood-passive-voice">be visualised</span> as--- a graph.

+ Then a model of a graph (signature) <span class="org-code">&#119970;</span> is an interpreation/realisation of the graph&#8217;s vertices
  as sets and the graph&#8217;s edges as functions between said sets.

+  A model of <span class="org-code">&#119970;</span> is nothing more than a graph morphism
   <span class="org-code">&#119970; &#10230; &#119982;e&#120009;</span>, where <span class="org-code">&#119982;e&#120009;</span> is the graph with vertices being sets and edges being functions.

Notice that a <span class="org-code">Graph&#8320;</span> is precisely a model of the graph <span class="org-code">&#8226; &#8649; &#8226;</span>, which consists of
two vertices and two edges from the first vertex to the second vertex.
We will return to this point ;-)

Before we move on, it is important to note that a signature does not capture any
constraints required on the symbols --e.g., a monoid is the monoid signature as well
as the constraint that the 2-arity operation is associative and the 0-arity operation is its unit.
More generally, a <span class="italic">specification</span> consists of a signature declaring symbols of interest,
along with a set of sentences over it that denote axioms or constraints.
In programming parlance, this is an interface consisting of types and functions
that need to <span class="writegood-passive-voice">be provided</span> and implemented, along with constraints that are usually documented in comments.
Unsurprisingly, models of specifications also form categories.

<span class="org-level-1">* </span><span class="org-level-1"><span class="italic">Cats but no alligators</span></span>
<span class="org-drawer">:PROPERTIES:...
</span>
<span class="comment"># Category and functor defns</span>
<span class="comment"># {A poor-man&#8217;s definition of Category}</span>

In this section we introduce the notion of a &#8216;&#8216;poor-man&#8217;s category&#8217;&#8217; along with the notion of
structure preserving transformations and structure preserving transformations between such
transformations. The former <span class="writegood-passive-voice">are called</span> <span class="italic">functors</span> and the latter <span class="writegood-passive-voice">are known</span> as <span class="italic">natural transformations</span>
and <span class="writegood-passive-voice">are considered</span> one of the most important pieces of the fundamentals of category theory;
as such, we discuss them at length.
Afterwards, we relate this section back to our motivating discussion of graphs.

<span class="org-hide">*</span><span class="org-level-2">* Strict Categories</span>
<span class="org-drawer">   :PROPERTIES:...
</span>A category, like a monoid, is <span class="writegood-duplicates">a a</span> <span class="writegood-weasels">few</span> types and operations for which <span class="writegood-weasels">some</span> equations hold.
However, to discuss equations a notion of equality <span class="writegood-passive-voice">is needed</span> and rather than enforce one
outright it is best to let it <span class="writegood-passive-voice">be given</span>. This is a &#8216;set&#8217; in constructive mathematics:
A type with an <span class="org-code">E</span>-quivalence relation on it ---also called a <span class="italic">setoid</span> or an <span class="org-code">E</span>-set.
However, then the structure must have a <span class="writegood-weasels">few</span> added axioms: The operations must be congruences,
i.e., preserve the equivalence relation, and structure-preserving maps must also be congruences.

For our purposes we will use propositional equality and point-wise propositional equality,
and as such most of the proofs fall out of the fact that propositional equality is an equivalence.
However, this setoid structure becomes a bit of a noise, without providing any real insight for our uses,
and the issues of equivalences will be a distraction from the prime focus.
Instead, for our two cases where we use point-wise propositional,
we will postulate two forms of extensionality. Without question this is not a general approach
---then again, our aim is not to develop a library for category theory, which has already <span class="writegood-passive-voice">been
done</span> so elegantly by Kahl who calls it the <span class="org-link"><a href="http://relmics.mcmaster.ca/RATH-Agda/RATH-Agda-2.0.0.pdf">RATH-Agda</a></span> project.

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block"> </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">An anyonomous module for categorial definitions
</span></span><span class="org-block">
 record </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {i j </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Level</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block"> (&#8467;suc (i </span><span class="org-block"><span class="haskell-operator">&#8845;</span></span><span class="org-block"> j)) </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
  </span><span class="org-block"><span class="haskell-keyword">infixr</span></span><span class="org-block"> 10 </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">
  field
    </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block">      </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block"> i
    </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">     </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block"> j
    </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">      </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">C</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">C</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">C</span></span><span class="org-block">
    assoc    </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">C</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">D</span></span><span class="org-block">} {f </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block">}{g </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">C</span></span><span class="org-block">} {h </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">C</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">D</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (f </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> g) </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> h </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> f </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> (g </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> h)
    </span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block">       </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block">
    leftId   </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block">} {f </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> f </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> f
    rightId  </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block">} {f </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> f </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> f

 open </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> using (</span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block">)
 open </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> &#10627;</span><span class="org-block"><span class="haskell-operator">...</span></span><span class="org-block">&#10628; hiding (</span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block">)

 </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment"><span class="writegood-weasels">Some</span></span></span><span class="org-block"><span class="comment"> sugar for times when we must specify the category
</span></span><span class="org-block"> </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">&#8220;colons associate to the right&#8221; ;-)
</span></span><span class="org-block">
 arr </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> Category._</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">
 syntax arr </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> x y  </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block">  x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> y </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">    </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">&#8220;ghost colon&#8221;
</span></span><span class="org-block">
 cmp </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> Category._</span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">
 syntax cmp </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> f g  </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block">  f </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> g </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">    </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">&#8220;ghost colon&#8221;
</span></span><span class="org-block-end-line">#+END_SRC
</span>
However, similar to nearly everything else in this document, we can leave the setoid approach as an exercise
for the reader, which of course has solutions being in the literate source.
<span class="org-meta-line">#
# I've moved the setoid-based theory to an appendix at the end,</span>
<span class="comment"># it seems I must enforce setoid structure at the outset</span>
<span class="comment"># and I really do not think it is worth it for my intended purposes; moreover,</span>
<span class="comment"># it adds noise to the presentation without giving enough insight.</span>

Moreover, lest you&#8217;re not convinced that my usage of extensionality is at all acceptable,
then note that others have used it to simplify their presentations; e.g.,
<span class="org-link"><a href="http://cs.ioc.ee/~tarmo/papers/jfr14.pdf">Relative monads formalised</a></span>.
Such &#8216;appeal to authority&#8217; is for the lazy reader who dares not think for him- or her-self,
otherwise one ought to read up on the <span class="org-link"><a href="https://ncatlab.org/nlab/show/principle+of+equivalence">evils</a></span>
of using equality instead of equivalence relations so as to understand
<span class="org-link"><a href="http://www.math.harvard.edu/~mazur/preprints/when_is_one.pdf">when one thing is really another</a></span>.

The diligent reader may <span class="writegood-passive-voice">be interested</span> to know that Maarten Fokkinga has written a <span class="writegood-weasels">very</span>
<span class="org-link"><a href="http://maartenfokkinga.github.io/utwente/mmf92b.pdf">gentle introduction to category theory using the calculational approach</a></span>; I highly recommend it!

Anyhow, in place of strict equality, one uses categorical isomorphism instead.
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"> open </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> using (</span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block">) public

 record </span><span class="org-block"><span class="haskell-constructor">Iso</span></span><span class="org-block"> {i} {j} (</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {i} {j}) (</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block"> j </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
   private </span><span class="org-block"><span class="haskell-keyword">instance</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">&#119966;</span></span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">Category</span></span><span class="org-block"> ; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">
   field
     to   </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block">
     from </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block">
     lid  </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> to </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> from </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block">
     rid  </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> from </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> to </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block">

 syntax </span><span class="org-block"><span class="haskell-constructor">Iso</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8773;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> within </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">
</span><span class="org-block-end-line">#+END_SRC
</span>
<span class="writegood-weasels">Interestingly</span>, we shall later encounter a rather large category named
&#119966;&#119990;&#120009; possessing the special property of being a <span class="org-link"><a href="https://ncatlab.org/nlab/show/2-category">&#8220;2-Category&#8221;</a></span>:
It has morphisms between objects, as expected, which are now called &#8220;1-morphisms&#8221;,
and it has morphisms between 1-morphisms, also called &#8220;2-morphisms&#8221;.

That is, it has morphisms between morphisms.

Above we argued that equality should <span class="writegood-passive-voice">be deferred</span> in favour of isomorphism
at the morphism level. Hence, in a 2-Category, it is only reasonable to defer
an equation involving objects to be up to isomorphism of 2-morphisms
---this is then called an &#8220;equivalence&#8221;.
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">&#8466;HS &#8771; &#8475;HS  &#8660;  &#931; F &#8758; &#8466;HS &#10230; &#8475;HS &#8226; &#931; G &#8758; &#8475;HS &#10230; &#8466;HS &#8226; F &#10814; G &#8773; G &#10814; F &#8773; Id
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>
Hence when it comes to categories themselves, one usually speaks in terms of
equivalences rather than isomorphisms.

<span class="comment"># E.g., &#119982;e&#120009; ^ S &#8771; &#119982;e&#120009; / S, where S </span><span class="comment"><span class="writegood-passive-voice">is construed</span></span><span class="comment"> as a discrete category</span>
<span class="comment"># on the lhs but a set on the rhs.</span>

<span class="comment"># also :: every category is equivalent to a skeletal subcategory</span>

For example, let &#119979;&#119990;&#120007; be the supercategory of &#119982;e&#120009; with morphisms being &#8216;partial
functions&#8217; <span class="org-code">(A &#10230; B) = (A &#8594; B + &#120793;)</span> where the extra element of <span class="org-code">&#120793; = { * }</span> represents
&#8216;undefined&#8217; ---also known as the <span class="org-code">Partial</span>, <span class="org-code">Option</span>, or <span class="org-code">Maybe</span> monads.  Moreover,
let &#119979;&#119982;&#8495;&#120009; be the category of sets with an elected point.  Then, <span class="org-code">&#119979;&#119990;&#120007; &#8771; &#119979;&#119982;e&#120009;</span> <span class="writegood-passive-voice">is
witnessed</span> by <span class="org-code">(A &#10230; B) &#8614; ( (A + &#120793;, *) &#10230; (B + &#120793;, *) )</span> and conversely
<span class="org-code">( (A , a) &#10230; (B , b) ) &#8614; ( A - a &#10230; B - b)</span> where
<span class="org-macro">{{{newline}}}</span> <span class="org-code">X - x &#8801; &#931; y &#8758; X &#8226; &#172;(x &#8801;
y)</span>. Exercise: Work out the remaining details for the equivalence.

<span class="org-drawer">:ParSetup:...
</span>
<span class="org-hide">*</span><span class="org-level-2">* </span><span class="org-special-keyword">COMMENT</span><span class="org-level-2"> arrows in a particular category </span><span class="org-level-2"><span class="org-tag">:syntax:</span></span>
<span class="org-drawer">   :PROPERTIES:...
</span>
 arr-in-cat : &#8704;{i j} (&#119966; : Category {i} {j}) (A B : Obj &#119966;) &#8594; Set j
 arr-in-cat = Category._&#10230;_
 infix -66 arr-in-cat
 syntax arr-in-cat &#119966; A B  =  A &#10230; B &#8758; &#119966; -- note the &#8220;ghost colon&#8221;

 -- open Category &#10627;...&#10628; hiding (Obj)
 open Category using (Id)

<span class="org-hide">*</span><span class="org-level-2">* Familiar </span><span class="org-level-2"><span class="org-code">&#119982;&#8495;&#120009;</span></span><span class="org-level-2">-tings</span>
<span class="org-drawer">   :PROPERTIES:...
</span>Let us give <span class="writegood-weasels">some</span> elementary examples of the notion of a category to exhibit its ubiquity.

<span class="org-hide">**</span><span class="org-level-3">* &#119982;&#8495;&#120009;'s</span>
<span class="org-drawer">    :PROPERTIES:...
</span>The collection of small, say level <span class="org-code">i</span>, types and functions between them and usual function composition
with usual identity form a category and this is not at all difficult to see:
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">instance</span></span><span class="org-block">
  </span><span class="org-block"><span class="haskell-type">&#119982;e&#120009;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {i} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">Category</span></span><span class="org-block"> {&#8467;suc i} {i} </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">this is a &#8216;big&#8217; category
</span></span><span class="org-block">  </span><span class="org-block"><span class="haskell-constructor">&#119982;e&#120009;</span></span><span class="org-block"> {i} </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> record {
      </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block"> i
    ; </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block">)
    ; </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; f g </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (&#955; x </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> g (f x))
    ; assoc </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl
    ; </span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; x </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> x
    ; leftId </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl
    ; rightId </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl
    }
</span><span class="org-block-end-line">#+END_SRC
</span>Sadly, this category is traditionally used to motivate constructions in arbitrary categories
and as such people usually think of objects in an arbitrary category as nothing more than
sets with extra datum ---which is <span class="writegood-weasels">completely</span> false.

For example, the category <span class="org-code">Div</span> consists of objects <span class="italic">and</span> arrows both being numbers &#8469;
and there is an arrow<span class="org-latex-and-related"> $k : m &#8594; n$ </span>precisely when <span class="org-code">k &#215; m = n</span>, so that an arrow is a
constructive witness that<span class="org-latex-and-related"> $m$ </span>divides<span class="org-latex-and-related"> $n$.</span> Notice that besides &#8469;, no sets nor functions
<span class="writegood-passive-voice">were involved</span> in the making of this useful number-theoretic category.
<span class="comment"># --if you know </span><span class="comment"><span class="writegood-weasels">some</span></span><span class="comment"> category theory, convince yourself that this category is interesting</span>
<span class="comment"># by showing, for example, that multiplication distributes over gcd where gcd is the</span>
<span class="comment"># categorial product construction.</span>

<span class="org-hide">**</span><span class="org-level-3">* Sets are trivial categories</span>
<span class="org-drawer">    :PROPERTIES:...
</span>
Recall that a type, or set, is nothing more than a specified collection of values.

Every set is also a category: There is a formal syntactic object associated with each element, the only morphisms are (formal)
identities, and composition is constantly a syntactic identity.
<span class="writegood-weasels">Some</span> define a set to be a category with only identity morphisms; also called a
&#8216;discrete category&#8217; when one wants to distance themself from set theory ;)
---less loosely, a discrete category over a type <span class="org-code">S</span> has <span class="org-code">Obj = S</span> and <span class="org-code">(x &#10230; y) = (x &#8801; y)</span>,
where the equivalence is classical, having two possible members <span class="italic">true</span> or <span class="italic">false</span>.

Discrete categories are <span class="writegood-weasels">quite</span> an important space for <span class="org-link"><a href="http://homotopytypetheory.org/">hott</a></span> people ...
that&#8217;s right, attractive people <span class="writegood-passive-voice">are interested</span> in these things.

Observe that all arrows are invertible! ---due to the symmetry of equality.
Categories with this property <span class="writegood-passive-voice">are known</span> as <span class="italic">groupoids</span>.

<span class="org-hide">**</span><span class="org-level-3">* Categories </span><span class="org-level-3"><span class="writegood-passive-voice">are typed</span></span><span class="org-level-3"> monoids</span>
<span class="org-drawer">    :PROPERTIES:...
</span>
Recall that a monoid <span class="org-code">(M, &#8853;, e)</span> is a type <span class="org-code">M</span> with an associative operation <span class="org-code">&#8853; : M &#215; M &#8594; M</span>
that has a unit <span class="org-code">e</span>.

Every monoid is also a category: There is one object, call it <span class="org-code">&#9733;</span>, the morphisms are the monoid
elements, and composition is the monoid operation.
---less loosely, for a monoid <span class="org-code">(M, &#8853;, e)</span> we take <span class="org-code">Obj = {&#9733;} , </span><span class="org-code"><span class="underline">&#10230;</span></span><span class="org-code"> = M</span>.

In fact, <span class="writegood-weasels">some</span> would define a monoid to be a one-object category!
--I'm looking at you <span class="org-link"><a href="https://books.google.ca/books/about/Categories_Allegories.html?id=fCSJRegkKdoC&amp;printsec=frontcover&amp;source=kp_read_button&amp;redir_esc=y#v=onepage&amp;q&amp;f=false">Freyd &amp; Scedrov</a></span> =)

<span class="org-hide">**</span><span class="org-level-3">* Categories are coherently preordered sets</span>
<span class="org-drawer">    :PROPERTIES:...
</span>
<span class="org-link"><a href="http://www.cs.utexas.edu/~EWD/ewd11xx/EWD1102.PDF">Recall</a></span> that a preordered set, or preset, is a type <span class="org-code">P</span> with a relation <span class="org-code">&#8804;</span> on
it that satisfies <span class="italic">indirect inequality from above</span>:
<span class="org-latex-and-related">\[
  &#8704; x , y &#8226;\qquad x &#8804; y \quad&#8660;\quad (&#8704; z &#8226;\; y &#8804; z &#8658; x &#8804; z)
\]</span>
Equivalently, if it satisfies <span class="italic">indirect equality from below</span>:
<span class="org-latex-and-related">\[ &#8704; x , y &#8226;\qquad x &#8804; y \quad&#8660;\quad (&#8704; z &#8226;\; z &#8804; x &#8658; z &#8804; y) \]</span>
If we also have<span class="org-latex-and-related"> $&#8704; x , y &#8226;\; x &#8804; y \,&#8743;\, y &#8804; x \;&#8658;\; x = y$,</span>
then we say <span class="org-code">(P, &#8804;)</span> is a &#8216;poset&#8217; or an &#8216;ordered set&#8217;.

Every (pre)ordered set is also a category:
The objects are the elements,
the morphisms are the order-relations,
identities are the relfexitivity of <span class="org-code">&#8804;</span>,
and composition is transitivity of <span class="org-code">&#8804;</span>.
To see this more <span class="writegood-weasels">clearly</span>, suppose you have a group<span class="org-latex-and-related">
$(M, &#8853;, \_{}&#8315;&#185;, e)$ </span>and you define<span class="org-latex-and-related"> $x &#8804; y \;&#8660;\; (&#8707; m : M &#8226;\; m &#8853; x = y)$
</span>then the this is a preorder whose induced category has a morphism<span class="org-latex-and-related">
$m : x &#8594; y$ </span>precicely when<span class="org-latex-and-related"> $m &#8853; x = y$
</span>--now sit down and define the remaining categorical structure of this
&#8216;constructive&#8217; preorder associated to the group.
<span class="comment"># and check that this category has $e$ for identity maps and $&#8853;$</span><span class="org-latex-and-related">
</span><span class="comment"># for composition of morphisms.</span>
<span class="org-meta-line">#
# Preorder:</span>
<span class="comment"># If m &#8853; x = y  and n &#8853; y = x</span>
<span class="comment"># Then x = n &#8853; y = n &#8853; m &#8853; x whence e = n &#8853; m, whence we have isos not necessarily equality.</span>

Traditionally, classically, the relation <span class="org-code">&#8804;</span> is precicely a function <span class="org-code">P &#215; P &#10230; &#120121; = {true, flase}</span>
and thus there is at-most one morphism between any two objects
--consequently, categories with this property <span class="writegood-passive-voice">are called</span> <span class="italic">poset categories</span>.

In the constructive setting, the relation <span class="org-code">&#8804;</span> <span class="writegood-passive-voice">is typed</span> <span class="org-code">P &#215; P &#8594; Set</span> and then
for a preset <span class="org-code">(P, &#8804;)</span> we take <span class="org-code">Obj = P, </span><span class="org-code"><span class="underline">&#10230;</span></span><span class="org-code"> = a &#8804; b</span> and insist
on &#8216;proof-irrelevance&#8217; <span class="org-code">&#8704; {a b} (p q : a &#8804; b) &#8594; p &#8801; q</span> so that there is at most one morphism
between any two objects.
The restriction is not needed if we were using actual categories-with-setoids since then we would
<span class="italic">define</span> morphism equality to be <span class="org-macro">{{{newline}}}</span>
<span class="org-code">((a, b, p) &#8776; (a&#8217;, b&#8217;, q) )  =  (a &#8801; a&#8217;  &#215;  b &#8801; b&#8217;)</span>.

Observe that in the case we have a poset, every isomorphism is an equality:
<span class="org-latex-and-related">\[
  &#8704; x, y &#8226;\qquad x &#8773; y &#8660; x &#8801; y
\]</span>
Categories with this property <span class="writegood-passive-voice">are called</span> <span class="italic">skeletal</span>.
Again, hott people like this; so much so, that they want it, more-or-less, to be a
<span class="org-link"><a href="http://arxiv.org/abs/1302.4731">foundational axiom</a></span>!

Poset categories are a wonderful and natural motivator for <span class="writegood-weasels">many</span> constructions and definitions in
category theory. This idea is so broad-reaching that it would not be an exaggeration to think of
<span class="org-link"><a href="http://www.cs.nott.ac.uk/~psarb2/papers/abstract.html#CatTheory">categories as coherently constructive lattices</a></span>!

<span class="org-hide">**</span><span class="org-level-3">* Groupoids</span>
<span class="org-drawer">    :PROPERTIES:...
</span>Equivalence relations are relations that are symmetric, reflexive, and transitive.
Alternatively, they are preorder categories where every morphism is invertible ---this is the
symmetry property. But categories whose morphisms are invertible are groupoids!

Hence, groupoids can <span class="writegood-passive-voice">be thought</span> of as generalized equivalence relations.
Better yet, as &#8220;constructive&#8221; equivalence relations: there might be more than one morphism/construction
witnessing the equivalence of two items.

<span class="writegood-weasels">Some</span> insist that a <span class="italic">true</span> &#8216;set&#8217; is a type endowed with an equivalence relation, that is a setoid.
However, since groupoids generalise equivalence relations, others might insist on a true set to be
a "groupoid". However, in the constructive setting of dependent-type theory, these notions
coincide!

<span class="org-hide">**</span><span class="org-level-3">* Rule of Thumb</span>
<span class="org-drawer">    :PROPERTIES:...
</span>
It&#8217;s <span class="writegood-passive-voice">been said</span> that the aforementioned categories should <span class="writegood-passive-voice">be consulted</span> whenever one learns a new
concept of category theory.
Indeed, these examples show that a category is a generalisation of a system of processes,
a system of compositionality, and an ordered system.

<span class="org-level-1">* </span><span class="org-level-1"><span class="italic">Endowing Structure with Functors</span></span>
<span class="org-drawer">:PROPERTIES:...
</span>
<span class="org-hide">*</span><span class="org-level-2">* Definition </span><span class="org-level-2"><span class="org-tag">:ignore:</span></span>
<span class="org-drawer">   :PROPERTIES:...
</span>Now the notion of structure-preserving maps, for categories, is just that of graphs
but with attention to the algebraic portions as well.

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"> record </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> {i j k l} (</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {i} {j}) (</span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {k} {l})
  </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block"> (&#8467;suc (i </span><span class="org-block"><span class="haskell-operator">&#8845;</span></span><span class="org-block"> j </span><span class="org-block"><span class="haskell-operator">&#8845;</span></span><span class="org-block"> k </span><span class="org-block"><span class="haskell-operator">&#8845;</span></span><span class="org-block"> l)) </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
  private
    </span><span class="org-block"><span class="haskell-keyword">instance</span></span><span class="org-block">
      </span><span class="org-block"><span class="haskell-type">&#119966;</span></span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">Category</span></span><span class="org-block"> ;  </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">
      </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> ;  </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block">  </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">
  field
    </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Usual graph homomorphism structure: An object map, with morphism preservation
</span></span><span class="org-block">    obj   </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">
    mor   </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{x y </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> y </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> obj x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> obj y
    </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Interaction with new algebraic structure: Preservation of identities &amp; composition
</span></span><span class="org-block">    id    </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{x   </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> mor (</span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> x}) </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block">       </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">identities preservation
</span></span><span class="org-block">    comp  </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{x y z} {f </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> y} {g </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> y </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> z} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> mor (f </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> g) </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> mor f </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> mor g

  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Aliases for readability
</span></span><span class="org-block">  functor_preserves</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">composition </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> comp
  functor_preserves</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">identities  </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> id

 open </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> public hiding (id ; comp)
</span><span class="org-block-end-line">#+END_SRC
</span>
For a functor <span class="org-code">F</span>, it is common practice to denote both <span class="org-code">obj F</span> and <span class="org-code">mor F</span> by <span class="org-code">F</span> and this is usually
not an issue since we can use type inference to deduce which <span class="writegood-passive-voice">is meant</span>. However, in the Agda formalization
we will continue to use the names <span class="org-code">mor , obj</span>. Incidentally in the Haskell community, <span class="org-code">mor</span>
<span class="writegood-passive-voice">is known</span> as <span class="org-code">fmap</span> but we shall avoid that name or risk asymmetry in the definition of
a functor, as is the case in Haskell which turns out to be pragmatically useful.

A functor can <span class="writegood-passive-voice">be thought</span> of as endowing an object with <span class="writegood-weasels">some</span> form of structure
---since categories are intrinsically structureless in category theory---
and so the morphism component of a functor can <span class="writegood-passive-voice">be thought</span> of as preserving relations:
<span class="org-code">f : a &#10230; b &#8658; </span><span class="org-code"><span class="writegood-duplicates">F f</span></span><span class="org-code"> : F a &#10230; F b</span> can <span class="writegood-passive-voice">be read</span> as, &#8216;&#8216;if <span class="org-code">a</span> <span class="writegood-passive-voice">is related</span> to <span class="org-code">b</span> (as witnessed by <span class="org-code">f</span>)
then their structured images are also related (as witness by <span class="org-code"><span class="writegood-duplicates">F f</span></span>)&#8217;&#8217;.
Recall the category <span class="org-code">Div</span> for constructive divisibility relationships <img src="../../.emacs.d/emojis/emojione-v2.2.6-22/1f609.png" alt=";-)" />

<span class="org-hide">*</span><span class="org-level-2">* </span><span class="org-special-keyword">COMMENT</span><span class="org-level-2"> Synonyms for Readability</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
While we&#8217;re close to the definition, let&#8217;s introduce <span class="writegood-weasels">some</span> synonyms for readability
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom"> module _ {i j k l} {&#119966; : Category {i} {j}} {&#119967; : Category {k} {l}} {F : Functor &#119966; &#119967;}
  where

    functors-preserve-composition = Functor.comp F
    functors-preserve-identities  = Functor.id F
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>We make these as synonyms rather than names in the record since we do not want to use such lengthy
identifiers when realizing functor instances. The reason we do not make these synonyms in the
record but rather in a public dummy module is to make the functor in question found from the ambient
context via the implicit declaration <span class="org-code">{F : Functor &#119966; &#119967;}</span>.

Musa: Apparently, the above intention did not work as desired.
Most of the time, I had to supply the functor anyways.

<span class="org-hide">*</span><span class="org-level-2">* </span><span class="org-special-keyword">COMMENT</span><span class="org-level-2"> Functor Conventions</span>
<span class="org-drawer">   :PROPERTIES:...
</span>In informal mathematics a functor <span class="org-code">F = (obj , mor, preservation proofs)</span>
is usually presented as <span class="org-macro">{{{newline}}}</span> <span class="italic">F = (F&#8320;, F&#8321;) is a functor (exercise to reader)</span>.

&#8220;endo&#8221;-morphism is a morphism with the
same source and target, an &#8220;auto&#8221;-morphism
is an isomorphism with the same source and
target.

Say &#8220;co&#8221;-functor as short for &#8220;co&#8221;ntravariant
functor. Notice that the composition of
cofunctors is a covaraint functor ---cf the multiplication of negative numbers is a positive functor.

<span class="org-hide">*</span><span class="org-level-2">* Examples</span>
<span class="org-drawer">  :PROPERTIES:...
</span>
A functor among monoids --construed as categories-- is just a monoid homomorphism;
i.e., an identity and multiplication preserving function of the carriers.
<span class="org-table">|   | </span><span class="org-table"><span class="italic">(M, &#8853;, e) &#10230; (N, &#8855;, d)</span></span><span class="org-table">                                |</span>
<span class="org-table">| </span><span class="org-formula">= </span><span class="org-table">| </span><span class="org-table"><span class="italic">&#931; h &#8758; M &#8594; N &#8226; &#8704; x,y &#8226; h(x &#8853; y) = h x &#8855; h y &#8743; h e = d</span></span><span class="org-table"> |</span>
<span class="comment"># By induction, h preserves all finite multiplications:</span>
<span class="comment"># h (&#8853; i &#8758; 1..n &#8226; x&#7522;) = (&#8855; i &#8758; 1..n &#8226; h x&#7522;) where</span>
<span class="comment"># (&#9733; i &#8758; 1..n &#8226; y&#7522;) &#8788; e &#9733; y&#8321; &#9733; y&#8322; &#8943; &#9733; y&#8345;.</span>
<span class="comment"># More generally,</span>
By induction, <span class="org-code">h</span> preserves all finite &#8853;-multiplication and, more generally,
functors preserve finite compositions:
<span class="org-latex-and-related">\[ F (f&#8320; &#10814; f&#8321; &#10814; &#8943; &#10814; f&#8345;) \;\;=\;\; F\,f&#8320; &#10814; F\,f&#8321; &#10814; &#8943; &#10814; F\,f&#8345; \]</span>
Cool beans <img src="../../.emacs.d/emojis/emojione-v2.2.6-22/1f642.png" alt=":-)" />
<span class="comment"># F (&#10814; i &#8758; 1..n &#8226; f&#7522;) = (&#10814; i &#8758; 1..n &#8226; </span><span class="comment"><span class="writegood-duplicates">F f</span></span><span class="comment">&#7522;)</span>
In the same way, sit down and check your understanding!
+ A functor among discrete categories is just a function of the associated sets.
+ A functor among poset categories is an order-preserving function.

Two examples of functors from a poset (category) to a monoid (category):

+ <span class="org-code">monus : (&#8469;, &#8804;) &#10230; (&#8469;,+, 0)</span> is a functor defined on morphisms by
  <span class="org-latex-and-related">\[ i &#8804; j \quad&#8658;\quad \mathsf{monus}(i,j) &#8788; j - i\]</span>
  Then the functor laws become  <span class="org-code">i - i = 0</span> and <span class="org-code">(k - j) + (j - i) = k - i</span>.

+ <span class="org-code">div : (&#8469;&#8314;, &#8804;) &#8594; (&#8474;, &#215;, 1)</span> <span class="writegood-passive-voice">is defined</span> on morphisms by
  <span class="org-latex-and-related">\[i &#8804; j \quad&#8658;\quad \mathsf{div}(i,j) &#8788; j / i\]</span>
  The functor laws become <span class="org-code">i / i = 1</span> and <span class="org-code">(k / j) &#215; (j / i) = k / i</span>.

Hey, these two seem alarmingly similar! What gives!
Well, they&#8217;re both functors from posets to monoids <img src="../../.emacs.d/emojis/emojione-v2.2.6-22/1f609.png" alt=";)" />
Also, they are instances of &#8216;residuated po-monoids&#8217;.
Non-commutative monoids <span class="writegood-weasels">may have</span> not have a general inverse operation,
but instead might have left- and right- inverse operations known as residuals
---we&#8217;ll mention this word again when discussing adjunctions and are
categorically seen as kan extensions.
Alternatively, they&#8217;re are instances of <span class="org-link"><a href="http://link.springer.com.libaccess.lib.mcmaster.ca/article/10.1007/s10773-004-7710-7">&#8216;(Kopka) Difference-posets&#8217;</a></span>.


For more examples of categories, we will need to reason
by extensionality --two things are &#8216;equal&#8217; when they have
equivalent properties ... recall Leibniz and his
<span class="org-link"><a href="https://en.wikipedia.org/wiki/Identity_of_indiscernibles">law of indiscernibles</a></span> ;p

<span class="comment"># Functors are not determined by where they send objects</span>
<span class="comment"># e.g., <a href="https://math.stackexchange.com/a/3026355/80406">https://math.stackexchange.com/a/3026355/80406</a></span>
<span class="org-level-1">* </span><span class="org-level-1"><span class="italic">The four postulates of the apocalypse</span></span>
<span class="org-drawer">:PROPERTIES:...
</span>
<span class="org-hide">*</span><span class="org-level-2">* Postulates Intro                                                  </span><span class="org-level-2"><span class="org-tag">:ignore:</span></span>
<span class="org-drawer">   :PROPERTIES:...
</span>Categories have objects and morphisms between them, functors are morphisms between categories,
and then we can go up another level and consider morphisms between functors.
These &#8216;level 2 morphisms&#8217; are pretty cool, so let&#8217;s touch on them briefly.

Recall that a poset ordering <span class="writegood-passive-voice">is extended</span> to (possibly non-monotone) functions<span class="org-latex-and-related"> $f , g$ </span>pointwise
<span class="org-latex-and-related">\[f \overset{.}{&#8804;} g \quad\iff\quad (&#8704; x &#8226;\; f\, x \,&#8804;\, g\, x)\]</span>
As such, with posets as our guide, we extend the notion of &#8216;morphism between functors&#8217;
to be a &#8216;witness&#8217; of these orderings<span class="org-latex-and-related"> $&#951; : &#8704; {X} &#8594; F\, X &#10230; G\, X$
</span>--this is a dependent type, note that the second arrow notates category morphisms, whereas
the first acts as a separator from the implicit parameter<span class="org-latex-and-related"> $X$;</span> sometimes one sees<span class="org-latex-and-related"> $&#951;_X$
</span>for each component/instance of such an operation.
<span class="comment"># <a href="http://www.jmilne.org/not/Mamscd.pdf">http://www.jmilne.org/not/Mamscd.pdf</a></span>
<span class="org-block-begin-line">#+BEGIN_CENTER
</span><span class="org-latex-and-related">$\require{AMScd}$
\begin{CD}
\color{navy}{F\, A} @&gt;\color{fuchsia}{&#951;_A}&gt;&gt;      \color{teal}{G\, A}    \\
@V\color{navy}{F\, f}VV    \!=                    @VV\color{teal}{G\, f}V \\
\color{navy}{F\, B} @&gt;&gt;\color{fuchsia}{&#951;_B}&gt;      \color{teal}{G\, B}
\end{CD}</span>
<span class="org-block-end-line">#+END_CENTER
</span>
However, then for any morphism<span class="org-latex-and-related"> $f : A &#10230; B$ </span>we have two ways to get from<span class="org-latex-and-related"> $F\, A$ </span>to<span class="org-latex-and-related"> $G\, B$ </span>via
<span class="org-code"><span class="writegood-duplicates">F f</span></span><span class="org-code"> &#10814; &#951; {B}</span> and <span class="org-code">&#951; {A} &#10814; G f</span> and rather than choose one or the other, we request that they
are identical ---similar to the case of associativity.
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">NatTrans</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {i j i&#8217; j&#8217;}  &#10627; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {i} {j} &#10628; &#10627; </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {i&#8217;} {j&#8217;} &#10628;
            (</span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block"> (j&#8217; </span><span class="org-block"><span class="haskell-operator">&#8845;</span></span><span class="org-block"> i </span><span class="org-block"><span class="haskell-operator">&#8845;</span></span><span class="org-block"> j)
 </span><span class="org-block"><span class="haskell-constructor">NatTrans</span></span><span class="org-block"> &#10627; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> &#10628; &#10627; </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> &#10628; </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block">
   </span><span class="org-block"><span class="haskell-constructor">&#931;</span></span><span class="org-block"> &#951; </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (obj </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> (obj </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block">))
       </span><span class="org-block"><span class="haskell-operator">&#8226;</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block">} {f </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> mor </span><span class="org-block"><span class="haskell-constructor"><span class="writegood-duplicates">F</span></span></span><span class="org-block"><span class="writegood-duplicates"> f</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> &#951; {</span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> &#951; {</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> mor </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> f)
</span><span class="org-block-end-line">#+END_SRC
</span>The naturality condition <span class="writegood-passive-voice">is remembered</span> by placing the target component <span class="org-code">&#951; {B}</span> <span class="italic">after</span>
lifting <span class="org-code">f</span> using the <span class="italic">source</span> functor <span class="org-code">F</span>;
likewise placing the source component <span class="italic">before</span> applying the target functor.

Another way to remember it:
<span class="org-code">&#951; : F &#10230;&#775; G</span> starts at <span class="org-code">F</span> and ends at <span class="org-code">G</span>, so the naturality also starts with <span class="org-code">F</span> and ends
with <span class="org-code">G</span>; i.e., <span class="org-code"><span class="writegood-duplicates">F f</span></span><span class="org-code"> &#10814; &#951; {B} = &#951; {A} &#10814; G f</span> :-)

It is at this junction that aforementioned problem with our definition
of category comes to light: Function equality is extensional by definition
and as such we cannot prove it.
Right now we have two function-like structures for which we will postulate a
form of extensionality,
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"> </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">function extensionality
</span></span><span class="org-block"> postulate extensionality </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {i j} {</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block"> i} {</span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block"> j}
                              {f g </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> (a </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> a}
                          </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {a} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> f a </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> g a) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> f </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> g

 </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">functor extensionality
</span></span><span class="org-block"> postulate funcext </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {i j k l} &#10627; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {i} {j} &#10628; &#10627; </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {k} {l} &#10628;
                       {</span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">}
                     </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (oeq </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {o} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> obj </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> o </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> obj </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> o)
                     </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Y</span></span><span class="org-block">} {f </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Y</span></span><span class="org-block">}
                        </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> mor </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> f  </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">  </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">subst&#8322; (Category._</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">) </span><span class="org-block"><span class="writegood-duplicates">oeq oeq</span></span><span class="org-block"> (mor </span><span class="org-block"><span class="haskell-constructor"><span class="writegood-duplicates">F</span></span></span><span class="org-block"><span class="writegood-duplicates"> f</span></span><span class="org-block">))
                     </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">

 </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">graph map extensionality
</span></span><span class="org-block"> postulate graphmapext </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block"> } {f g </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">GraphMap</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">}
                       </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (veq </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {v} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> ver f v </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> ver g v)
                       </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {x y} {e </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> Graph._</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> x y}
                          </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> edge g e </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">subst&#8322; (Graph._</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">) </span><span class="org-block"><span class="writegood-duplicates">veq veq</span></span><span class="org-block"> (edge f e))
                       </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> f </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> g

 </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">natural transformation extensionality
</span></span><span class="org-block"> postulate nattransext </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {i j i&#8217; j&#8217;} {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {i} {j} } {</span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {i&#8217;} {j&#8217;} }
                         {</span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">} (&#951; &#947; </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">NatTrans</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">)
                       </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> proj&#8321; &#951; {</span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> proj&#8321; &#947; {</span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block">})
                       </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> &#951; </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> &#947;
</span><span class="org-block-end-line">#+END_SRC
</span>
Natural transformations are too cool to end discussing so briefly
and so we go on to discuss their usage is mathematics later on.

<span class="org-hide">*</span><span class="org-level-2">* A </span><span class="org-level-2"><span class="writegood-weasels">very</span></span><span class="org-level-2"> big </span><span class="org-level-2"><span class="org-code">&#119966;&#119990;&#120009;</span></span>
<span class="org-drawer">   :PROPERTIES:...
</span>
With the notions of categories, functors, and extensionality in-hand we can now discus the
notion of the category of small categories and the category of small graphs.
Afterwards we give another example of a functor that says how every category can <span class="writegood-passive-voice">be
construed</span> as a graph.

First the category of <span class="italic">smaller</span> categories,
<span class="org-block-begin-line">#+BEGIN_QUOTE
</span><span class="org-quote"><span class="org-code">&#119966;&#119990;&#120009;</span></span><span class="org-quote"> is a category of kind </span><span class="org-quote"><span class="org-code">(&#8467;suc m, &#8467;suc m)</span></span><span class="org-quote">, where </span><span class="org-quote"><span class="org-code">m = i &#8845; j</span></span><span class="org-quote">, and its objects
are categories of kind </span><span class="org-quote"><span class="org-code">(i , j)</span></span><span class="org-quote"> and so it is not an object of itself.

Thank-you Russel and friends!

( You may proceed to snicker at the paradoxical and size issues encountered
  by those who use set theory.
  ---Then again, I&#8217;ve never actually learned, nor even attempted to learn,
  any &#8216;&#8216;formal set theory&#8217;&#8217;;
  what I do know of set theory is usually couched in the language of type theory;
  I heart </span><span class="org-quote"><span class="org-link"><a href="https://www.springer.com/gp/book/9780387941158">LAD</a><a href="https://www.springer.com/gp/book/9780387941158">M</a></span></span><span class="org-quote">!
)
</span><span class="org-block-end-line">#+END_QUOTE
</span>
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">instance</span></span><span class="org-block">
  </span><span class="org-block"><span class="haskell-type">&#119966;&#119990;&#120009;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {i j} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">Category</span></span><span class="org-block"> {&#8467;suc (i </span><span class="org-block"><span class="haskell-operator">&#8845;</span></span><span class="org-block"> j)} {&#8467;suc (i </span><span class="org-block"><span class="haskell-operator">&#8845;</span></span><span class="org-block"> j)}
  </span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block"> {i} {j} </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> record {
      </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {i} {j}
    ; </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block">
    ; </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">&#8496;</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">
        </span><span class="org-block"><span class="haskell-keyword">let</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">instance</span></span><span class="org-block">
                   </span><span class="org-block"><span class="haskell-type">&#119966;</span></span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">Category</span></span><span class="org-block"> ; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">
                   </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> ; </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">
                   </span><span class="org-block"><span class="haskell-constructor">&#8496;</span></span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> ; </span><span class="org-block"><span class="haskell-constructor">&#8496;</span></span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#8496;</span></span><span class="org-block">
        </span><span class="org-block"><span class="haskell-keyword">in</span></span><span class="org-block"> record
        { obj  </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block">  obj </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> obj </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">this compositon lives in &#119982;e&#120009;
</span></span><span class="org-block">        ; mor  </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block">  mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> mor </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">
        ; id   </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block">  &#955; {x} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> begin
              (mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> mor </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">) (</span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block"> &#10627; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> &#10628; {</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> x})
            </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216; </span><span class="org-block"><span class="string">"definition of function composition"</span></span><span class="org-block"> &#10217;</span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block">
              mor </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> (mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block">)
            </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216; functor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> preserves</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">identities even</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">under (mor </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">) &#10217;
              mor </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block">
            </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216; functor </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> preserves</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">identities &#10217;
              </span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block">
            </span><span class="org-block"><span class="haskell-operator">&#8718;</span></span><span class="org-block">
        ; comp </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; {x y z f g} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">
             begin
               (mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> mor </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">) (f </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> g)
            </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216; </span><span class="org-block"><span class="string">"definition of function composition"</span></span><span class="org-block"> &#10217;</span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block">
               mor </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> (mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> (f </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> g))
             </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216; functor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> preserves</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">composition even</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">under mor </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> &#10217;
               mor </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> (mor </span><span class="org-block"><span class="haskell-constructor"><span class="writegood-duplicates">F</span></span></span><span class="org-block"><span class="writegood-duplicates"> f</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> g)
             </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216; functor </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> preserves</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">composition &#10217;
               (mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> mor </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">) f </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> (mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> mor </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">) g
             </span><span class="org-block"><span class="haskell-operator">&#8718;</span></span><span class="org-block">
        }
    ; assoc    </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block">  &#955; {a b c d f g h} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> funcext </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl
    ; </span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block">       </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block">  record { obj </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block"> ; mor </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block"> ; id </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl ; comp </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl }
    ; leftId   </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block">  funcext </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl
    ; rightId  </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block">  funcext </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl
    }
</span><span class="org-block-end-line">#+END_SRC
</span>
<span class="writegood-weasels">Some</span> things to note,

+ First off: <span class="org-code">functor F preserves-composition even-under mor G</span> is a real line of code!
  It consists of actual function calls and is merely an alias for
  <span class="org-code">&#8801;-cong (mor G) (mor F)</span> but it sure is far more readable than this form!

+ We could have written <span class="org-code">id = &#8801;-cong (mor G) (id F) &#10216;&#8801;&#8801;&#10217; id G</span>,
  but this is not terribly clear what is going on.
  Especially since we introduced categories not too long ago,
  we choose to elaborate the detail.

  Likewise, <span class="org-code">comp = (&#8801;-cong (mor G) (comp F)) &#10216;&#8801;&#8801;&#10217; (comp G)</span>.

+ <span class="org-code">assoc</span> is trivial since function composition is, by definition, associative.
  Likewise <span class="org-code">leftId, rightId</span> hold since functional identity is, by definition, unit of function composition.

<span class="comment"># + The definition of composition immediately gives us that obj , mor distributes over composition:</span>
<span class="comment">#   \[ \eqn{&#119966;&#119990;&#120009; $\obj$ Distributivity}{\obj\, (F &#10814; G) \quad=\quad \obj\, F \;&#10814;\; \obj\, G}\]</span>
<span class="comment">#   \[ \eqn{&#119966;&#119990;&#120009; $\mor$ Distributivity}{\mor\, (F &#10814; G) \quad=\quad \mor\, F \;&#10814;\; \mor\, G}\]</span>
<span class="org-meta-line">#
** ~&#119970;&#120007;&#119990;&#120005;&#119997;~</span>
<span class="org-drawer">   :PROPERTIES:...
</span>In a nearly identical way, just ignoring the algebraic datum, we can show that
<span class="org-code">Graph</span>'s with <span class="org-code">GraphMap</span>'s form a graph
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">  &#119970;&#120007;&#119990;&#120005;&#119997; : Category
  &#119970;&#120007;&#119990;&#120005;&#119997; = {! exercise !}
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>
<span class="org-drawer">:Solution:...
</span>
<span class="org-hide">*</span><span class="org-level-2">* </span><span class="org-level-2"><span class="org-code">&#119966;&#119990;&#120009;</span></span><span class="org-level-2">'s are </span><span class="org-level-2"><span class="org-code">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-level-2">'s</span>
<span class="org-drawer">   :PROPERTIES:...
</span><span class="org-block-begin-line">#+BEGIN_CENTER
</span><span class="italic">Forgive and forget: The &#119984;nderlying functor.</span>
<span class="org-block-end-line">#+END_CENTER
</span>
Let&#8217;s formalise what we meant earlier when we said graphs are categories
but ignoring the algebraic data.

Given a category, we ignore the algebraic structure to obtain a graph,
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block">
 </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> record { </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> ; </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> Category._</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> }
</span><span class="org-block-end-line">#+END_SRC
</span>
Likewise, given a functor we &#8216;forget&#8217; the property that the map of morphisms needs to preserve all
finite compositions to obtain a graph map:
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">
 </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> record { ver </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> obj </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> ; edge </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> }
</span><span class="org-block-end-line">#+END_SRC
</span>This says that <span class="org-code">&#119984;&#8321;</span> turns <span class="org-code">ver, edge</span> into <span class="org-code">obj , mor</span>
--<span class="org-code">&#119984;&#8321; &#10814; ver  &#8801; obj</span> and <span class="org-code">&#119984;&#8321; &#10814; edge &#8801; mor</span>-- reassuring us that <span class="org-code">&#119984;&#8321;</span> acts
as a bridge between the graph structures: <span class="org-code">ver , edge</span> of graphs and
<span class="org-code">obj , mor</span> of categories.

Putting this together, we obtain a functor.
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Underlying/forgetful functor: Every category is a graph
</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block">
 </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> record { obj </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8320; ; mor </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; ; id </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl ; comp </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl }
</span><span class="org-block-end-line">#+END_SRC
</span>We forget about the extra algebraic structure of a category and of a functor to
arrive at a graph and graph-map, <span class="writegood-weasels">clearly</span> --<span class="org-code">&#8801;-refl</span>-- such &#8216;forgetfullness&#8217; preserves identities
and composition since it does not affect them at all!

Those familiar with category theory may exclaim that just as I have mentioned
the names &#8216;underlying functor&#8217; and &#8216;forgetful functor&#8217; I ought to mention
&#8216;stripping functor&#8217; as it is just as valid since it brings about connotations of
&#8216;stripping away&#8217; extra structure.
I&#8217;m assuming the latter is less popular due to its usage for
poor mathematical jokes and puns.

Before we move on, the curious might wonder if &#8216;&#8216;categories are graphs&#8217;&#8217;
then what is the analgoue to &#8216;<span class="org-latex-and-related">&#8216;$X$ </span>are hypergraphs&#8217;&#8217;,
it is <span class="org-link"><a href="http://arxiv.org/PS_cache/math/pdf/0305/0305049v1.pdf#page=178">multicategories</a></span>.

Now the remainder of these notes is to build-up the material
needed to realise the notion of &#8216;free&#8217; which is, in <span class="writegood-weasels">some</span> sense,
<span class="italic">the best-possible approximate inverse</span> to &#8216;forgetful&#8217;
--however, forgetting is <span class="writegood-weasels">clearly</span> not invertible since it can <span class="writegood-weasels">easily</span>
confuse two categories as the same graph!

<span class="org-level-1">* </span><span class="org-level-1"><span class="italic">How natural is naturality?</span></span>
<span class="org-drawer">:PROPERTIES:...
</span>
<span class="comment"># commutative diagrams with MathJax</span>
<span class="comment"># <a href="http://www.jmilne.org/not/Mamscd.pdf">http://www.jmilne.org/not/Mamscd.pdf</a></span>

<span class="org-hide">*</span><span class="org-level-2">* NatTrans Intro                                                    </span><span class="org-level-2"><span class="org-tag">:ignore:</span></span>
<span class="org-drawer">   :PROPERTIES:...
</span>Recall, that a natural transformation<span class="org-latex-and-related"> $&#951; : F \natTo G$ </span>is a family<span class="org-latex-and-related">
$&#8704; \{X \,:\, \Obj &#119966;\} \,&#8594;\, F\, X &#10230; G\, X$ </span>that satisfies the naturality condition:<span class="org-latex-and-related">
$&#8704; \{A \; B\} \{f \,:\, A &#10230; B\} \,&#8594;\, </span><span class="org-latex-and-related"><span class="writegood-duplicates">F f</span></span><span class="org-latex-and-related"> &#10814; &#951; {B} \;&#8801;\; &#951; {A} &#10814; G f$.</span>

  + In the type of &#951;, note that the first <span class="italic">show</span> arrow &#8216;&#8594;&#8217; acts as a separator from <span class="writegood-duplicates">the
    the</span> &#8704;-quantified variable<span class="org-latex-and-related"> $X$,</span> whereas the second <span class="italic">longer</span> arrow &#8216;&#10230;&#8217; denotes the
    morphism type in the category &#119966;.

  + We will freely interchange the informal mathematical rendition<span class="org-latex-and-related"> $(&#951;_x : F\, X &#8594; G\, X)_{x &#8712; \Obj &#119966;}$
</span>    with the aforementioned formal Agda forms <span class="org-code">&#8704;{X : Obj &#119966;} &#8594; F X &#8594; G &#8594; X</span> and invocation <span class="org-code">&#951; {X}</span>.

<span class="org-block-begin-line">#+BEGIN_CENTER
</span><span class="org-latex-and-related">$\require{AMScd}$
\begin{CD}
\color{navy}{F\, A} @&gt;\color{fuchsia}{&#951;_A}&gt;&gt;      \color{teal}{G\, A}    \\
@V\color{navy}{F\, f}VV    \!=                    @VV\color{teal}{G\, f}V \\
\color{navy}{F\, B} @&gt;&gt;\color{fuchsia}{&#951;_B}&gt;      \color{teal}{G\, B}
\end{CD}</span>
<span class="org-block-end-line">#+END_CENTER
</span>Let us look at this from a <span class="writegood-weasels">few</span> different
angles; in particular, <span class="org-link"><a href="http://mathoverflow.net/questions/56938/what-does-the-adjective-natural-actually-mean/56956">what does the adjective &#8216;natural&#8217; actually mean?</a></span>
It&#8217;s <span class="writegood-passive-voice">been discussed</span> on <span class="writegood-weasels">many</span> forums and we collect a <span class="writegood-weasels">few</span> of the key points here.

<span class="org-hide">*</span><span class="org-level-2">* Identification of possible paths ---contraction of choices</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
Given two functors<span class="org-latex-and-related"> $F , G$,</span> for any object<span class="org-latex-and-related"> $~x$ </span>we obtain two objects<span class="org-latex-and-related"> $F\, x\, , \, G\, x$ </span>and so a morphism
from<span class="org-latex-and-related"> $F$ </span>to<span class="org-latex-and-related"> $G$ </span>ought to map such<span class="org-latex-and-related"> $F\,x$ </span>to<span class="org-latex-and-related"> $G\, x$.</span> That is, a morphsim of functors is a family <span class="org-macro">{{{newline}}}</span><span class="org-latex-and-related">
$&#951; \,:\, &#8704; \{x : \Obj &#119966;\} \,&#8594;\, F \,x &#10230; G \,x$.</span> Now for any<span class="org-latex-and-related"> $f : a &#8594; b$ </span>there are two ways to form a morphism<span class="org-latex-and-related">
$F\, a &#8594; G\, b$: $F f &#10814; &#951; \{b\}$ </span>and<span class="org-latex-and-related"> $&#951; \{a\} &#10814; G\, f$.</span> Rather than make a choice each time we want such
a morphism, we eliminate the choice all together by insisting that they are identical.
This is the naturality condition.

This is similar to when we <span class="writegood-passive-voice">are given</span> three morphisms<span class="org-latex-and-related"> $f : a &#8594; b , g : b &#8594; c , h : c &#8594; d$,</span>
then there are two ways to form a morphism<span class="org-latex-and-related"> $a &#8594; d$;</span> namely<span class="org-latex-and-related"> $(f &#10814; g) &#10814; h$ </span>and<span class="org-latex-and-related"> $f &#10814; (g &#10814; h)$.</span>
Rather than make a choice each time we want such a morphism, we eliminate the choice all together
by insisting that they are identical. This is the associativity condition for categories.

Notice that if there&#8217;s no morphism<span class="org-latex-and-related"> $F\, x &#10230; G\, x$ </span>for <span class="writegood-weasels">some</span><span class="org-latex-and-related"> $x$,</span> they by definition there&#8217;s no
possible natural transformation<span class="org-latex-and-related"> $F \natTo G$.</span>

<span class="org-hide">*</span><span class="org-level-2">* No Choice --free will is only an illusion</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
<span class="org-latex-and-related">\begin{align*}
     &amp; \quad\text{the natural $X$}
\\ = &amp; \quad\text{the $X$ which requires no arbitrary choices}
\\ = &amp; \quad\text{the canonical/standard $X$}
\end{align*}</span>

That is,
<span class="org-latex-and-related">\begin{align*}
     &amp; \quad \text{it is a natural construction/choice}
\\ = &amp; \quad \text{distinct people would arrive at the same construction;}
\\   &amp; \quad \text{ (no arbitrary choice or cleverness needed) }
\\ = &amp; \quad \text{ there is actually no choice, i.e., only one possiility, }
\\   &amp; \quad \text{ and so two people </span><span class="org-latex-and-related"><span class="writegood-passive-voice">are expected</span></span><span class="org-latex-and-related"> to arrive at the same &#8216;choice&#8217;}
\end{align*}</span>

Thus, if a construction every involves having to decide between distinct routes, then chances are
the result is not formally natural.
Sometimes this &#8216;inution&#8217; <span class="writegood-passive-voice">is developed</span> from working in a field for <span class="writegood-weasels">some</span> time;
sometimes it just &#8220;feel&#8221;" natural.
<span class="comment"># "natural" = "resonable or expected in the ambient context" ;</span>

<span class="org-link"><span class="writegood-weasels"><a href="http://math.stackexchange.com/questions/939404/do-natural-transformations-make-god-given-precise?rq=1">Some</a></span></span><span class="org-link"><a href="http://math.stackexchange.com/questions/939404/do-natural-transformations-make-god-given-precise?rq=1"> would even say</a></span>: <span class="italic">Natural = God-given</span>.

<span class="org-hide">*</span><span class="org-level-2">* </span><span class="org-special-keyword">COMMENT</span><span class="org-level-2"> Common Properties                            </span><span class="org-level-2"><span class="org-tag">:this_looks_suspect:</span></span>
<span class="org-drawer">   :PROPERTIES:...
</span>"natural solution" = "has properties of all other solutions"

[To consider: is a natural solution then just an initial solution? That is, an intial
transformation?]

{\sc add this to todo&#8217;s list}

<span class="org-hide">*</span><span class="org-level-2">* Natural means polymorphic without type inspection</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
<span class="comment">#  nattrans are polyfuncs</span>

A natural transformation can <span class="writegood-passive-voice">be thought</span> of as a polymorphic function
<span class="org-code">&#8704; {X} &#8594; F X &#10230; G X</span> <span class="italic">where</span> we restrict ourselves to avoid inspecting any <span class="org-code">X</span>.

+ Recall that a <span class="org-code">mono</span>-morphic operation makes no use of type variables in its signature,
  whereas a <span class="org-code">poly</span>-morphic operation uses type variables in its signature.

+ For example, in C# one can ask if one type <span class="org-code">is</span> a subclass of another thereby
  obtaining specific information, whereas there is no such mechanism in Haskell.

Inspecting type parameters or not leads to the distinction of ad hoc plymorphism vs. parametric
polymorphism ---the later is the kind of polymorphism employed in functional language like Haskell
and friends and so such functions are natural transformations by default!
<span class="org-link"><a href="http://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf">Theorems for free!</a></span>

For example,
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">-- Let &#119974; x y &#8788; Id {x} for morphisms, and &#119974; x y &#8788; x for objects.

size : &#8704; {X} &#8594; List X &#8594; &#119974; &#8469; X
size [x&#8321;, &#8230;, x&#8345;] = n
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>is a polymorphic function and so naturality follows and is <span class="writegood-weasels">easily</span> shown --show it dear reader!
So we have always have
<span class="org-latex-and-related">\[List\; f \;&#10814;\; size \quad=\quad size\]</span>
Since <span class="org-code">&#119974; &#8469; f = Id</span>, then by extensionality: <span class="org-code">size : List &#10230;&#775; &#119974;</span>.
<span class="org-drawer">:Solution:...
</span>
On the other hand, the polymorphic function
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">whyme : &#8704; {X} &#8594; List X &#8594; &#119974; Int X
whyme {X} [x&#8321;,&#8230;,x&#8345;] = If X = &#8469; then 1729 else n
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>is not natural: The needed equation <span class="org-code"><span class="writegood-duplicates">F f</span></span><span class="org-code"> &#10814; &#951; {B} = &#951; {A} &#10814; G f</span>
for any <span class="org-code">f : A &#8594; B</span> breaks as witnessed by
<span class="org-code">f = (&#955; x &#8594; 0) : &#8477; &#8594; &#8469;</span> and any list with length <span class="org-code">n &#8800; 1729</span>,
and this is <span class="writegood-weasels">easily</span> shown --do so!
<span class="org-drawer">:Solution:...
</span>
One might exclaim, <span class="italic">hey! this only works &#8217;cuz you&#8217;re using Ramanujan&#8217;s taxi-cab number!</span>
<span class="italic">1729 is the smallest number expressible as a sum of 2 cubes in 2 ways:</span>
<span class="italic"><span class="org-latex-and-related">$1729 = 12&#179; + 1&#179; = 10&#179; + 9 &#179;$.</span></span> I assure you that this is not the reason that naturality breaks,
and I commend you on your keen observation.

Notice that it is natural if we exclude the type inspected, &#8469;.
That is, if we only consider<span class="org-latex-and-related"> $f : A &#8594; B$ </span>with<span class="org-latex-and-related"> $A &#8800; &#8469; &#8800; B$.</span>
In general, is it the case that a transformation can <span class="writegood-passive-voice">be made</span> natural by excluding
the types that <span class="writegood-passive-voice">were inspected</span>?

Before we move on, observe that a solution in<span class="org-latex-and-related"> $h$ </span>to the absorptive-equation<span class="org-latex-and-related"> $F f &#10814; h = h$
</span>is precisely a natural transformation from<span class="org-latex-and-related"> $F$ </span>to the aforementioned &#8216;diagonal functor&#8217;:
<span class="org-latex-and-related">\[</span><span class="org-latex-and-related"><span class="writegood-duplicates">F f</span></span><span class="org-latex-and-related"> &#10814; h \;=\; h \qquad&#8660;\qquad &#8707; X : Obj \;&#8226;\; h &#8712; F \overset{.}{&#10230;} &#119974; X ~\]</span>
<span class="org-meta-line">#
# Recall that &#8594;&#775; is a &#931;-type for which membership </span><span class="org-meta-line"><span class="writegood-passive-voice">is defined</span></span><span class="org-meta-line"> as follows:</span>
<span class="org-meta-line">#
# ~(x &#8712; &#931; y &#8758; Y &#8226; P y) =  (&#931; y &#8758; Y &#8226; y &#8801; x &#8743; P y)~.</span>
<span class="org-meta-line">#
# {\sc add to todo&#8217;s: formalise ~&#8712;~; trickier than it looks ;) }</span>

<span class="comment"># since g &#10814; (&#955; _ &#8594; e) = (&#955; x &#8594; (&#955; _ &#8594; e) (g x) ) = (&#955; x &#8594; e)</span>
In particular, due to the constant-fusion property<span class="org-latex-and-related"> $g \,&#10814;\, &#119974;\, e \;=\; &#119974;\, e$,</span> we have that
<span class="org-latex-and-related">\[&#8704; \{F\} \{X\} \{e \,:\, X\} \;&#8594;\; (&#119974;\, e) \,&#8712;\, F \overset{.}{&#10230;} &#119974;\, X \]</span>
Is the converse also true? If<span class="org-latex-and-related"> $h &#8712; F &#10230;&#775; &#119974; X$ </span>then<span class="org-latex-and-related"> $h \,=\, &#119974;\, e$ </span>for <span class="writegood-weasels">some</span><span class="org-latex-and-related"> $e$?</span>

<span class="org-hide">*</span><span class="org-level-2">* </span><span class="org-special-keyword">COMMENT</span><span class="org-level-2"> monomorphic funcs are natural                  </span><span class="org-level-2"><span class="org-tag">:possibly_harmful:</span></span>
<span class="org-drawer">   :PROPERTIES:...
</span>
Notice <span class="writegood-duplicates">that that</span> monomorphic functions are always natural!

Given <span class="org-code">m : X &#8594; Y</span> we can consture this as <span class="org-code">m : &#8704; {Z} &#8594; &#119974; X Z &#8594; &#119974; Y Z</span> and then we obtain
naturality: given <span class="org-code">f : A &#8594; B</span>,
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">  m &#10814; &#119974; X f
= m &#10814; Id
= m
= Id &#10814; m
= &#119974; Y f &#10814; m
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>
this is <span class="writegood-weasels">probably</span> less insightful, and <span class="writegood-weasels">probably</span> a damaging observation...

<span class="org-hide">*</span><span class="org-level-2">* Natural means no reference to types</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
The idea that a natural transformation cannot make reference to the type variable at all can <span class="writegood-passive-voice">be
seen</span> by yet another example.

<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">  data &#120793; : Set where &#9733; : &#120793;

  -- Choice function: For any type X, it yields an argument of that type.
  postulate &#949; : (X : Set) &#8594; X

  nay : &#8704; {X} &#8594; X &#8594; X
  nay {X} _ = &#949; X
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>
Now naturality<span class="org-latex-and-related"> $\Id \, f &#10814; nay_B \;=\; nay_A &#10814; \Id \, f$ </span>breaks as witnessed by<span class="org-latex-and-related">
$f \;=\; (&#955; _ &#8594; &#949;&#8469; + 1) \;:\; &#120793; &#8594; &#8469;$ </span>--and provided<span class="org-latex-and-related"> $&#949;&#8469; &#8800; 0$,</span> otherwise
we could use an<span class="org-latex-and-related"> $f$ </span>with no fix points.

<span class="org-drawer">:Solution:...
</span>
From this we may hazard the following:
If we have natural transformations<span class="org-latex-and-related"> $&#951;&#7522; \,:\, &#8704; {X : Obj&#7522;} &#8594;\, F X \overset{.}{&#10230;} G X$
</span>where the<span class="org-latex-and-related"> $Obj&#7522;$ </span>partition the objects available --- i.e.,<span class="org-latex-and-related"> $Obj \;=\; &#931; i \,&#8226;\, Obj&#7522;$ </span>---
then the transformation<span class="org-latex-and-related"> $&#951;_{(i, X)} \;=\; &#951;&#7522;$ </span>is generally unnatural since it <span class="writegood-weasels">clearly</span> makes choices,
for each partition.

<span class="org-hide">*</span><span class="org-level-2">* Natural means uniformly and simultaneously defined</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
A family of morphisms is <span class="italic">natural in x</span> precisely when it <span class="writegood-passive-voice">is defined</span>
<span class="italic">simultaneously</span> for all <span class="italic">x</span> ---there is no inspection of <span class="writegood-weasels">some</span> particular <span class="italic">x</span> here and there,
no, it is uniform! With this view, the naturality condition <span class="writegood-passive-voice">is thought</span> of as a &#8216;simultaneity&#8217;
condition. <span class="org-link"><a href="https://www.google.ca/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8&amp;client=ubuntu#q=general%20theory%20of%20natural%20equivalences">Rephrasing GToNE</a></span>.

The idea of naturality as uniformly-definable <span class="writegood-passive-voice">is pursued</span> by <span class="org-link"><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.107.2336&amp;rep=rep1&amp;type=pdf">Hodges and Shelah</a></span>.

<span class="org-hide">*</span><span class="org-level-2">* Naturality is restructure-modify commutativity</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
Recall that a functor can <span class="writegood-passive-voice">be thought</span> of as endowing an object with structure.
Then a transformation can <span class="writegood-passive-voice">be thought</span> of as a restructuring operation and naturality means
that it doesn&#8217;t matter whether we restructure or modify first, as long as we do both.

<span class="org-hide">*</span><span class="org-level-2">* Natural means obvious</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
It may help to think of <span class="italic">there&#8217;s a natural transformation from F to G</span> to mean
<span class="italic">there&#8217;s an obvious/standard/canconical way to transform F structure into G structure</span>.

Likewise, <span class="italic">F is naturally isomorphic to G</span> may <span class="writegood-passive-voice">be read</span> <span class="italic">F is obviously isomorphic to G</span>.
For example, <span class="bold">TODO</span> seq-pair or pair-seq ;-)

Sometimes we can show &#8216;&#8216;F X is isomorphic to G X, if we make a choice dependent on X&#8217;&#8217;
and so the isomorphism is not obvious, since a choice must <span class="writegood-passive-voice">be made</span>.

<span class="org-hide">*</span><span class="org-level-2">* Naturality is promotion</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
+ I think Richard Bird refers to the naturality condition as a promotion law where the functors
  involved <span class="writegood-passive-voice">are thought</span> of as (list) constructions.

+ The nomenclature <span class="writegood-passive-voice">is used</span> <span class="org-link"><a href="https://www.cs.ox.ac.uk/files/3378/PRG56.pdf">to express the idea than operation on a compound structure
  can be &#8216;promoted&#8217; into its components.</a></span>
<span class="comment">   # <a href="http://www.cs.ox.ac.uk/files/3390/PRG69.pdf">http://www.cs.ox.ac.uk/files/3390/PRG69.pdf</a>, orginal source, is a dead link.</span>

+ Reading <span class="org-code"><span class="writegood-duplicates">F f</span></span><span class="org-code"> &#10814; &#951; {B} = &#951; {A} &#10814; G f</span> from left to right:
   Mapping<span class="org-latex-and-related"> $f$ </span>over a complicated structure then handling the result
   <span class="italic">is the same as</span>
   handling the complex datum then mapping<span class="org-latex-and-related"> $f$ </span>over the result.

   - `Handling' can <span class="writegood-passive-voice">be thought</span> of as `processing' or as `reshaping'.

Lists give <span class="writegood-weasels">many</span> examples of natural transformations by considering
<span class="org-link"><a href="https://link.springer.com/chapter/10.1007/3-540-51305-1_24">a categorical approach to the theory of lists.</a></span>

<span class="org-hide">*</span><span class="org-level-2">* Naturality as a rewrite rule</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
The naturality condition can <span class="writegood-passive-voice">be seen</span> as a rewrite rule that let&#8217;s us replace a complicated or
inefficient side with a simplier or more efficient yet equivalent expression.
I think I first learned this view of equations at the insistence of
<span class="org-link"><a href="https://www.amazon.com/Algebra-Programming-Prentice-hall-International-Computer/dp/013507245X">Richard Bird and Oege de Moor</a></span>
--whose text can <span class="writegood-passive-voice">be found</span> <span class="org-link"><a href="http://themattchan.com/docs/algprog.pdf">here</a></span>, albeit the legitimacy of the link may be suspect.

For example, recall the &#119974;onstant functor now construed only as a polymorphic binary operation:
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">_&#10218;_    :  &#8704;{A B : Set} &#8594; A &#8594; B &#8594; </span><span class="custom"><span class="writegood-duplicates">A
a</span></span><span class="custom"> &#10218; b  =  a
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>
The above is a constant time operation, whereas the next two are linear time operations; i.e.,
they take <span class="org-code">n</span> steps to compute, where <span class="org-code">n</span> is the length of the given list.

<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">-- This' map for List's; i.e., the mor of the List functor
map    : &#8704; {A B : Set} (f : A &#8594; B) &#8594; List A &#8594; List B
map f []         =  []
map f (x &#8759; xs)  =  f x &#8759; map f xs

-- Interpret syntax `x&#8320;&#8759;&#8943;&#8759;x&#8345;&#8331;&#8321;` semantically as `x&#8320; &#8853; &#8943; &#8853; x&#8345;&#8331;&#8321;`, where &#8853; = cons.
fold  : &#8704; {A B : Set} (cons : A &#8594; B &#8594; B) (nil : B) &#8594; List A &#8594; B
fold cons nil [] = nil
fold cons nil (x &#8759; xs) = cons x (fold cons nil xs)
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>
By <span class="italic">Theorems for Free</span>, or a <span class="writegood-weasels">simple</span> proof, we have that <span class="org-code">fold</span> is a natural
transformation<span class="org-latex-and-related"> $List \overset{.}{&#8594;} \Id$:</span>
<span class="org-latex-and-related">\[ List\; f \;&#10814;\; fold \; cons_B \; nil_B \qquad=\qquad fold \; cons_A \; nil_A \;&#10814;\; f \]</span>
Note that here we are ranging over objects<span class="org-latex-and-related"> $X$ </span>equipped with<span class="org-latex-and-related"> $nil_X : X, \; cons_X : X &#8594; X &#8594; X$;</span>
as such the equation is not valid when this is not the case.

Now we map compute,
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">postulate A B : Set
postulate nil-B : B
postulate f : A &#8594; B -- possibly expensive operation

head  :  List B &#8594; B
head  =  fold _&#10218;_ nil-B

compute  :  List A &#8594; B
compute  =  map f  &#10814;  head
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>
That is,
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">  compute [x&#8320;, &#8230;, x&#8345;&#8331;&#8321;]
= head (map f [x&#8320;, &#8230;, x&#8345;&#8331;&#8321;])
= head [f x&#8320;, &#8230;, f x&#8345;&#8331;&#8321;]
= f x&#8320;  &#10218;  f x&#8321; &#10218; &#8943; &#10218; &#8943; f x&#8345;&#8331;&#8321; &#10218; nil-B
= f x&#8320;
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>
However this approach performs the potentially expensive operation<span class="org-latex-and-related"> $f$ </span>a total of<span class="org-latex-and-related">
$n = \text{&#8220;length of input&#8221;}$ </span>times! In spite of that, it only needs the first element of
the list and performs the operation only once! Indeed, by the naturality of <span class="org-code">fold</span> we have
an equivalent, and more efficient, formulation:
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">compute  =  head  &#10814;  f
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>
This operation only performs the potentially costly <span class="org-code">f</span> once!

A more concrete and realistic example is to produce an efficient version of the function
that produces the <span class="org-code">average xs = div (sum xs, length xs)</span> of a list of numbers: This operation
traverses the input list twice, yet we can keep track of the length as we sum-along the list
to obtain an implementation that traverses the list only once!

<span class="org-link"><a href="https://scss.tcd.ie/publications/tech-reports/reports.99/TCD-CS-1999-74.pdf">Indeed</a></span>,
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">div : &#8469; &#215; &#8469; &#8594; &#8469;
div (0, 0) = 0
div (m, n) = m &#247; n

average     :  List &#8469; &#8594; &#8469;
average xs  =  div (fold _&#8853;_ &#120792; xs)
  where  &#120792; = (0 , 0)
         _&#8853;_  : &#8469; &#8594; (&#8469; &#215; &#8469;) &#8594; &#8469;
         a &#8853; (b , n) = (a + b , n + 1)
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>
<span class="org-hide">*</span><span class="org-level-2">* Naturality is just model morphism</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
Given two functors<span class="org-latex-and-related"> $F , G : &#119966; &#10230; &#119967;$ </span>let us construe them as only graph homomorphisms.
Then each is a model of the graph<span class="org-latex-and-related"> $&#119984;&#8320; \; &#119966;$ </span>---each intereprets the nodes and edges of <span class="org-code">&#119984;&#8320; &#119966;</span> as
actual objects and morphisms of &#119967;--- and a natrual transformation is then nothing
more than a morphism of models.

<span class="comment"># {\sc was the notion of model morphisms mentioned earlier when</span>
<span class="comment"># models </span><span class="comment"><span class="writegood-passive-voice">were introduced</span></span><span class="comment">?}</span>

<span class="org-hide">*</span><span class="org-level-2">* Naturality yields pattern matching</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
In the setting of types and functions, <span class="org-code">&#951; : F &#10230;&#775; G</span> means we have <span class="org-code">&#951; (</span><span class="org-code"><span class="writegood-duplicates">F f</span></span><span class="org-code"> x) = G f (&#951; x)</span>
which when read left-to-right says that <span class="org-code">&#951;</span> <span class="writegood-passive-voice">is defined</span> by pattern-matching on its argument
to obtain something of the form <span class="org-code"><span class="writegood-duplicates">F f</span></span><span class="org-code"> x</span> then it <span class="writegood-passive-voice">is defined</span> recursively by examining <span class="org-code">x</span> and then
applying <span class="org-code">G f</span> to the result ---of course there&#8217;s <span class="writegood-weasels">some</span> base case <span class="org-code">F</span> definitions as well.

Alternatively, the input to <span class="org-code">&#951;</span> is of the form <span class="org-code">F &#8230;</span> and its
output is of the form <span class="org-code">G &#8230;</span> --mind blown!

<span class="comment"># Hence, in a pointwise setting, to define a natural transformation &#951;</span>
<span class="comment"># we need to define it at components of the input shape $&#951;_{F \, f \, x}$</span><span class="org-latex-and-related">
</span><span class="comment"># to have the output shape $G \, f \, &#951;_{x}$.</span>

For example, I want to define a transformation<span class="org-latex-and-related"> $\mathsf{List} &#10230;&#775; \mathsf{List}$.</span>
0. So let me suppose the input is of the shape<span class="org-latex-and-related"> $\List \, f\, x$,</span> more concretely
   it is of the shape
   <span class="org-macro">{{{newline}}}</span> <span class="org-code">[f x&#8320;, f x&#8321;, &#8230;, f x&#8345;&#8331;&#8321;]</span> --for arbitrary<span class="org-latex-and-related"> $f : A &#8594; B$.</span>
1. Then the output shape must be<span class="org-latex-and-related"> $\List \, f\, (&#951; \, x)$,</span> more concretely
   it is of the shape <span class="org-macro">{{{newline}}}</span> <span class="org-code">[f y&#8320;, f y&#8321;, &#8230;, f y&#8344;&#8331;&#8321;]</span> where<span class="org-latex-and-related"> $y \,=\, &#951;\,x$.</span>
2. So my <span class="italic">only</span> choices are<span class="org-latex-and-related"> $y : \List A$ </span>and<span class="org-latex-and-related"> $m : &#8469;$
</span>
   Here are <span class="writegood-weasels">some</span> possibilities and the resulting &#951;:
   +<span class="org-latex-and-related"> </span><span class="org-list-dt"><span class="org-latex-and-related">$y, m = x, n$ </span></span><span class="org-list-dt">::</span> Identity function
   +<span class="org-latex-and-related"> </span><span class="org-list-dt"><span class="org-latex-and-related">$y, m = x, 0$ </span></span><span class="org-list-dt">::</span> Constantly empty list <span class="org-code">[]</span> function
   +<span class="org-latex-and-related"> </span><span class="org-list-dt"><span class="org-latex-and-related">$y, m = x, 1$ </span></span><span class="org-list-dt">::</span> The first element, &#8216;head&#8217;, function
   +<span class="org-latex-and-related"> </span><span class="org-list-dt"><span class="org-latex-and-related">$y, m = x, k$ </span></span><span class="org-list-dt">::</span> The first<span class="org-latex-and-related"> $k &lt; n$ </span>elements function
   +<span class="org-latex-and-related"> </span><span class="org-list-dt"><span class="org-latex-and-related">$m = n$ </span></span><span class="org-list-dt">with</span><span class="org-list-dt"><span class="org-latex-and-related"> $y&#7522; = x&#8345;&#8331;&#7522;$ </span></span><span class="org-list-dt">::</span> List reversal function
   +<span class="org-latex-and-related"> </span><span class="org-list-dt"><span class="org-latex-and-related">$y, m = \mathsf{reverse}(x), k$ </span></span><span class="org-list-dt">::</span> The last<span class="org-latex-and-related"> $k &lt; n$ </span>elements, in reverse, function
        - Here we applied an already known natural transformation
          and indeed the composition of naturally transformation is itself natural.

<span class="org-hide">*</span><span class="org-level-2">* Examples</span>
<span class="org-drawer">  :PROPERTIES:...
</span>+ <span class="org-list-dt">Pointwise Monotonicity ::</span>

   A functor among poset categories is an order-preserving function and a natural transformation
  <span class="org-latex-and-related"> $f \natTo g$ </span>is a proof that<span class="org-latex-and-related"> $f \overset{.}{&#8804;} g$ </span>pointwise:<span class="org-latex-and-related"> $&#8704; x \,&#8226;\, f\, x \;&#8804;\; g\, x$
</span>   ---all the other pieces for a natural
   transformation are automatic from the definition of begin a poset category.

+ <span class="org-list-dt">conjugation ::</span>

  A functor among monoids --construed as categories-- is just a monoid homomorphism:
<span class="org-latex-and-related">  \begin{align*}
             &amp; (M, &#8853;, e) &#10230; (N, &#8855;, d)
  </span><span class="org-macro"><span class="org-latex-and-related">{{{newline}}}</span></span><span class="org-latex-and-related"> &#8773; \quad &amp; &#931; h &#8758; M &#8594; N &#8226; &#8704; \{x \, y \} &#8226;\; h(x &#8853; y) = h x &#8855; h y \lands h e = d
  \end{align*}</span>
  A natural transformation <span class="org-code">(f, prf) &#10230; (g, prf&#8217;)</span> is a point<span class="org-latex-and-related"> $n : N$ </span>with
 <span class="org-latex-and-related"> $&#8704; x &#8758; M \;&#8226;\; f x &#8855; n \,=\, n &#8855; g x$,</span> a so-called &#8216;conjugation&#8217; by<span class="org-latex-and-related"> $n$ </span>that takes<span class="org-latex-and-related"> $f$ </span>to<span class="org-latex-and-related"> $g$.</span>
<span class="org-drawer">  :Solution:...
</span>
+ <span class="org-list-dt">fold ::</span>

    Recall from the introduction<span class="org-latex-and-related"> $&#119984;(S, &#8853;, e) \;=\; S$ </span>was the underlying functor from monoids to sets.

    Let<span class="org-latex-and-related"> $&#119984; &#215; &#119984;$ </span>be the functor that for objects<span class="org-latex-and-related"> $M \;&#8614;\; &#119984;\, M \,&#215;\, &#119984;\, M$ </span>and for morphisms
   <span class="org-latex-and-related"> $h \;&#8614;\; &#955; (x,y) &#8594; (h\, x, h\, y)$.</span> Then the monoid multiplication (of each monoid) is a natural
    transformation<span class="org-latex-and-related"> $&#119984; &#215; &#119984; \natTo &#119984;$,</span> where naturality says that for any monoid homomorphism<span class="org-latex-and-related"> $h$,</span> the
    application of<span class="org-latex-and-related"> $&#119984;\, h$ </span>to the (monoid) multiplication of two elements is the same as the
    (monoid) multiplication of the<span class="org-latex-and-related"> $&#119984;\, h$ </span>images of the two elements,
    and this is evident from the homomorphism condition.

    Extending to finite products,<span class="org-latex-and-related"> $&#8466; \;&#8788;\; (&#931; n &#8758; &#8469; &#8226; &#8719; i &#8758; 1..n &#8226; &#119984;)$,</span> the natural transformation
   <span class="org-latex-and-related"> $&#8466; \natTo &#119984;$ </span>is usually called <span class="italic">fold, reduce, or cata</span> and <span class="org-code">&#8466;</span> <span class="writegood-passive-voice">is known</span> as the
    <span class="italic">free monoid functor</span> with notations<span class="org-latex-and-related"> $A* \;=\; \List A \;=\; &#8466;\, A$.</span>

    Loosely put,
<span class="org-block-begin-line">    #+BEGIN_EXAMPLE
</span><span class="custom">    &#8466;&#8320;    :  Monoid &#8594; Set
    &#8466;&#8320; M  =  &#931; n &#8758; &#8469; &#8226; &#8719; i : 1..n &#8226; &#119984; M   -- finite sequences of elements from M

    &#8466;&#8321; : &#8704; {M N : Monoid} &#8594; (M &#10230; N) &#8594; &#8466;&#8320; M &#8594; &#8466;&#8320; N
    &#8466;&#8321; (h , prf) = &#955; (n , x&#8321;, &#8230;, x&#8345;) &#8594; (n , h x&#8321; , &#8230; , h x&#8345;)

    fold : &#8704; {M : Monoid} &#8594; &#8466;&#8320; M &#8594; &#119984;&#8320; M
    fold {(M, &#8853;, e)} = &#955; (n , x&#8321;, &#8230;, x&#8345;) &#8594; x&#8321; &#8853; &#8943; &#8853; x&#8345;
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>
    --The reader would pause to consider implementing this formally using Agda's <span class="org-code">Data.Fin</span> and <span class="org-code">Data.Vec</span> ;-)--

    Now for any monoid homomorphism <span class="org-code">h</span>, applying induction, yields
<span class="org-block-begin-line">    #+BEGIN_EXAMPLE
</span><span class="custom">    h&#8320;(x&#8321; &#8853; &#8943; &#8853; x&#8345;)  =  h&#8320; x&#8321; &#8853; &#8943; &#8853; h&#8320; x&#8345;  where  h&#8320; = &#119984; (h&#8320;, prf) = &#119984; h
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>    Which is <span class="writegood-weasels">easily</span> seen to be just naturality -- if we use backwards composition<span class="org-latex-and-related"> $f &#10814; g \;=\; g &#8728; f$ </span>--
<span class="org-block-begin-line">    #+BEGIN_EXAMPLE
</span><span class="custom">    &#119984; h &#8728; fold {M}  =  fold {N} &#8728; &#8466; h
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>    Woah!

+ <span class="org-list-dt">Every operation in any multisorted algebraic structure gives a natural transformation ::</span>

   This <span class="writegood-passive-voice">is mentioned</span> in the <span class="org-link"><a href="http://www.math.mcgill.ca/triples/Barr-Wells-ctcs.pdf">Barr and Wells' </a></span><span class="org-link"><span class="italic"><a href="http://www.math.mcgill.ca/triples/Barr-Wells-ctcs.pdf">Category Theory for Computing Science</a></span></span><span class="org-link"><a href="http://www.math.mcgill.ca/triples/Barr-Wells-ctcs.pdf"> text</a></span>, citing
   Linton, 1969a-b.

   For example, <span class="org-code">src, tgt</span> ---from the graph signature--- give natural transformations
  <span class="org-latex-and-related"> $V \natTo E$ </span>from the vertex functor to the edge functor ... keep reading ;)

+ <span class="org-list-dt">Representability ::</span>

   Recall that<span class="org-latex-and-related"> $V(G)$ </span>is essentially<span class="org-latex-and-related"> $&#8473;&#8320; &#10230; G$ </span>where
  <span class="org-latex-and-related"> $&#8473;&#8345;$ </span>is the graph of<span class="org-latex-and-related"> $n$ </span>edges on<span class="org-latex-and-related"> $n+1$ </span>vertices named<span class="org-latex-and-related"> $0..n$ </span>with typing<span class="org-latex-and-related"> $i \,:\, i-1 &#10230; i$,</span>
   which I like to call <span class="italic">the path graph of length n</span>; and in particular<span class="org-latex-and-related"> $&#8473;&#8320;$ </span>is the graph of
   just one dot, called 0, and no edges. ---Earlier I used the notation <span class="org-code">[n]</span>, but I&#8217;m using<span class="org-latex-and-related"> $&#8473;$ </span>since
   I like the view point of &#8473;aths.

   What does it mean to say that <span class="italic">V(G) is essentially &#8473;&#8320; &#10230; G</span>?

   It means that the vertices functor
   --<span class="org-latex-and-related"> $&#119985; \;:\; &#119970;&#120007;&#119990;&#120005;&#119997; &#10230; &#119982;&#8495;&#120009;$ </span>that takes objects<span class="org-latex-and-related"> $G &#8614; V(G)$ </span>and morphisms<span class="org-latex-and-related"> $h &#8614; \mathsf{ver}\, h$ </span>--
   can be &#8216;represented&#8217; as the Hom functor<span class="org-latex-and-related"> $(&#8473;&#8320; &#10230; \_{})$,</span> that is to say
   <span class="org-latex-and-related">\[&#119985; \quad&#8773;\quad (&#8473;&#8320; &#10230; \_{}) \;\mathsf{within \; Func} \; &#119970;&#120007;&#119990;&#120005;&#119997; \; &#119982;&#8495;&#120009;\]</span>
   --<span class="org-code">Func</span>-tor categories will <span class="writegood-passive-voice">be defined</span> in the next section!--

   Notice that we arrived at this expression by
   &#8216;eta-reducing&#8217; the phrase <span class="italic">V(G) is essentially &#8473;&#8320; &#10230; G</span>! ;)

   More generally, we have the functor<span class="org-latex-and-related"> $&#8473;&#8345; &#10230; \_{}$ </span>which yields all paths of length<span class="org-latex-and-related"> $n$
</span>   for a given graph.

   Observe --i.e., show-- that we also have an edges functor.
<span class="org-drawer">   :Solution:...
</span><span class="org-level-1">* </span><span class="org-level-1"><span class="italic">Functor Categories</span></span>
<span class="org-drawer">:PROPERTIES:...
</span>
<span class="org-hide">*</span><span class="org-level-2">* FuncCats Intro                                                    </span><span class="org-level-2"><span class="org-tag">:ignore:</span></span>
<span class="org-drawer">   :PROPERTIES:...
</span>With a notion of morphisms between functors, one <span class="writegood-passive-voice">is led</span> inexorably to ask
whether functors as objects and natural transformations as morphisms constitute
a category?
They do!
However, we leave their definition to the reader ---as usual, if the reader is ever so desperate
for solutions, they can <span class="writegood-passive-voice">be found</span> as comments in the unruliness that is the source file.
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom"> instance
  Func       :  &#8704; {i j i&#8217; j&#8217;} (&#119966; : Category {i} {j}) (&#119967; : Category {i&#8217;} {j&#8217;}) &#8594; Category _
  Func &#119966; &#119967;  =  {! exercise !}
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>
+ A hint: The identity natural transformation is the obvious way to get from<span class="org-latex-and-related"> $F\, X$ </span>to<span class="org-latex-and-related"> $F\, X$,</span>
  for any<span class="org-latex-and-related"> $X$ </span>given<span class="org-latex-and-related"> $F$ </span>---well the only way to do so, without assuming anything else about the
  functor<span class="org-latex-and-related"> $F$,</span> is <span class="writegood-weasels">simply</span><span class="org-latex-and-related"> $\Id_{F X}$.</span> This is the &#8216;natural&#8217; choice, any other choice would be
  &#8216;unnatural&#8217; as it would require <span class="writegood-weasels">some</span> &#8216;cleverness&#8217;.

+ Another hint: The obvious way to define<span class="org-latex-and-related"> $&#951; &#10814; &#947;$ </span>to get<span class="org-latex-and-related"> $F\, X &#10230; H\, X$ </span>from
 <span class="org-latex-and-related"> $F\, X &#10230; G\, X &#10230; H\, X$ </span>is composition of morphisms in the category!
  That is, pointwise composition. Nothing &#8216;clever&#8217;, just using the obvious candidates!

<span class="org-drawer">:Solution:...
</span>
This is a good exercise as it will show you that there is an identity functor and that composition of functors
is again a functor. Consequently, functors are in abundance: Given any two, we can form [possibly] new ones by composition.

<span class="comment"># <a href="https://math.stackexchange.com/questions/627676/equivalence-of-categories-and-of-their-functor-categories">https://math.stackexchange.com/questions/627676/equivalence-of-categories-and-of-their-functor-categories</a></span>

It is a common construction that when a type<span class="org-latex-and-related"> $Y$ </span><span class="writegood-passive-voice">is endowed</span> with <span class="writegood-weasels">some</span> structure, then we can endow
the function space<span class="org-latex-and-related"> $X &#8594; Y$,</span> where<span class="org-latex-and-related"> $X$ </span>is any type, with the same structure and we do so
&#8216;pointwise&#8217;. This idea <span class="writegood-passive-voice">is formalised</span> by functor categories.
Alternatively, one can say we have &#8216;categorified&#8217; the idea; where
<span class="italic">categorification</span> is the process of replacing types and functions with categories and
functors and possibly adding <span class="writegood-weasels">some</span> coherence laws.

There are people who like to make a show about how &#8216;big&#8217; &#119966;&#119990;&#120009; or <span class="org-code">Func &#119966; &#120019;</span> are;
these people adhere to something called &#8216;set theory&#8217; which is essentialy type theory but
ignoring types, loosely put they work only with the datatype
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">data SET : Set where
  Elem : &#8704; {A : Set} &#8594; A &#8594; SET
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>Such heathens delegate types-of-types into &#8216;classes&#8217; of &#8216;small&#8217; and &#8216;big&#8217; sets and it&#8217;s not
uniform enough for me.
Anyhow, such people would say that functor categories &#8216;&#8216;cannot <span class="writegood-passive-voice">be constructed</span> (as sets)&#8217;&#8217; unless
one of the categories involved is &#8216;&#8216;small&#8217;&#8217;. Such shenanigans <span class="writegood-passive-voice">is ignored</span> due to the hierarchy of
types we are using :-)

We must admit that at times the usage of a single type, a &#8216;uni-typed theory&#8217; if you will can <span class="writegood-passive-voice">be
used</span> when one wants to relise types in an extrinsic fashion rather than think of data as
intrinsically typed --E.g., graphs with <span class="org-code">src, tgt</span> <span class="italic">then</span> deriving a notion of &#8216;type&#8217; with <span class="org-code">_&#10230;_</span>.
Everything has its place ... nonetheless, I prefer (multi)typed settings!

<span class="org-hide">*</span><span class="org-level-2">* Examples</span>
<span class="org-drawer">  :PROPERTIES:...
</span>
<span class="org-hide">**</span><span class="org-level-3">* All Categories are Functor Categories</span>
<span class="org-drawer">    :PROPERTIES:...
</span>Let <span class="org-code">&#120793; &#8788; [ &#8226; ]</span> be the discrete category of one object (and only the identity arrow on it).

Then <span class="org-code">&#119966; &#8773; Func &#120793; &#119966;</span>.

<span class="org-hide">**</span><span class="org-level-3">* Powers of Categories are Functor Categories</span>
<span class="org-drawer">    :PROPERTIES:...
</span>Let <span class="org-code">&#120794;&#8320; &#8788; [&#8226; &#8226;]</span> be the discrete category of two objects.
  Then the <span class="italic">&#119966;-squared</span> category can <span class="writegood-passive-voice">be defined</span> <span class="org-code">&#119966; &#8855; &#119966; &#8758;&#8773; Func &#120794;&#8320; &#119966;</span>:
  This category essentially consists of pairs of &#119966;-objects with pairs of &#119966;-arrows
  between them.

  The subscript 0 is commonly used for matters associated with objects and
  the name <span class="org-code">&#120794;&#8320;</span> is suggestive of the category of 2 objects only.

  More generally, if &#119977; is the discrete category of<span class="org-latex-and-related"> $n$ </span>objects, then
  the <span class="italic">n</span>-fold product category <span class="writegood-passive-voice">is defined</span> by
  <span class="org-code">(&#8719; i &#8758; 1..n &#8226; &#119966;) &#8758;&#8773; Func &#119977; &#119966;</span>.

These are also commonly denoted<span class="org-latex-and-related"> $&#119966;^2$ </span>and<span class="org-latex-and-related"> $&#119966;^&#119977;$ </span>since they are essentially
products, and more generally <span class="org-code">Func &#119987; &#119988;</span> is also denoted &#119988;^&#119987; and referred.

<span class="org-hide">**</span><span class="org-level-3">* Arrow Categories</span>
<span class="org-drawer">    :PROPERTIES:...
</span>We can add an arrow to <span class="org-code">&#120794;&#8320;</span> to obtain another category...

Let <span class="org-code">&#120794; &#8788; &#8226; &#10230; &#8226;</span> be the category of two objects, call them 0 and 1, with one arrow between them.
  Then a functor <span class="org-code">&#120794; &#10230; &#119966;</span> is precisely a morphism of &#119966; and a natural transformation
<span class="org-code">f &#10230; g</span> boils down to just a pair of morphisms <span class="org-code">(h,k)</span> with <span class="org-code">h &#10814; g = f &#10814; k</span>.

Hence, the <span class="italic">arrow category of &#119966;</span> is<span class="org-latex-and-related"> $&#119966;^&#120794; \;&#8773;\; &#119966;^&#8594; \;&#8773;\; \mathsf{Func}\, &#120794; &#119966;$;</span>
which is essentially the category with objects being &#119966;-morphisms and morphisms being <span class="italic">commutative squares</span>.

Notice that a functor can <span class="writegood-passive-voice">be used</span> to
+ <span class="italic">select</span> two arbitrary &#119966; objects --if it's source is &#120794;&#8320;
+ <span class="italic">select</span> two arbitrary &#119966; objects with a &#119966; arrow between them --if it's source is &#120794;
+ <span class="italic">select</span> an arbitrary &#119966; arrow --if it's source is &#120794;

Likewise, a natural transformation can <span class="writegood-passive-voice">be used</span> to <span class="italic">select</span> a commutative diagram.

<span class="org-hide">**</span><span class="org-level-3">* Understand &#119966; by looking at Functor Categories</span>
<span class="org-drawer">    :PROPERTIES:...
</span>It is a common heuristic that when one suspects the <span class="italic">possibility</span> of a category <span class="org-code">&#119966;</span>, then one
can make <span class="italic">probes</span> to discover its structure. The objects are just functors <span class="org-code">&#120793; &#10230; &#119966;</span> and the
morphisms are just functors <span class="org-code">&#120794; &#10230; &#119966;</span>.

<span class="org-hide">**</span><span class="org-level-3">* Presheaves -- delegating work to &#119982;&#8495;&#120009;</span>
<span class="org-drawer">    :PROPERTIES:...
</span>
The <span class="italic">category of presheaves of &#119966;</span> is the category <span class="org-code">PSh &#119966; &#8788; Func (&#119966; &#7506;&#7510;) &#119982;e&#120009;</span>.

This is a pretty awesome category since it allows nearly all constructions in &#119982;&#8495;&#120009; to <span class="writegood-passive-voice">be
realised</span>! Such as subsets, truth values, and even powersets! All these extra goodies make it
a &#8216;topos&#8217; aka &#8216;power allegory&#8217; ---the first is a category that has all finite limits and
a notion of powerset while the second, besides the power part, looks like a totally different beast;
the exhilaration!

<span class="org-hide">**</span><span class="org-level-3">* Slice Categories</span>
<span class="org-drawer">    :PROPERTIES:...
</span>The <span class="italic">slice category of &#119966; over B : Obj &#119966;</span> is the category <span class="org-code">&#119966; / B &#8788; &#931; F &#8758; Func &#120794; &#119966; &#8226; (F 1 = B)</span>.

Essentially it is the category of objects being &#119966;-morphisms with target<span class="org-latex-and-related"> $B$
</span>and morphisms<span class="org-latex-and-related"> $f &#10230; g$ </span>being<span class="org-latex-and-related"> $(h,k)$ </span>with<span class="org-latex-and-related"> $h &#10814; g = f &#10814; k$ </span>but a natural choice for<span class="org-latex-and-related">
$k : B &#10230; B$ </span>is<span class="org-latex-and-related"> $\Id_B$ </span>and so we can use morphism type<span class="org-latex-and-related">
$(f &#10230;&#8217; g) \;&#8788;\; &#931; h : \src f &#10230; \src g \;&#8226;\; h &#10814; g = f$.</span>

This <span class="writegood-passive-voice">is seen</span> by the observation <span class="org-latex-and-related">\[(h, k) \;&#8712;\; f &#10230; g \qquad&#8660;\qquad h \;&#8712;\; (f &#10814; k) &#10230;&#8217; g\]</span>
Of course a formal justification <span class="writegood-passive-voice">is obtained</span> by showing
<span class="org-latex-and-related">\[\_{}&#10230;\_{} \quad&#8773;\quad \_{}&#10230;&#8217;\_{} \quad \mathsf{within \; Func }\; (&#119966; &#7506;&#7510; &#8855; &#119966;) &#119982;e&#120009; \]</span>
...which I have not done and so may be spouting gibberish!

<span class="org-drawer">:Solution:...
</span>
Just as the type <span class="org-code">&#931; x &#8758; X &#8226; P x</span> can <span class="writegood-passive-voice">be included</span> in the type <span class="org-code">X</span>, by forgetting the second
component, so too the category <span class="org-code">&#931; F &#8758; &#120794; &#10230; &#119966; &#8226; F 1 &#8776; B</span> can <span class="writegood-passive-voice">be included</span> into the category
&#119966; and we say it is a <span class="italic">subcategory</span> of &#119966;.

The notation <span class="org-code">&#931; o &#8758; Obj &#119966; &#8226; P o</span> defines the subcategory of &#119966; obtained by deleting
all objects not satisfying predicate <span class="org-code">P</span> and deleting all morphisms incident to such objects; i.e.,
it is the category &#119967; with
<span class="org-latex-and-related">\[ \Obj &#119967; \quad&#8801;\quad &#931; o &#8758; \Obj &#119966; \,&#8226;\, P o
   \qquad\text{ and }\qquad
   (o , prf) &#10230;_&#119967; (o' , prf') \quad&#8801;\quad o &#10230;_&#119966; o'
\]</span>
This is the largest/best/universal subcategory of &#119966; whose objects satisfy<span class="org-latex-and-related"> $P$.</span>
<span class="org-macro">{{{newline}}}</span> Formalise this via a universal property ;)

<span class="org-hide">**</span><span class="org-level-3">* Slices of </span><span class="org-level-3"><span class="org-code">&#119982;e&#120009;</span></span><span class="org-level-3"> are Functor Categories</span>
<span class="org-drawer">    :PROPERTIES:...
</span>
<span class="comment"># fibres</span>
<span class="org-latex-and-related">\[ \Func \; S \; &#119982;e&#120009;  \qquad&#8773;\qquad  &#119982;e&#120009; / S \]</span>
Where S in the left <span class="writegood-passive-voice">is construed</span> as a discrete category and in the right
<span class="writegood-passive-voice">is construed</span> as an object of &#119982;e&#120009;.

This is because a functor from a discrete category need only be a function of objects since
there are no non-identity morphisms. That is, a functor<span class="org-latex-and-related"> $f : S &#10230; &#119982;&#8495;&#120009;$
</span><span class="writegood-passive-voice">is determined</span> by giving a set<span class="org-latex-and-related"> $f\,s$ </span>for each element<span class="org-latex-and-related"> $s &#8712; S$ </span>---since there are no non-identity morphisms.
Indeed a functor<span class="org-latex-and-related"> $f : S &#10230; Set$ </span>yields an <span class="italic">S</span>-targeted
function
<span class="org-latex-and-related">\[ (&#931; s &#8758; S \,&#8226;\, f\, s) &#8594; S  \quad:\quad &#955; (s , fs) &#8594; s \]</span>
Conversely a function<span class="org-latex-and-related"> $g : X &#8594; S$ </span>yields a functor by sending elements to their pre-image sets:
<span class="org-latex-and-related">\[ S &#10230; Set \quad:\quad &#955; s &#8594; (&#931; x &#8758; X \,&#8226;\, g\, x &#8801; s)\]</span>

Because of this example, <span class="org-code">&#119966; / B</span> can <span class="writegood-passive-voice">be thought</span> of as &#8216;&#119966;-objects indexed by B&#8217;
--extending this idea further leads to <span class="italic">fibred categories</span>.

<span class="org-hide">**</span><span class="org-level-3">* Natural transformations as functor categories</span>
<span class="org-drawer">    :PROPERTIES:...
</span>
In a similar spirit, we can identify natural transformations as functors!
<span class="org-latex-and-related">\[\Func \, &#119966; \, (&#119967; ^ &#120794;) \quad&#8773;\quad (&#931; F , G &#8758; &#119966; &#10230; &#119967; \;&#8226;\; \mathsf{NatTrans}\, F\, G)\]</span>

A functor<span class="org-latex-and-related"> $N : &#119966; &#10230; &#119967; ^ &#120794;$ </span>gives, for each object<span class="org-latex-and-related"> $C : \Obj &#119966;$ </span>an object in<span class="org-latex-and-related"> $&#119967; ^ &#120794;$ </span>which
is precisely an arrow in<span class="org-latex-and-related"> $&#119967;$,</span> rewrite it as<span class="org-latex-and-related"> $N_C : F\,C &#10230; G\,C$ </span>where<span class="org-latex-and-related"> $F\,C \,&#8788;\, N\, C\, 0$
</span>and<span class="org-latex-and-related"> $G\, C \,&#8788;\, N\, C\, 1$.</span>

Likewise, for each arrow<span class="org-latex-and-related"> $f : A &#10230; B$ </span>in &#119966; we obtain an arrow<span class="org-latex-and-related"> $N\, f \,:\, N\, A &#10230; N\, B$
</span>in<span class="org-latex-and-related"> $&#119967; ^ &#120794;$ </span>which is precisely a commutative square in &#119967;;
that is, a pair of &#119967;-arrows<span class="org-latex-and-related"> $(F\,f , G\,f) &#8788; N\,f$
</span>with<span class="org-latex-and-related"> $N_A &#10814; G\,f \;=\; F\,f &#10814; N_B$.</span>

Notice that we have implicitly defined two functors<span class="org-latex-and-related"> $F, G : &#119966; &#10230; &#119967;$.</span>
Their object and morphism mappings are clear, but what about functoriality?
We prove it for both<span class="org-latex-and-related"> $F, G$ </span>together.

<span class="comment"># \begin{multicols}{2}</span>

<span class="underline">Identity:</span>
<span class="org-latex-and-related">\begin{calc}
     (F \,\Id \, , \, G\, \Id)
\step{ definition of $F$ and $G$ }
     N \, \Id
\step{ $N$ is a functor }
     \Id \,&#8758;\, &#119967; ^ &#120794;
\step{ identity in arrow categories }
     (\Id , \Id)
\end{calc}</span>
<span class="comment">#   \columnbreak</span>
<span class="underline">Composition:</span>
<span class="org-latex-and-related">\begin{calc}
     ( F (f &#10814; g) , G (f &#10814; g) )
   \step{ definition of $F$ and $G$ }
     N\, (f &#10814; g)
   \step{ $N$ is a functor }
     N\, f  &#10814;  N\, g
   \step{ definition of $F$ and $G$ }
     (F\, f, G\, f) &#10814; (F\,g , G\,g)
   \step{ composition in arrow categories }
     (F\,f &#10814; F\,g , G\,f &#10814; G\,g)
\end{calc}</span>
<span class="comment">  # \end{multicols}</span>

Sweet!

Conversely, given a natural transformation<span class="org-latex-and-related"> $&#951; : F \overset{.}{&#10230;} G$
</span>we define a functor<span class="org-latex-and-related"> $N : &#119966; &#10230; &#119967; ^ &#120794;$ </span>by sending objects<span class="org-latex-and-related"> $C$ </span>to<span class="org-latex-and-related"> $&#951;_C : F\, C &#10230; G\, C$,</span>
which is an object is<span class="org-latex-and-related"> $&#119967; ^ &#120794;$,</span> and sending morphisms<span class="org-latex-and-related"> $f : A &#10230; B$ </span>to pairs<span class="org-latex-and-related"> $(G f , </span><span class="org-latex-and-related"><span class="writegood-duplicates">F f</span></span><span class="org-latex-and-related">)$,</span>
which is a morphism in<span class="org-latex-and-related"> $&#119967; ^ &#120794;$ </span>due to naturality of &#951;; namely<span class="org-latex-and-related">
$&#951;_A &#10814; G\, f \;=\; F\, f &#10814; &#951;_B$.</span>
It remains to show that<span class="org-latex-and-related"> $N$ </span>preserves identities and composition --Exercise!

Now it remains to show that these two processes are inverses
and the isomorphism claim is complete. Woah!

Similarly, to show
<span class="org-latex-and-related">\[ \Func\, (&#120794; &#8855; &#119966;) \, &#119967; \qquad&#8773;\qquad (&#931; F&#8320; , F&#8321; &#8758; &#119966; &#10230; &#119967; &#8226; \mathsf{NatTrans}\, F&#8321; \, F&#8322;)\]</span>
<span class="comment"># It suffices to show that &#8216;&#8216;the universal property of exponentiation&#8217;&#8217;</span>
<span class="comment"># &#119987; &#10230; (&#119989; ^ &#119988;) &#8773; (&#119987; &#8855; &#119988; &#10230; &#119989;, or more</span>
<span class="comment">#   directly: to/from direction obtained</span>
By setting<span class="org-latex-and-related"> $H\, i \;=\; F&#7522;$ </span>on objects and likewise for morphisms
but with<span class="org-latex-and-related"> $H(\Id, 1) \;=\; &#951;$ </span>where<span class="org-latex-and-related"> $1 : 0 &#10230; 1$ </span>is the non-identity arrow of <span class="org-code">&#120794;</span>.

(Spoilers! Alternatively: <span class="org-code">Arr (Func &#119966; &#119967;) &#8773; &#120794; &#10230; &#119966; ^ &#119967; &#8773; &#119966; &#215; &#120794; &#10230; &#119967;</span> since <span class="org-code">&#119966;&#119990;&#120009;</span> has exponentials,
   and so the objects are isomorphic; i.e., natural transformations correspond to functors <span class="org-code">&#119966;&#215;&#120794;&#10230;&#119967;</span>)

   Why are we mentioning this alternative statement? Trivia knowledge of-course!

   On a less relevant note, if you&#8217;re familiar with the theory of stretching-without-tearing,
   formally known as topology which is pretty awesome, then you might&#8217;ve heard of paths and
   deformations of paths <span class="writegood-passive-voice">are known</span> as homotopies which are just continuous functions
  <span class="org-latex-and-related"> $H : X &#215; I &#10230; Y$ </span>for topological spaces $X, Y,$ and<span class="org-latex-and-related"> $I \,=\, [0,1]$ </span>being the unit interval in &#8477;.
   Letting<span class="org-latex-and-related"> $&#119973; = &#120794;$ </span>be the &#8216;categorical interval&#8217; we have that functors<span class="org-latex-and-related"> $&#119966; &#215; &#119973; &#10230; &#119967;$
</span>   are, by the trivia-relevant result, the same as natural transformations.
   That is, <span class="italic">natural transformations extend the notion of homotopies, or path-deformations.</span>

On <span class="org-link"><a href="http://mathoverflow.net/a/75686/42716">mathoverflow</a></span>, the above is recast succinctly as:
   A natural transformation from<span class="org-latex-and-related"> $F$ </span>to<span class="org-latex-and-related"> $G$ </span>is a functor,
   targeting an arrow category, whose &#8216;source&#8217;
   is<span class="org-latex-and-related"> $F$ </span>and whose &#8216;target&#8217; is<span class="org-latex-and-related"> $G$.</span>
   <span class="org-latex-and-related">\[
       \hspace{-2em} F \overset{.}{&#10230;} G : &#119966; &#10230; &#119967; \quad&#8773;\quad
       &#931; &#951; &#8758; &#119966; &#10230; \mathsf{Arr}\, &#119967; &#8226;\; \mathsf{Src} &#8728; &#951; = F \;\;&#8743;\;\; \mathsf{Tgt} &#8728; &#951; = G
   \]</span>
   Where, the projection functors
<span class="org-latex-and-related">   \begin{align*}
      \mathsf{Src}&amp;                              &amp;:&amp; \mathsf{Arr}\, &#119967; &#10230; &#119967;
   \\ \mathsf{Src}&amp; (A&#8321; , A&#8322; , f)                &amp;=&amp; A&#8321;
   \\ \mathsf{Src}&amp; (f  , g  , h&#8321; , h&#8322; , proofs) &amp;=&amp; h&#8321;
   \end{align*}</span>
   with<span class="org-latex-and-related"> $\mathsf{Tgt}$ </span>returning the other indexed items.

<span class="org-hide">*</span><span class="org-level-2">* Graphs as functors</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
We give an example of a functor by building on our existing graphs setup.
After showing that graphs correspond to certain functors, we then
mention that the notion of graph-map is nothing more than the associated
natural transformations!

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> graphs</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">as</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">functors </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
</span><span class="org-block-end-line">#+END_SRC
</span>
Let us construct our formal graph category, which contains the ingredients for
a graph and a category and nothing more than the equations needed of a category.
The main ingredients of a two-sorted graph are two sort-symbols <span class="org-code">E, V</span>, along with
two function-symbols <span class="org-code">s, t</span> from <span class="org-code">E</span> to <span class="org-code">V</span> ---this is also called &#8216;the signature
of graphs&#8217;. To make this into a category, we need function-symbols <span class="org-code">id</span> and a composition
for which it is a unit.
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">formal objects
</span></span><span class="org-block">  </span><span class="org-block"><span class="haskell-keyword">data</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">&#119970;</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-type">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">Set</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">E</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block">&#8320;

  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">formal arrows
</span></span><span class="org-block">  </span><span class="org-block"><span class="haskell-keyword">data</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">&#119970;</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-type">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">&#119970;</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">&#119970;</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">Set</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
     s t </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-constructor">E</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">
     id  </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {o} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="writegood-duplicates">o o</span></span><span class="org-block">

  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">(forward) composition
</span></span><span class="org-block">  fcmp </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {a b c} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block">&#8321; a b </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block">&#8321; b c </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block">&#8321; a c
  fcmp f id </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> f
  fcmp id f </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> f
</span><span class="org-block-end-line">#+END_SRC
</span>
Putting it all together,
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">  </span><span class="org-block"><span class="haskell-keyword">instance</span></span><span class="org-block">
   </span><span class="org-block"><span class="haskell-type">&#119970;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">Category</span></span><span class="org-block">
   </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> record
        { </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block">     </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block">&#8320;
        ; </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">     </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block">&#8321;
        ; </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">     </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> fcmp
        ; assoc   </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; {a b c d f g h} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> fcmp</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">assoc f g h
        ; </span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block">      </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> id
        ; leftId  </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> left</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">id
        ; rightId </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> right</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">id
        }
    </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
       </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">exercises: prove associativity, left and right unit laws
</span></span><span class="org-block-end-line">#+END_SRC
</span>
<span class="org-drawer">:Solution:...
</span>
Now we can show that every graph <span class="org-code">G</span> gives rise to a functor: A semantics of <span class="org-code">&#119970;</span> in <span class="org-code">&#119982;e&#120009;</span>.
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">  toFunc </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119982;e&#120009;</span></span><span class="org-block">
  toFunc </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> record
    { obj  </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#10214;</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">&#10215;&#8320;
    ; mor  </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#10214;</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">&#10215;&#8321;
    ; id   </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl
    ; comp </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; {x y z f g} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> fcmp</span><span class="org-block"><span class="haskell-operator">-&#10814;</span></span><span class="org-block"> {x} {y} {z} {f} {g}
    }
    </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
      &#10214;</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">&#10215;&#8320; </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119982;e&#120009;</span></span><span class="org-block">
      &#10214; </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block">&#8320;</span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block"> &#10215;&#8320; </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph.V</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">
      &#10214; </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block">&#8320;</span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block"><span class="haskell-constructor">E</span></span><span class="org-block"> &#10215;&#8320; </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#931;</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph.V</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8226;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#931;</span></span><span class="org-block"> y </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph.V</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8226;</span></span><span class="org-block"> Graph._</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> x y

      &#10214;</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">&#10215;&#8321; </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {x y </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> y </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (&#10214; x &#10215;&#8320; </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> &#10214; y &#10215;&#8320;)
      &#10214; s &#10215;&#8321; (src , tgt , edg) </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> src
      &#10214; t &#10215;&#8321; (src , tgt , edg) </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> tgt
      &#10214; id &#10215;&#8321; x </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> x

      </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Exercise: fcmp </span></span><span class="org-block"><span class="comment"><span class="writegood-passive-voice">is realised</span></span></span><span class="org-block"><span class="comment"> as functional composition
</span></span><span class="org-block">      fcmp</span><span class="org-block"><span class="haskell-operator">-&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{x y z} {f </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block">&#8321; x y} {g </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block">&#8321; y z} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> &#10214; fcmp f g &#10215;&#8321; </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> &#10214; f &#10215;&#8321; </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> &#10214; g &#10215;&#8321;
</span><span class="org-block-end-line">#+END_SRC
</span><span class="org-drawer">:Solution:...
</span>
Conversely, every such functor gives a graph whose vertices and edges are the sets
associated with the sort-symbols <span class="org-code">V</span> and <span class="org-code">E</span>, respectively.
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">  fromFunc </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119982;e&#120009;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block">
  fromFunc </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> record {
      </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">      </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> obj </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block">&#8320;</span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">
    ; </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">    </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; x y </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#931;</span></span><span class="org-block"> e </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> obj </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block">&#8320;</span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block"><span class="haskell-constructor">E</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8226;</span></span><span class="org-block"> src e </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#215;</span></span><span class="org-block"> tgt e </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> y
             </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">the type of edges whose source is x and target is y
</span></span><span class="org-block">    }
    </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block"> tgt src </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> obj </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block">&#8320;</span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block"><span class="haskell-constructor">E</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> obj </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block">&#8320;</span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">
          src </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block">&#8321;</span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block">s
          tgt </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block">&#8321;</span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block">t
</span><span class="org-block-end-line">#+END_SRC
</span>
It is to <span class="writegood-passive-voice">be noted</span> that we can define &#8216;&#8216;graphs over &#119966;&#8217;&#8217; to be the category <span class="org-code">Func &#119970; &#119966;</span>.
<span class="writegood-weasels">Some</span> consequences are as follows: Notion of graph in any category, the notion of graph-map
is the specialisation of natural transformation (!), and most importantly, all the power of functor categories
is avaiable for the study of graphs.

In <span class="writegood-weasels">some</span> circles, you may hear people saying an &#8216;algebra over the signature of graphs&#8217; is an interpretation
domain (<span class="org-code">&#119966;</span>) and an operation (<span class="org-code">Functor &#119970; &#119966;</span>) interpreting the symbols. <span class="italic">Nice!</span>

<span class="comment"># We no longer make use of this two-sorted approach to graphs.</span>
<span class="org-meta-line">#
# Yes, I do: To motivate, rather find, my definition of graphs!</span>
<span class="org-level-1">* A </span><span class="org-level-1"><span class="writegood-weasels">few</span></span><span class="org-level-1"> categorical constructions</span>
<span class="org-drawer">:PROPERTIES:...
</span>
We briefly take a pause to look at the theory of category theory.
In particular, we show a pair of constructions to get new categories from old ones,
interpret these constructions from the view of previously mentioned categories, and
discuss how to define the morphism type <span class="org-code">_&#10230;_</span> on morphisms themselves, thereby
yielding a functor.

<span class="org-hide">*</span><span class="org-level-2">* Opposite</span>
<span class="org-drawer">   :PROPERTIES:...
</span>The &#8216;dual&#8217; or &#8216;opposite&#8217; category &#119966;&#7506;&#7510; is the category constructed from &#119966; by
reversing arrows:<span class="org-latex-and-related"> $(A &#10230;_{&#119966;&#7506;&#7510;} B) \;&#8788;\; (B &#10230;_&#119966; A)$,</span> then necessarily<span class="org-latex-and-related">
$(f &#10814;_{&#119966;&#7506;&#7510;} g) \;&#8788;\; g &#10814;_&#119966; f$.</span>
A &#8216;contravariant functor&#8217;, or &#8216;cofunctor&#8217;, is a functor F from an opposite category and so
there is a reversal of compositions:<span class="org-latex-and-related"> $F(f \,&#10814;\, g) \;=\; F g \,&#10814;\, F f$.</span>
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom"> _&#7506;&#7510; : &#8704; {i j} &#8594; Category {i} {j} &#8594; Category
 &#119966; &#7506;&#7510; = {! exercise !}
</span><span class="org-block-end-line">#+END_EXAMPLE
</span><span class="org-drawer">:Solution:...
</span>
Notice that<span class="org-latex-and-related"> $(&#119966; &#7506;&#7510;) &#7506;&#7510; \;=\; &#119966;$ </span>and<span class="org-latex-and-related"> $&#119966; &#7506;&#7510; \;&#8773;\; &#119966;$
</span>--one <span class="writegood-weasels">may have</span> an intuitive idea of what this isomorphsim means,
but formally it is only meaningful in the context of an ambient category; keep reading ;)

We must admit that for categories, the notion of isomorphism <span class="writegood-passive-voice">is considered</span> less useful
than that of equivalence which weakens the condition of the to-from functors being
inverses to just being naturally isomorphic to identities; C.f., &#8216;evil&#8217; above.

<span class="writegood-weasels">Some</span> interpretations:

+  &#119982;e&#120009;&#7506;&#7510; is usual sets and functions but with &#8216;backwards composition&#8217;:
<span class="org-block-begin-line">   #+BEGIN_src haskell
</span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">infix</span></span><span class="org-block"> 10 </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#8728;</span></span><span class="org-block"><span class="haskell-keyword"><span class="writegood-duplicates">_</span></span></span><span class="org-block"><span class="writegood-duplicates">
 </span></span><span class="org-block"><span class="haskell-keyword"><span class="writegood-duplicates">_</span></span></span><span class="org-block"><span class="haskell-operator">&#8728;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {i j } &#10627; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {i} {j}&#10628; {</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">C</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">C</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">  </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">C</span></span><span class="org-block">
 f </span><span class="org-block"><span class="haskell-operator">&#8728;</span></span><span class="org-block"> g </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> g </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> f
</span><span class="org-block-end-line">#+END_SRC
</span>   Indeed, we have <span class="org-code">g &#10814; f within &#119966;  =  f &#8728; g within &#119966; &#7506;&#7510;</span>; which is how these composition operators
    are usually related in informal mathematics (without mention of the ambient categories of course).

   On a more serious note, the opposite of &#119982;e&#120009; is <span class="writegood-weasels">clearly</span> &#120009;&#8495;&#119982; haha
   ---technically for the purposes of this pun we identify the words &#8216;opposite&#8217; and &#8216;reverse&#8217;.

+
  For a discrete category, its opposite is itself.

+
  For a monoid (viewed as a category), its opposite is itself if the monoid operation is commutative, otherwise
  it is the &#8216;dual monoid&#8217;.

+
  For a poset (viewed as a category), its opposite is the &#8216;dual poset&#8217;:<span class="org-latex-and-related"> $(P, &#8849;)&#7506;&#7510; \;=\; (P, &#8850;)$.</span>

  In particular, the &#8216;least upper bound&#8217;, or &#8216;supremum&#8217; in<span class="org-latex-and-related"> $(P, &#8849;)$ </span>of two elements
 <span class="org-latex-and-related"> $x,y$ </span>is an element<span class="org-latex-and-related"> $s$ </span>with the &#8216;universal property&#8217;:<span class="org-latex-and-related"> $&#8704; z &#8226;\; x &#8849; z &#8743; y &#8849; z \;&#8801;\; s &#8849; z$.</span>
  However, switching &#8849; with &#8850; gives us the notion of &#8216;infimum&#8217;, &#8216;greatest upper bound&#8217;!
  So any theorems about supremums automatically hold for infimums since the infifum is nothing
  more than the supremum in the dual category of the poset.

  It is not difficult to see that this idea of &#8220;2 for the price of 1&#8221; for theorems holds for all
  categories.

+ <span class="bold">Stone Duality:</span>
  <span class="org-code">FinBoolAlg &#8771; FinSets &#7506;&#7510;</span> , witnessed by considering the collection of
  atoms of a Boolean Algebra in one direction and the power set in the other.
  Finiteness can <span class="writegood-passive-voice">be removed</span> at the cost of completeness and atomicitiy,
  <span class="org-code">CompleteAtomicBoolAlg &#8771; &#119982;&#8495;&#120009; &#7506;&#7510;</span>.

+ What about the category of functors and natural transformations?

Speaking of functors, we can change the type of a functor by <span class="org-code">&#7506;&#7510;</span>-ing its source and target,
while leaving it alone,
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"> </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">this only changes type
</span></span><span class="org-block"> opify </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {i j i&#8217; j&#8217;} {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {i} {j}} {</span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {i&#8217;} {j&#8217;}}
      </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> &#7506;&#7510;) (</span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> &#7506;&#7510;)
 opify </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> record { obj   </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block">  obj </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">
                  ; mor   </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block">  mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">
                  ; id    </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block">  Functor.id </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">
                  ; comp  </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block">  Functor.comp </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">
                  }
</span><span class="org-block-end-line">#+END_SRC
</span>
<span class="org-block-begin-line">#+BEGIN_QUOTE
</span><span class="org-quote">Category Theory is the &#8216;op&#8217;ium of the people!

--- Karl Marx might say it had cats existed in his time
</span><span class="org-block-end-line">#+END_QUOTE
</span>
This two definitions seem to indicate that we have <span class="writegood-weasels">some</span> form of opposite-functor &#8230; ;)
---keep reading!

<span class="org-code">opify</span> seems to show that <span class="org-code">Functor &#119966; &#119967; &#8801; Functor (&#119966; &#7506;&#7510;) (&#119967; &#7506;&#7510;)</span>, or alternatively a
functor can have &#8216;two different types&#8217; ---this is akin to using the integers as reals
without writing out the inclusion formally, leaving it implicit; however, in the Agda mechanization
everything must <span class="writegood-passive-voice">be made</span> explicit ---the type system doesn&#8217;t let you get away with such things.
Professor Maarten Fokkinga has informed me that
the formalization allowing multiple-types <span class="writegood-passive-voice">is called</span> a
<span class="org-link"><a href="http://maartenfokkinga.github.io/utwente/mmf92b.pdf">pre-category</a></span>.

<span class="org-hide">**</span><span class="org-level-3">* ah-yeah: &#8706; and dagger categories</span>
<span class="org-drawer">    :PROPERTIES:...
</span>
With <span class="org-code">&#119966;&#119990;&#120009;</span> in-hand, we can formalise the opposite, or &#8706;ual, functor:
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8706;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {i j} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block"> {i} {j}) </span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block">
 </span><span class="org-block"><span class="haskell-operator">&#8706;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> record { obj </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> _&#7506;&#7510; ; mor </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> opify ; id </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl ; comp </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl }
</span><span class="org-block-end-line">#+END_SRC
</span>
Conjecture: Assuming categories <span class="writegood-passive-voice">are equipped</span> with a contravariant involutionary functor
that is identity on objects, we can show that the identity functor is naturally isomorphic
to the opposite functor.

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"> ah</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">yeah </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {i j} (</span><span class="org-block"><span class="haskell-keyword">let</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Cat</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block"> {i} {j}))
     </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">identity on objects cofunctor, sometimes denoted _&#728;
</span></span><span class="org-block">     </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (dual </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Cat</span></span><span class="org-block">) {x y </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">}  </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">  x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> y </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">  </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">  y </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">)
     </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block"><span class="haskell-operator">&#728;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> &#10627; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Cat</span></span><span class="org-block"> &#10628; {x </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> dual </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block">  </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">  </span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> x})
     </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-operator">&#10814;-&#728;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> &#10627; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Cat</span></span><span class="org-block"> &#10628; {x y z </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} {f </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> y} {g </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> y </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> z}
            </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> dual </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> (f </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> g </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">)  </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">  (dual </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> g) </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> (dual </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> f) </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">)
     </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">which is involutionary
</span></span><span class="org-block">     </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-operator">&#728;&#728;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> &#10627; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Cat</span></span><span class="org-block"> &#10628; {x y </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} {f </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> y} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> dual </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> (dual </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> f) </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> f)
     </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">which </span></span><span class="org-block"><span class="comment"><span class="writegood-passive-voice">is respected</span></span></span><span class="org-block"><span class="comment"> by other functors
</span></span><span class="org-block">     </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (respect </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> &#10627; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Cat</span></span><span class="org-block"> &#10628; {</span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">} {x y </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} {f </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> y}
                </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> (dual </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> f) </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> dual </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> (mor </span><span class="org-block"><span class="haskell-constructor"><span class="writegood-duplicates">F</span></span></span><span class="org-block"><span class="writegood-duplicates"> f</span></span><span class="org-block">))
     </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">then
</span></span><span class="org-block">     </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8706;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8773;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block"> within </span><span class="org-block"><span class="haskell-constructor">Func</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block"> {i} {j}) </span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block">
</span><span class="org-block-end-line">#+END_SRC
</span><span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom"> ah-yeah = {! exercise !}
</span><span class="org-block-end-line">#+END_EXAMPLE
</span><span class="org-drawer">:Solution:...
</span>
<span class="writegood-weasels">Some</span> things to note.

+
  Categories whose morphisms are all isomorphisms <span class="writegood-passive-voice">are called</span> &#8216;groupoids&#8217; ---groups are just one-object groupoids.
  Consequently, restricted to groupoids the opposite functor is naturally isomorphic to the identity functor!

  In fact, the group case was the motivator for me to conjecture the theorem, which took a while to prove since I hadn&#8217;t
  a clue what I needed to assume. Here we&#8217;d use <span class="org-code">a &#728; &#8788; a &#8315;&#185;</span>.

+
  Consider the category <span class="org-code">Rel</span> whose objects are sets and whose morphisms are &#8216;typed-relations&#8217;<span class="org-latex-and-related"> $(S, R, T)$,</span>
  where<span class="org-latex-and-related"> $R$ </span>is a relation from set<span class="org-latex-and-related"> $S$ </span>to set<span class="org-latex-and-related"> $T$,</span> and
  composition is just relational composition
  ---the notion of &#8216;untyped&#8217;, or multi-typed, morphisms <span class="writegood-passive-voice">is formalized</span> as pre-categories;
  see <span class="org-link"><a href="http://maartenfokkinga.github.io/utwente/mmf92b.pdf">Fokkinga</a></span>.
  Then we can define an endofunctor by taking <span class="org-code">-&#728;</span> to be relational converse:<span class="org-latex-and-related"> $x \,(R &#728;)\, y \;&#8801;\; y \,R\, x$.</span>
  Consequently, restricted to the category <span class="org-code">Rel</span> we have that the opposite functor is naturally isomorphic to the identity functor.

<span class="org-drawer">  :NeatObservation:...
</span>
The above items are instance of a more general concept, of course.

A category with an involutionary contravariant endofunctor that is the identity on objects
<span class="writegood-passive-voice">is known</span> as <span class="italic">a dagger category, an involutive/star category, or a category with converse</span>
---and the functor <span class="writegood-passive-voice">is denoted</span> as a superscript suffix by <span class="org-code">&#8224;, *, &#728;</span>, respectively.
The dagger notation <span class="writegood-weasels">probably</span> comes from
the Hilbert space setting while the converse notation comes from the relation algebra setting.
As far as I know, the first two names are more widely known.
A dagger category bridges the gap between arbitrary categories and groupoids.

Just as matrices with matrix multiplication do not form a monoid but rather a category, we have
that not all matrices are invertible but they all admit transposition and so we have a dagger
category. In the same vein, relations admit converse and so give rise to a category with converse.

Besides relations and groupoids, other examples include:
+ discrete categories with the dagger being the identity functor
+ every monoid with an anti-involution is trivially a dagger category; e.g.,
   lists with involution being reverse.
+ commutative monoids are anti-involutive monoids with anti-involution being identity

Spoilers!! Just as the category of categories is carestian closed, so too is the category of dagger
categories and dagger preserving functors --c.f.,the <span class="org-code">respect</span> premise above.

<span class="org-drawer">:PseudoHeaps:...
</span>
<span class="org-hide">*</span><span class="org-level-2">* Products</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
For any two categories &#119966; and &#119967; we can construct their &#8216;product&#8217; category<span class="org-latex-and-related">
$&#119966; &#8855; &#119967;$ </span>whose objects and morphisms are pairs with components from &#119966; and &#119967;:<span class="org-latex-and-related">
$\Obj\, (&#119966; &#8855; &#119967;) \;\;=\;\; \Obj\, &#119966; \,&#215;\, \Obj\, &#119967;$ </span>and<span class="org-latex-and-related">
$(A , X) &#10230;_{&#119966; &#8855; &#119967;} (B , Y) \;\;=\;\; (A &#10230;_&#119966; B) \,&#215;\, (X &#10230;_&#119967; Y)$.</span>
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom"> -- we cannot overload symbols in Agda and so using &#8216;&#8855;&#8217; in-place of more common &#8216;&#215;&#8217;.
 _&#8855;_ : &#8704; {i j i&#8217; j&#8217;} &#8594; Category {i} {j} &#8594; Category {i&#8217;} {j&#8217;} &#8594; Category
 &#119966; &#8855; &#119967; = {! exercise !}
</span><span class="org-block-end-line">#+END_EXAMPLE
</span><span class="org-drawer">:Solution:...
</span>
Observe that in weaker languages, a category <span class="writegood-passive-voice">is specified</span> by its objects, morphisms, and composition
---the proof obligations <span class="writegood-passive-voice">are delegated</span> to comments, if they <span class="writegood-passive-voice">are realized</span> at all.
In such settings, one would need to prove that this construction actually produces a full-fledged
category. Even worse, this proof may be a distance away in <span class="writegood-weasels">some</span> documentation.
With dependent types, our proof obligation is nothing more than another component of the program,
a piece of the category type.

In a similar fashion we can show that the sum of two categories is again a category and in general
we have the same for quantified variants: <span class="org-code">&#928; &#119966; &#8758; Family &#8226; &#119966;</span>, likewise for &#8216;&#931;&#8217;.
For the empty family, the empty sum yields the category <span class="org-code">&#120792;</span> with no objects and
the empty product yields the category <span class="org-code">&#120793;</span> of one object.
One can then show the usual &#8216;laws of arithmetic&#8217; ---i.e., &#215;,+ form a commutative monoid, up to isomorphism---
hold in this setting: Letting <span class="org-code">&#9733; &#8712; {+,&#215;}</span>, we have
associtivity <span class="org-code">A &#9733; (B &#9733; C) &#8773; (A &#9733; B) &#9733; C</span>, symmetry <span class="org-code">A &#9733; B &#8773; B &#9733; A</span>,
unit <span class="org-code">&#120793; &#215; A &#8773; &#120792; + A &#8773; A</span>, and zero <span class="org-code">&#120792; &#215; A &#8773; &#120792;</span>.
These notions can <span class="writegood-passive-voice">be defined</span> for any category though the objects may or may not exist
--- in <span class="org-code">&#119982;e&#120009;</span> and <span class="org-code">&#119970;&#120007;&#119990;&#120005;&#119997;</span>, for example, they do exist ;) ---and these associated arithmetical
laws also hold.

<span class="italic">Question!</span> What of the distributivity law,
<span class="org-code">A &#215; (B + C) &#8773; (A &#215; B) + (A &#215; C)</span>, does it hold in the mentioned cases?
Let <span class="org-code">&#119979;&#119982;e&#120009;</span> be the category of sets with a distinguished point, i.e.,  <span class="org-code">&#931; S : Obj &#119982;e&#120009; &#8226; S</span>, and
functions that preserve the &#8216;point&#8217;, one can then show ---if he or she so desires, and is not
lazy--- that this category has notions of product and sum but distributivity fails.

<span class="writegood-weasels">Some</span> interpretations:
+
  For discrete categories, this is the usual Cartesian product.
+
  For monoid (or poset) categories, this says that the product of two monoids (or posets) is again
  a monoid (respectively poset. This follows since the product does not affect the number of
  objects and so the product is again a one-object category, i.e., a monoid (poset respectively).
+ <span class="writegood-weasels">Interestingly</span>, the <span class="italic">sum</span> of two monoids is <span class="bold">not</span> formed by their disjoint union: Instead
  it is the set of all alternating lists of elements from the two given monoids.
  Exercise: Find the associated operation ;-)

As expected, we have projections,
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Fst</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {i j i&#8217; j&#8217;} {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {i} {j}} {</span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {i&#8217;} {j&#8217;}}
     </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8855;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">
 </span><span class="org-block"><span class="haskell-constructor">Fst</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> record { obj </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> proj&#8321; ; mor </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> proj&#8321; ; id </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl ; comp </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl }

 </span><span class="org-block"><span class="haskell-constructor">Snd</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {i j i&#8217; j&#8217;} {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {i} {j}} {</span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {i&#8217;} {j&#8217;}}
     </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8855;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">
 </span><span class="org-block"><span class="haskell-constructor">Snd</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> record { obj </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> proj&#8322; ; mor </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> proj&#8322; ; id </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl ; comp </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl }
</span><span class="org-block-end-line">#+END_SRC
</span>
<span class="org-hide">**</span><span class="org-level-3">* Currying</span>
<span class="org-drawer">    :PROPERTIES:...
</span>
For types we have <span class="org-latex-and-related">\[ (&#119987; &#215; &#119988; &#10230; &#119989;) \quad&#8773;\quad (&#119987; &#10230; &#119989; ^ &#119988;) \quad&#8773;\quad (&#119988; &#10230; &#119989; ^ &#119987;)\]</span>
Since categories are essentially types endowed with nifty structure,
we expect it to hold in that context as well.
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">  -- Everyone usually proves currying in the first argument,
  -- let&#8217;s rebel and do so for the second argument
 curry&#8322; : &#8704; {ix jx iy jy iz jz}
          {&#119987; : Category {ix} {jx}} {&#119988; : Category {iy} {jy}} {&#119989; : Category {iz} {jz}}
        &#8594; Functor (&#119987; &#8855; &#119988;) &#119989; &#8594; Functor &#119988; (Func &#119987; &#119989;)
 curry&#8322; = {! exercise !}
</span><span class="org-block-end-line">#+END_EXAMPLE
</span><span class="org-drawer">:Solution:...
</span>
<span class="org-hide">*</span><span class="org-level-2">* Pointwise extensions and the hom functor</span>
<span class="org-drawer">   :PROPERTIES:...
</span>Just as addition can <span class="writegood-passive-voice">be extended</span> to number-valued functions pointwise,<span class="org-latex-and-related"> $f + g \;&#8788;\; &#955; x &#8594; f x + g x$,</span>
we can do the same thing with functors.
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom"> -- For bifunctor &#8216;&#8853;&#8217; and functors &#8216;F, G&#8217;, we have a functor &#8216;&#955; x &#8594; F x &#8853; G x&#8217;
 pointwise : &#8704; {ic jc id jd ix jx iy jy}
   {&#119966; : Category {ic} {jc}} {&#119967; : Category {id} {jd}} {&#119987; : Category {ix} {jx}} {&#119988; : Category {iy} {jy}}
   &#8594; Functor (&#119987; &#8855; &#119988;) &#119967; &#8594; Functor &#119966; &#119987; &#8594; Functor &#119966; &#119988;
   &#8594; Functor &#119966; &#119967;
 pointwise = {! exercise !}
</span><span class="org-block-end-line">#+END_EXAMPLE
</span><span class="org-drawer">:Solution:...
</span>
By &#8216;extensionality&#8217; <span class="org-code">p &#8801; (proj&#8321; p , proj&#8322; p)</span>, we have that the pointwise extension along the projections
is the orginal operation.
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"> exempli</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">gratia </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119987;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119988;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {&#8467;&#8320;} {&#8467;&#8320;}} (</span><span class="org-block"><span class="haskell-operator">&#8853;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">&#119987;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8855;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119988;</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">)
                </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">let</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">&#10216;</span><span class="org-block"><span class="haskell-operator">&#8853;</span></span><span class="org-block">&#10217;</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> pointwise </span><span class="org-block"><span class="haskell-operator">&#8853;</span></span><span class="org-block">
                   </span><span class="org-block"><span class="haskell-keyword">in</span></span><span class="org-block">
                      </span><span class="org-block"><span class="haskell-constructor">Fst</span></span><span class="org-block"> &#10216;</span><span class="org-block"><span class="haskell-operator">&#8853;</span></span><span class="org-block">&#10217; </span><span class="org-block"><span class="haskell-constructor">Snd</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8853;</span></span><span class="org-block">
 exempli</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">gratia </span><span class="org-block"><span class="haskell-constructor">Bi</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> funcext (</span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">cong (obj </span><span class="org-block"><span class="haskell-constructor">Bi</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl) (</span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">cong (mor </span><span class="org-block"><span class="haskell-constructor">Bi</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl)
</span><span class="org-block-end-line">#+END_SRC
</span>
An example bifunctor <span class="writegood-passive-voice">is obtained</span> by extending the &#8216;&#10230;&#8217; to morphisms:
Given <span class="org-code">f : A &#10230; B , g : C &#10230; D</span> we define <span class="org-code">(f &#10230; g) : (B &#10230; C) &#8594; (A &#10230; C)</span> by
<span class="org-code">&#955; h &#8594; f &#10814; h &#10814; g</span> as this is the only way to define it so as to meet the type requirements.
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Hom</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {i j} {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {i} {j} } </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> &#7506;&#7510; </span><span class="org-block"><span class="haskell-operator">&#8855;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">) (</span><span class="org-block"><span class="haskell-constructor">&#119982;e&#120009;</span></span><span class="org-block"> {j})
   </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">hence contravariant in &#8216;first arg&#8217; and covaraint in &#8216;second arg&#8217;
</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Hom</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block">
   </span><span class="org-block"><span class="haskell-keyword">let</span></span><span class="org-block">
     </span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">
     </span><span class="org-block"><span class="haskell-keyword">instance</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">&#119966;</span></span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">Category</span></span><span class="org-block"> ; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">
     </span><span class="org-block"><span class="haskell-operator">&#10814;-</span></span><span class="org-block">cong&#8322; </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">C</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} {f </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block">} {</span><span class="org-block"><span class="writegood-duplicates">g g</span></span><span class="org-block">&#8217; </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">C</span></span><span class="org-block">}
             </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> g </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> g&#8217; </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> f </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> g </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> f </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> g&#8217;
     </span><span class="org-block"><span class="haskell-operator">&#10814;-</span></span><span class="org-block">cong&#8322;  q  </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block">  </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">cong&#8322; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl q
   </span><span class="org-block"><span class="haskell-keyword">in</span></span><span class="org-block"> record {
     obj </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955;{ (</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> , </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">  </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> }
   ; mor </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955;{ (f , g) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> &#955; h </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> f </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> h </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"> g }
   ; id </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> extensionality (&#955; {h} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> begin
        </span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> h </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block">
      </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216; leftId &#10217;
        h </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block">
      </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216; rightId &#10217;
        h
      </span><span class="org-block"><span class="haskell-operator">&#8718;</span></span><span class="org-block">)
   ; comp </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block">  &#955; {x y z </span><span class="org-block"><span class="writegood-duplicates">fg fg</span></span><span class="org-block">&#8217;} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">
       </span><span class="org-block"><span class="haskell-keyword">let</span></span><span class="org-block"> (f , g) </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> fg ; (f&#8217; , g&#8217;) </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> fg&#8217; </span><span class="org-block"><span class="haskell-keyword">in</span></span><span class="org-block"> extensionality (&#955; {h} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> begin
            (f&#8217; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> f) </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> h </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> (g </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> g&#8217;)
          </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216; assoc &#10217;
            f&#8217; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> (f </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> (h </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> (g </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> g&#8217;)))
          </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216; </span><span class="org-block"><span class="haskell-operator">&#10814;-</span></span><span class="org-block">cong&#8322; (</span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">sym assoc) &#10217;
            f&#8217; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> ((f </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> h) </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> (g </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> g&#8217;))
          </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216; </span><span class="org-block"><span class="haskell-operator">&#10814;-</span></span><span class="org-block">cong&#8322; (</span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">sym assoc) &#10217;
            f&#8217; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> ((f </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> h) </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> g) </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> g&#8217;
          </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216; </span><span class="org-block"><span class="haskell-operator">&#10814;-</span></span><span class="org-block">cong&#8322; (</span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">cong&#8322; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> assoc </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl) &#10217;
            f&#8217; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> (f </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> h </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> g) </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> g&#8217;
          </span><span class="org-block"><span class="haskell-operator">&#8718;</span></span><span class="org-block">)
     }
</span><span class="org-block-end-line">#+END_SRC
</span>The naming <span class="writegood-weasels">probably</span> comes from the algebra/monoid case where the functors are
monoid <span class="org-code">hom</span>-omorphisms. <span class="writegood-weasels">Some</span> prefer to use the name <span class="org-code">Mor</span>, short for <span class="org-code">mor</span>-phisms,
and that&#8217;s cool too. While Haskell programmers might call this the <span class="org-code">Reader</span> functor.

Usual notation for this functor is <span class="org-code">Hom</span>, but I like Fokkinga&#8217;s much better.
He uses <span class="org-code">(</span><span class="org-code"><span class="underline">&#10230;</span></span><span class="org-code">)</span> and writes <span class="org-code">(f &#10230; g) = &#955; h &#8226; f &#10814; h &#10814; g</span>
---the first argument of Hom is the first argument of the composition and the last
argument to Hom is the last argument of the resulting composition :-)
<span class="org-level-1">* &#119982;implicity &#119984;nderlies &#119966;omplexity</span>
<span class="org-drawer">:PROPERTIES:...
</span>
<span class="org-hide">*</span><span class="org-level-2">* Adjunctions Intro                                                 </span><span class="org-level-2"><span class="org-tag">:ignore:</span></span>
<span class="org-drawer">   :PROPERTIES:...
</span>
<span class="org-block-begin-line">#+BEGIN_QUOTE
</span><span class="org-quote">One way is to make it so &#119982;imple that there are obviously no deficiencies, and the other way is to
make it so &#119966;omplicated that there are no obvious deficiencies. The first method is far more
difficult. It demands the same skill, devotion, insight, and even inspiration as the discovery of
the </span><span class="org-quote"><span class="writegood-weasels">simple</span></span><span class="org-quote"> physical laws which &#119984;nderlie the complex phenomena of nature.

&#9472;</span><span class="org-quote"><span class="org-link"><a href="https://en.wikiquote.org/wiki/C._A._R._Hoare">C.A.R. Hoar</a><a href="https://en.wikiquote.org/wiki/C._A._R._Hoare">e</a></span></span><span class="org-quote">
</span><span class="org-block-end-line">#+END_QUOTE
</span>
<span class="org-meta-line">#+HTML: &lt;small&gt;</span>
<span class="org-block-begin-line">#+BEGIN_CENTER
</span>( The &#119966;omplex philosophy behinds games such as Chess and
<span class="org-link"><a href="http://playgo.to/iwtg/en/">Go</a></span> arise from <span class="writegood-weasels">some</span> &#119982;imple board game rules.
)
<span class="org-block-end-line">#+END_CENTER
</span><span class="org-meta-line">#+HTML: &lt;/small&gt;</span>

In this section we discuss what it means to be a &#8216;forgetful functor&#8217;?
--Also called an `&#119984;nderlying functor'.

The modifier &#8216;forgetful&#8217; is meaningful when there&#8217;s a notion of extra structure.
Indeed any functor <span class="italic">F : &#119966; &#10230; &#119982;</span> can <span class="writegood-passive-voice">be thought</span> of as forgetful by construing the objects of
&#119966; as objects of &#119982; with extra structure.
<span class="writegood-weasels">Mostly</span>: <span class="italic">You know it (to be forgetful) when you see it!</span>

<span class="org-hide">*</span><span class="org-level-2">* Being forgetful: from injections to faithful functors</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
A common example from set theory is the &#8216;inclusion&#8217; of a subset<span class="org-latex-and-related"> $A$ </span>of<span class="org-latex-and-related"> $B$,</span> the injection<span class="org-latex-and-related">
$&#953; : A &#8618; B : a &#8614; a$ </span>---it is essentially a form of &#8216;type casting&#8217;:<span class="org-latex-and-related"> $a &#8712; A$ </span>and<span class="org-latex-and-related"> $&#953; a \;=\; a &#8712; B$.</span>
Such injections &#8216;forget&#8217; the property that the argument is actually a member of a specified
subset. Indeed, construing sets as categories then functions becomes functors and inclusions
are then forgetful functors!

Since a functor <span class="italic">F</span> consists of two maps <span class="italic">(F&#8320;, F&#8321;) &#8788; (obj F, mor F)</span> and <span class="writegood-weasels">some</span> properties, we can speak about properties of the
functor and about properties of either of its maps.
The common definitions are a functor<span class="org-latex-and-related"> $F$ </span>is:
+ <span class="org-list-dt">faithful ::</span> If its operation on morphisms is <span class="italic">injective</span>, and it is
+ <span class="org-list-dt">full     ::</span> If morphisms starting and ending at <span class="italic">F</span> are a result of applying<span class="org-latex-and-related"> $F$;</span> <span class="org-macro">{{{newline}}}</span>
              i.e., <span class="italic">F&#8321;</span> is surjective <span class="italic">on</span> the image of <span class="italic">F&#8320;</span>: <span class="org-macro">{{{newline}}}</span>
             <span class="org-latex-and-related"> $&#8704; x,y &#8758; Obj \;&#8226;\; &#8704; g &#8758; F&#8320; x &#10230; F&#8320; y \;&#8226;\; &#8707; f &#8758; x &#10230; y \;&#8226;\; F&#8321; f = g$.</span>

Now we can generalize the previous example.
Every faithful functor <span class="italic">F : &#119966; &#10230; &#119967;</span> can <span class="writegood-passive-voice">be construed</span> as forgetful:
The &#119966;-maps can <span class="writegood-passive-voice">be embedded</span> into the &#119967;-maps, since F is faithful, and so can <span class="writegood-passive-voice">be thought</span> of
as a special sub-collection of the &#119967;-maps; then<span class="org-latex-and-related"> $F$ </span>&#8216;forgets&#8217; the property of being in this
special sub-collection.

Are faithful functors in abundance? Well any functor forgetting only axioms
(and/or structure) is faithful:

  0. Suppose &#119966; consists of &#119967; objects satisfying <span class="writegood-weasels">some</span> axioms and &#119967; maps preserving this structure.
  1. That is, &#119966; has pairs of &#119967; objects/morphisms with a proof that it satisfies the axioms/preserves-structure.
  2. Then <span class="org-latex-and-related">&#8220;$F : &#119966; &#10230; &#119967;$ </span>forgets only axioms&#8221; means<span class="org-latex-and-related"> $F\, (f, \mathsf{proof}) \;=\; f$.</span>
  3. Now given,<span class="org-latex-and-related"> $F (f , prf) = F (g , prf) \;&#8660;\; f = g \;&#8660;\; (f , prf) = (g , prf)$
</span>     -- equality does not (extensionally) depend on proof components.

     Hence, faithful :-)

    (Likewise for forgetting extra structure).

Of course we&#8217;re not saying all forgetful functors are necessarily faithful.
A <span class="writegood-weasels">simple</span> counterexample is the absolute value function:
Given a real number<span class="org-latex-and-related"> $x$ </span>it&#8217;s absolute value<span class="org-latex-and-related"> $&#8739;x&#8739;$ </span><span class="writegood-passive-voice">is obtained</span> by totally ignoring its sign
---of course<span class="org-latex-and-related"> $x$ </span>and<span class="org-latex-and-related"> $&#8739;x&#8739;$ </span>are equidistant from 0, the relation equidistant-from-0 is an equivalence
relation --Exercise!--, and so <span class="writegood-duplicates">the the</span> two are isomorphic in <span class="writegood-weasels">some</span> sense.

<span class="org-drawer">:Solution:...
</span>
Motivated by this, given a set<span class="org-latex-and-related"> $S$ </span>it&#8217;s size <span class="writegood-passive-voice">is denoted</span><span class="org-latex-and-related"> $&#8739; S &#8739;$ </span>which totally forgets about the
elements of the set ---of course it can <span class="writegood-passive-voice">be shown</span> that two sets are isomorphic precisely if they are
equinumerous.

I assume it is with these as motivators, <span class="writegood-weasels">some</span> people write<span class="org-latex-and-related"> $&#8739;&#183;&#8739;$ </span>for a forgetful functor.

( Exercise: A functor <span class="org-code">F : &#119966; &#8771; &#119967;</span> is (part of) an equivalence iff it is full,
faithful, and &#8216;&#8216;essentially surjective on objects&#8217;&#8217;:
 <span class="org-code">&#8704; D : Obj &#119967; &#8226; &#931; C : Obj &#119966; &#8226; F C &#8773; D</span> ---note the iso. )

<span class="org-hide">*</span><span class="org-level-2">* Of basis vectors</span>
<span class="org-drawer">   :PROPERTIES:...
</span>If you&#8217;ve ever studied abstract algebra ---the math with vector spaces--- then you may recall that
a collection of vectors &#8492; <span class="writegood-passive-voice">is called</span> a &#8216;basis&#8217; if every vector can <span class="writegood-passive-voice">be written</span> as a linear
combination of these vectors: For any vector<span class="org-latex-and-related"> $v$,</span> there are scalars<span class="org-latex-and-related"> $c&#8321;, &#8230;, c&#8345;$ </span>and vectors<span class="org-latex-and-related">
$b&#8321;, &#8230;, b&#8345;$ </span>in &#8492; with<span class="org-latex-and-related"> $v \;=\; c&#8321;&#183;b&#8321; + &#8943; + c&#8345;&#183;b&#8345;$.</span> That is, a basis is a collection of &#8216;building
blocks&#8217; for the vector space. Then any function<span class="org-latex-and-related"> $f$ </span>between basis sets immediately lifts to a
linear transformation (think vector space morphism)<span class="org-latex-and-related"> $F$ </span>as follows: Given a vector<span class="org-latex-and-related"> $v$,</span> since we
have a basis, we can express it as<span class="org-latex-and-related"> $c&#8321;&#183;b&#8321; + &#8943; + c&#8345;&#183;b&#8345;$,</span> now define<span class="org-latex-and-related">
$F v \;&#8788;\; c&#8321;&#183;(f\, b&#8321;) + &#8943; + c&#8345;&#183;(f\, b&#8345;)$.</span>

Sweet!

Thus, to define a complicated linear transformation of vector
spaces, it more than suffices to define a plain old <span class="writegood-weasels">simple</span> function of basis sets.
Moreover, by definition, such<span class="org-latex-and-related"> $F$ </span>maps basis vectors to basis vectors:<span class="org-latex-and-related"> $f \;=\; &#953; &#10814; F$ </span>where<span class="org-latex-and-related">
$&#953; : &#8492; &#8618; &#119985;$ </span>is the inclusion that realises basis vectors as just usual vectors in the vector
space &#119985;.  <span class="bold">Slogan:</span>
<span class="italic">Vector space maps </span><span class="italic"><span class="writegood-passive-voice">are determined</span></span><span class="italic"> by where they send their basis, and basis-vectors
</span><span class="italic"><span class="writegood-passive-voice">are preserved</span></span><span class="italic">.</span>

In the case of <span class="org-code">(List A, ++, [])</span> we may consider <span class="org-code">A</span> to be a &#8216;basis&#8217; of the monoid ---indeed,
every list can <span class="writegood-passive-voice">be written</span> as a linear combination of elements of <span class="org-code">A</span>, given list
<span class="org-code">[x&#8321;, &#8230;, x&#8345;] : List A</span> we have <span class="org-code">[x&#8321;, &#8230;, x&#8345;] = x&#8321; + &#8943; + x&#8345;</span> where <span class="org-code">x + y &#8788; [x] ++ [y]</span>.
Reasoning similarly as above, or if you have familiarity with <span class="org-code">foldr , reduce</span>, we have a <span class="bold">slogan:</span>
<span class="italic">Monoid homomorphisms from lists </span><span class="italic"><span class="writegood-passive-voice">are determined</span></span><span class="italic"> by where they send their basis and basis-vectors </span><span class="italic"><span class="writegood-passive-voice">are preserved</span></span><span class="italic">.</span>

Now the general case: <span class="italic"><span class="org-latex-and-related">$F &#8867; U$ </span></span><span class="italic">is a (free-forgetful) &#8216;adjunction&#8217;</span> means
for functors &#8216;forget&#8217;<span class="org-latex-and-related"> $U : &#119966; &#10230; &#119982;$ </span>and &#8216;free&#8217;<span class="org-latex-and-related"> $F : &#119982; &#8594; &#119966;$,</span> we have that
for a given &#119982;imple-object<span class="org-latex-and-related"> $S$ </span>there&#8217;s &#119982;imple-map<span class="org-latex-and-related"> $&#953; : S &#10230;_&#119982; U\,(F\, S)$ </span>---a way to realise &#8216;basis
vectors&#8217;--- such that for any &#119966;omplicated-object<span class="org-latex-and-related"> $C$ </span>and &#119982;imple-maps<span class="org-latex-and-related"> $&#966; : S &#10230;_&#119982; U\, C$,</span> there is a
unique &#119966;omplicated-map<span class="org-latex-and-related"> $&#934; : F\, S &#10230;_&#119966; C$ </span>that preserves the basis vectors:<span class="org-latex-and-related"> $&#966; = &#953; &#10814; U &#934;$.</span>

By analogy to the previous two cases, we may
consider<span class="org-latex-and-related"> $U\, X$ </span>to be a &#8216;basis&#8217;, and make the <span class="bold">slogan</span>:
&#119966;omplicated-maps from free objects <span class="writegood-passive-voice">are
determined</span> by where they send their basis and &#8216;basis vectors&#8217; <span class="writegood-passive-voice">are preserved</span>.

[ In more categorical lingo, one says<span class="org-latex-and-related"> $&#953;$ </span>is the &#8216;insertion of generators&#8217;.

  Question: Does the way we took<span class="org-latex-and-related"> $&#953;$ </span>in the previous graph show that it is a natural
  transformation<span class="org-latex-and-related"> $&#953; : \Id &#10230; F &#10814; U$?</span>
  ---The naturality just says that a &#8216;homomorphism&#8217;<span class="org-latex-and-related"> $F f$ </span>on the free object is
  <span class="writegood-weasels">completely</span> determined by what<span class="org-latex-and-related"> $f$ </span>does to the generators ;-)
]

<span class="org-hide">*</span><span class="org-level-2">* Of adjunctions</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
An adjunction<span class="org-latex-and-related"> $L &#8867; U$,</span> where the <span class="org-code">L</span>-ower adjoint is from &#119982; to &#119966; and the <span class="org-code">U</span>-pper adjoint is in
the opposite direction, lends itself to an elemntary interpretation if we consider &#119966;
to be <span class="writegood-weasels">some</span> universe of &#119966;omplicated items of study, while &#119982; to be a universe of &#119982;imple
items of study. Then adjointness implies that given a <span class="writegood-weasels">simple</span>-object<span class="org-latex-and-related"> $S$ </span>and a complicated-object<span class="org-latex-and-related">
$C$,</span> a <span class="writegood-weasels">simple</span>-map<span class="org-latex-and-related"> $X &#10230; U\, C$ </span>corresponds to a complicated-map<span class="org-latex-and-related"> $L\, S &#10230; C$.</span> To work with
complicated-maps it is more than enough to work with <span class="writegood-weasels">simple</span>-maps!

Formally this correspondence, saying<span class="org-latex-and-related"> $F : &#119966; &#10230; &#119967;$ </span>is adjoint to<span class="org-latex-and-related"> $G : &#119967; &#10230; &#119966;$,</span> written<span class="org-latex-and-related"> $F &#8867; G$,</span>
holds precisely when<span class="org-latex-and-related"> $(F &#8728; X &#10230; Y) \;&#8773;\; (X &#10230; G &#8728; Y)$ </span>in a functor category:

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#8867;</span></span><span class="org-block">&#8320;</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {i j} {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {i} {j}} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block"> (i </span><span class="org-block"><span class="haskell-operator">&#8845;</span></span><span class="org-block"> j)
 </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#8867;</span></span><span class="org-block">&#8320;</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">
    </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block">
      (</span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8728;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block">  </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">&#8345;&#8336;&#8348; </span><span class="org-block"><span class="haskell-constructor">Y</span></span><span class="org-block">)  </span><span class="org-block"><span class="haskell-operator">&#8773;</span></span><span class="org-block">  (</span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">&#8345;&#8336;&#8348; </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8728;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Y</span></span><span class="org-block">)  within  </span><span class="org-block"><span class="haskell-constructor">Func</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> &#7506;&#7510; </span><span class="org-block"><span class="haskell-operator">&#8855;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-constructor">&#119982;e&#120009;</span></span><span class="org-block">
   </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
     </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Fst</span></span><span class="org-block"> ; </span><span class="org-block"><span class="haskell-constructor">Y</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Snd</span></span><span class="org-block"> ; </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> opify </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">only changes types
</span></span><span class="org-block">
     </span><span class="org-block"><span class="haskell-keyword">infix</span></span><span class="org-block"> 5 </span><span class="org-block"><span class="haskell-keyword"><span class="writegood-duplicates">_</span></span></span><span class="org-block"><span class="haskell-operator"><span class="writegood-duplicates">&#10230;</span></span></span><span class="org-block"><span class="writegood-duplicates">&#8345;&#8336;&#8348;_
     </span></span><span class="org-block"><span class="haskell-keyword"><span class="writegood-duplicates">_</span></span></span><span class="org-block"><span class="haskell-operator"><span class="writegood-duplicates">&#10230;</span></span></span><span class="org-block"><span class="writegood-duplicates">&#8345;&#8336;&#8348;_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {i j} {</span><span class="org-block"><span class="haskell-constructor">&#119964;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {i} {j}} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">
            </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> &#7506;&#7510; </span><span class="org-block"><span class="haskell-operator">&#8855;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">) (</span><span class="org-block"><span class="haskell-constructor">&#119964;</span></span><span class="org-block"> &#7506;&#7510;) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> &#7506;&#7510; </span><span class="org-block"><span class="haskell-operator">&#8855;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-constructor">&#119964;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> &#7506;&#7510; </span><span class="org-block"><span class="haskell-operator">&#8855;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-constructor">&#119982;e&#120009;</span></span><span class="org-block">
     </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">&#8345;&#8336;&#8348;_ {i} {j} {</span><span class="org-block"><span class="haskell-constructor">&#119964;</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> pointwise (</span><span class="org-block"><span class="haskell-constructor">Hom</span></span><span class="org-block"> {i} {j} {</span><span class="org-block"><span class="haskell-constructor">&#119964;</span></span><span class="org-block">})
</span><span class="org-block-end-line">#+END_SRC
</span>Note that if we use Agda's built-in rewrite mechanism to add the rule,
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">{&#119966; &#119967; : Category {&#8467;&#8320;} {&#8467;&#8320;}} &#8594; Functor (&#119966; &#7506;&#7510;) (&#119967; &#7506;&#7510;) &#8801; Functor &#119966; &#119967;
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>then we might be able to get away without using <span class="org-code">opify</span>.

Anyhow, this says for any objects<span class="org-latex-and-related"> $X$ </span>and<span class="org-latex-and-related"> $Y$,</span> the collection of morphisms<span class="org-latex-and-related"> $(F\, A &#10230; B)$
</span>is isomorphic to the collection<span class="org-latex-and-related"> $(A &#10230; G\, B)$ </span>and naturally so in<span class="org-latex-and-related"> $A$ </span>and<span class="org-latex-and-related"> $B$.</span>

Unfolding it, we have
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"> record </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#8867;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> {i j i&#8217; j&#8217;} {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {i} {j}} {</span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {i&#8217;} {j&#8217;}}
        (</span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">) (</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">)
        </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block"> (j&#8217; </span><span class="org-block"><span class="haskell-operator">&#8845;</span></span><span class="org-block"> i&#8217; </span><span class="org-block"><span class="haskell-operator">&#8845;</span></span><span class="org-block"> j </span><span class="org-block"><span class="haskell-operator">&#8845;</span></span><span class="org-block"> i) </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">

   open </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> renaming (</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> to </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block">&#8322;</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">)
   open </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> renaming (</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> to </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block">&#8321;</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">)
   field
     </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">&#8216;left-adjunct&#8217;  L &#8776; &#8970;  and  &#8216;right-adjunct&#8217;  r &#8776; &#8968;
</span></span><span class="org-block">     &#8970;</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">&#8971; </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Y</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">   obj </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Y</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">   </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">   </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> obj </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Y</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">
     &#8968;</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">&#8969; </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Y</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">   </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> obj </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Y</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">   </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">   obj </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Y</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">

     </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Adjuncts are inverse operations
</span></span><span class="org-block">     lid </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Y</span></span><span class="org-block">} {d </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> obj </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Y</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> &#8968; &#8970; d &#8971; &#8969; </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> d
     rid </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Y</span></span><span class="org-block">} {c </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> obj </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Y</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> &#8970; &#8968; c &#8969; &#8971; </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> c

     </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">That for a fixed argument, are natural transformations between Hom functors
</span></span><span class="org-block">     lfusion </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">C</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">D</span></span><span class="org-block">} {f </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} {&#968; </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> obj </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">C</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">} {g </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">C</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">D</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">}
             </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">  &#8970; mor </span><span class="org-block"><span class="haskell-constructor"><span class="writegood-duplicates">F</span></span></span><span class="org-block"><span class="writegood-duplicates"> f</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block">&#8322; &#968; </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block">&#8322; g &#8971;  </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">  f </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block">&#8321; &#8970; &#968; &#8971; </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block">&#8321; mor </span><span class="org-block"><span class="haskell-constructor"><span class="writegood-duplicates">G</span></span></span><span class="org-block"><span class="writegood-duplicates"> g</span></span><span class="org-block">
     rfusion </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">C</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">D</span></span><span class="org-block">} {f </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} {&#968; </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> obj </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">C</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} {g </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">C</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">D</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">}
             </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">  &#8968; f </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block">&#8321; &#968; </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block">&#8321; mor </span><span class="org-block"><span class="haskell-constructor"><span class="writegood-duplicates">G</span></span></span><span class="org-block"><span class="writegood-duplicates"> g</span></span><span class="org-block"> &#8969;  </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">  mor </span><span class="org-block"><span class="haskell-constructor"><span class="writegood-duplicates">F</span></span></span><span class="org-block"><span class="writegood-duplicates"> f</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block">&#8322; &#8968; &#968; &#8969; </span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block">&#8322; g
</span><span class="org-block-end-line">#+END_SRC
</span>
<span class="comment"># It is interesting to note that here if we omit the types of A, B, C, D in rfusion</span>
<span class="comment"># they can </span><span class="comment"><span class="writegood-passive-voice">be inffered</span></span><span class="comment"> but that takes too much time for my taste, so I've annotated the types everywhere.</span>
<span class="comment"># The more likely to be more costly in terms of resolution time is the composition operation.</span>

This is easier for verifying an adjunction, while the former is easier for remembering and understanding what an adjunction actually is.

<span class="org-drawer">:RecallingTypes:...
</span>
As the slogan goes &#8216;adjunctions are everywhere&#8217;.
They can <span class="writegood-passive-voice">be said</span> to capture the notions of optimization and efficiency, but also that of simplicity.

For example, the supremum of a function <span class="writegood-passive-voice">is defined</span> to be an upper bound of its image set and the least such bound.
Formally, this definition carries a <span class="writegood-weasels">few</span> quantifiers and so a bit lengthy.
More elegantly, we can say the supremum operation <span class="writegood-passive-voice">is left</span>-adjoint to the constant function: <span class="org-latex-and-related">\[ \mathsf{sup} &#8867; &#119974; \]</span>
which means <span class="org-latex-and-related">\[ &#8704; z &#8226;\qquad \mathsf{sup}\, f \,&#8804;\, z \quad&#8660;\quad f \overset{.}{&#8804;} &#119974;\, z\]</span>
Where<span class="org-latex-and-related"> $&#119974;\, x\, y \,=\, x$ </span>and the<span class="org-latex-and-related"> $\overset{.}{&#8804;}$ </span>on the right is the point-wise ordering on functions.
This formulation of supremum is not only shorter to write but easier to use in calculational proofs.

For the efficiency bit, recall that it is efficient to specify a &#119982;imple-map, then use the adjuction, to obtain
a &#119966;omplicated-map. Recall in the last paragraph how we define the super complicated notion of supremum of a function
in terms of the most elementary constant function!

Adjunctions over poset categories <span class="writegood-passive-voice">are called</span> &#8216;Galois connections&#8217; and a good wealth of
material on them can <span class="writegood-passive-voice">be found</span> in nearly any writing by <span class="org-link"><a href="http://www.cs.nott.ac.uk/~psarb2/papers/papers.html">Backhouse et. al.</a></span>,
while a <span class="writegood-weasels">very</span> accessible introduction is by <span class="org-link"><a href="http://www.cs.nott.ac.uk/~psarb2/MPC/galois.ps.gz">Aarts</a></span>,
and there is also an Agda mechanisation by <span class="org-link"><a href="http://relmics.mcmaster.ca/RATH-Agda/AContext-2.1.pdf">Kahl &amp; Al-hassy</a></span>.

Regarding forgetful functors:
Generally, but not always, forgetful functors are faithful and have left adjoints
---because the notion of &#8216;forget&#8217; ought to have a corresponding notion of &#8216;free&#8217;.
An exception to this is the category of fields, which has a forgetful functor to the
category of sets with no left adjoint.
<span class="comment"># [Source: Wikipedia]</span>

<span class="org-hide">*</span><span class="org-level-2">* Adjunctions and Representable Functors</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
Another awesome thing about adjunctions <span class="org-code">L &#8867; U</span> is that they give us &#8216;representable functors&#8217;,
  a.k.a. &#8216;the best kind of functors&#8217;, when terminal objects exist.

  - An object <span class="org-code">&#120793;</span> is &#8216;terminal&#8217; if for any object <span class="org-code">A</span> there is a unique morphism <span class="org-code">! {A} : A &#10230; &#120793;</span>.
    In &#119982;&#8495;&#120009; we have <span class="org-code">(A &#10230; &#120793;) &#8773; &#120793;</span> and <span class="org-code">(&#120793; &#10230; A) &#8773; A</span>.

  - Specialising the adjunction, where <span class="org-code">U : &#119966; &#10230; &#119982;e&#120009;</span>, to
    a given set <span class="org-code">A</span> and <span class="org-code">&#120793;</span> we obtain <span class="org-code">(L &#120793; &#10230; A) &#8773; (&#120793; &#10230; U A) &#8773; U A</span> and so one says
    &#8216; <span class="org-code">U</span> <span class="writegood-passive-voice">is represented</span> by <span class="org-code">L &#120793;</span> &#8217;.

  - In particular, if &#119966; <span class="writegood-passive-voice">is built</span> on &#119982;&#8495;&#120009; by adding <span class="writegood-weasels">some</span> structure
    and we <span class="writegood-passive-voice">are interested</span> in utilising the elements of an object <span class="org-code">A</span>
    then it suffices to utilise the maps <span class="org-code">L &#120793; &#10230; A</span>.

In the case of a free-forgetful adjunction, this says that
  <span class="italic">a forgetful functor </span><span class="italic"><span class="writegood-passive-voice">is represented</span></span><span class="italic"> by the free object with generator </span><span class="italic"><span class="org-code">&#120793;</span></span><span class="italic">.</span>

For example, for monoids the one-point monoid is the terminal object: <span class="org-code">&#120793; &#8788; ({*}, &#8853;, *)</span> with <span class="org-code">x &#8853; y &#8788; &#8902;</span>.
Then every monoid-homomorphism from <span class="org-code">&#120793;</span> just picks out an element of the carrier of a monoid and so
<span class="org-code">(&#120793; &#10230; M) &#8773; &#119984; M</span> where <span class="org-code">&#119984;</span> is the forgetful functor for monoids mentioned in the introduction.

<span class="org-hide">*</span><span class="org-level-2">* Concluding remarks</span>
<span class="org-drawer">   :PROPERTIES:...
</span>A final note about &#8216;free objects&#8217; ---arising from an adjoint to a forgetful functor.

<span class="bold">&#8216;&#8216;The free object is generic&#8217;&#8217;</span>: The only truths provable for the free
object are precisely those that hold for every complicated-object.

(Begin squinting eyes)
<span class="org-macro">{{{newline}}}</span>
This follows from the
definition of adjunction which says we can construct a unique morphism between complicated-objects
from a <span class="writegood-weasels">simple</span>-map and by naturality we may transport any proof for the free object to any
complicated object.
<span class="org-macro">{{{newline}}}</span>
(Feel &#8216;free&#8217; to stop squinting your eyes)


For futher reading consider reading the adjoint article at <span class="org-link"><a href="http://www.comicbooklibrary.org/articles/Left_adjoint">the comic book library</a></span>
and for more on the adjective &#8216;forgetful&#8217; see <span class="org-link"><a href="https://ncatlab.org/nlab/show/forgetful+functor">ncatlab</a></span> or <span class="org-link"><a href="http://mathworld.wolfram.com/ForgetfulFunctor.html">mathworld</a></span>
A nice list of common free objects can <span class="writegood-passive-voice">be found</span> on <span class="org-link"><a href="https://en.wikipedia.org/wiki/Free_object#List_of_free_objects">wikipedia</a></span>.

<span class="comment"># &#10214; Challenge; true or false: For forgetful $U : &#119966; &#10230; &#119982;&#8495;&#120009;$,</span>
<span class="comment"># a free functor exists when &#119966; is a monad category over &#119982;&#8495;&#120009;? &#10215;</span>

You might be asking,
 <span class="italic">musa, when am I ever going to encounter this in daily life? In a popular setting?</span>
This concept is everywhere, even inclusions as mentioned earlier are an
instance. For the second question, enjoy listening to
<span class="org-link"><a href="https://www.youtube.com/watch?v=BipvGD-LCjU">this lovely musical group</a></span> --they use the words &#8216;forgetful functors&#8217; ;)

The remainder of this document can <span class="writegood-passive-voice">be seen</span> as one fully-worked out example of constructing a
free functor for the forgetful &#119984; defined above from &#119966;&#119990;&#120009; to &#119970;&#120007;&#119990;&#120005;&#119997;.

<span class="org-hide">*</span><span class="org-level-2">* </span><span class="org-special-keyword">COMMENT</span><span class="org-level-2"> Free first-order logics                               </span><span class="org-level-2"><span class="org-tag">:Abandoned:</span></span>
<span class="org-drawer">   :PROPERTIES:...
</span>
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">module RSD where

  data &#120793; : Set where &#8902; : &#120793;

  open import Data.Vec renaming (_&#8759;_ to _,,_) -- , already in use for products :/

  data Term (&#119982; : Signature) (Carrier : Set) (Var : Set) : Set where
    var : Var &#8594; Term &#119982; Carrier Var
    con : Carrier &#8594; Term &#119982; Carrier Var
    app : (i : Fin ar) &#8594; Vec (Term &#119982; Carrier Var) (lookup i ar) &#8594; Term &#119982; Carrier Var
    -- ~app i [t&#8321;, &#8230;, t&#8342;]~ read as: apply i-th function-symbol ~f&#7522;~ to ~k = arity (f&#7522;)~ terms ~t&#8321;, &#8230;, t&#8342;~

  infix 10 _&#8776;</span><span class="custom"><span class="writegood-duplicates">_
  _</span></span><span class="custom">&#8776;_ : {A B : Set} &#8594; A &#8594; B &#8594; A &#215; B
  _&#8776;_ = _,_

  record Logic (&#119982; : Signature) (Carrier : Set) (Var : Set) : Set where
    field
      #Eqns : &#8469;
      eqns : Vec ((Term &#119982; Carrier Var) &#215; (Term &#119982; Carrier Var)) #Eqns

  -- use integers as varaibles
  MyVars = &#8469;
  x y z : MyVars
  x = 0
  y = 1
  z = 2
  -- alternative is to parameterise module by a universe of variables.

  MonoidThry : {X : Set} &#8594; Logic MonSig X MyVars
  MonoidThry {X} = record { #Eqns = 3 ;
    eqns = &#949; &#183; var x &#8776; var x
      ,, var x &#183; &#949; &#8776; var x
      ,, (var x &#183; var y) &#183; var z &#8776; var x &#183; (var y &#183; var z)
      ,, [] }
    where
      -- the function symbols
      u = from&#8469;&#8804; {0} {2} (s&#8804;s z&#8804;n)
      m = from&#8469;&#8804; {1} {2} (s&#8804;s (s&#8804;s z&#8804;n))

      -- conventional monoid notation
      &#949; : Term MonSig X MyVars
      &#949; = app u []
      _&#183;_ : (l r : Term MonSig X MyVars) &#8594; Term MonSig X MyVars
      _&#183;_ = &#955; l r &#8594; app m (l ,, r ,, [])
</span><span class="org-block-end-line">#+END_EXAMPLE
</span><span class="org-level-1">* Designing Paths</span>
<span class="org-drawer">:PROPERTIES:...
</span>
<span class="comment"># Path definition</span>

<span class="org-block-begin-line">#+BEGIN_CENTER
</span><span class="italic">The &#8220;right&#8221; definition is hard to obtain!</span>
<span class="org-block-end-line">#+END_CENTER
</span>
<span class="org-hide">*</span><span class="org-level-2">* Paths Intro                                                       </span><span class="org-level-2"><span class="org-tag">:ignore:</span></span>
<span class="org-drawer">   :PROPERTIES:...
</span>
We can now define a &#8216;path&#8217; of length <span class="org-code">n</span> in a graph <span class="org-code">G</span> to be a graph-map
<span class="org-code">[ n ] &#10230; G</span>.

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="haskell-constructor">Path</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#8469;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block"> (&#8467;suc &#8467;&#8320;)
</span><span class="org-block"><span class="haskell-constructor">Path</span></span><span class="org-block">&#8320; n </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> [ n ]&#8320; </span><span class="org-block"><span class="haskell-constructor">&#119970;</span></span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">
</span><span class="org-block-end-line">#+END_SRC
</span>
Unfolding the definition of graph-morphisms, this just says that a path of length <span class="org-code">n</span>
consists of a sequence <span class="org-code">[v&#8320;, v&#8321;, v&#8322;,  &#8230;, v&#8345;]</span> of vertices of <span class="org-code">G</span> and a sequence <span class="org-code">[e&#8320;, e&#8321;, &#8230;, e&#8345;&#8331;&#8321;]</span>
of edges of <span class="org-code">G</span> with typing <span class="org-code">e&#7522; : v&#7522; &#10230; v&#7522;&#8330;&#8321;</span>.

The definition is pretty slick! However, as the name suggests, perhaps we can concatenate paths
and it&#8217;s not at all clear how to do this for the vertex- and edge- morphisms of the graph-maps
involved, whereas it&#8217;s immediately clear how to do this with sequences: We just concatenate the
sequences and ensure the result is coherent.

Since the vertices can <span class="writegood-passive-voice">be obtained</span> from the edges via <span class="org-code">src</span> and <span class="org-code">tgt</span>, we can dispense with them
and use the definition as outlined above.

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="haskell-definition">open</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">import</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Data.Vec</span></span><span class="org-block"> using (</span><span class="org-block"><span class="haskell-constructor">Vec</span></span><span class="org-block"> ; lookup)

</span><span class="org-block"><span class="haskell-definition">record</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Path</span></span><span class="org-block">&#8321; (n </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#8469;</span></span><span class="org-block">) (</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block">&#8320;) </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block"> (&#8467;suc &#8467;&#8320;) </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
  open </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block">&#8320;
  field
    edges     </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Vec</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">E</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">) (suc n)
    coherency </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> {i </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Fin</span></span><span class="org-block"> n} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> tgt </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> (lookup (` i) edges) </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> src </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> (lookup (fsuc i) edges)
</span><span class="org-block-end-line">#+END_SRC
</span>That is, edges <span class="org-code">[e&#8320;, &#8230;, e&#8345;]</span> with coherency <span class="org-code">tgt e&#7522; &#8801; src e&#7522;&#8330;&#8321;</span>.

Great, we&#8217;ve cut the definition of <span class="org-code">Path&#8320;</span> in half but that fact that we get a raw list of edges
and then need coherency to ensure that it is a well-formed path is still not terribly lovely.
After all, we&#8217;re in Agda, we&#8217;re among kings, we should be able to form the list in such a way that
the end result is a path. Let&#8217;s do that!

Enough of this repetition, let us fix a graph <span class="org-code">G</span>,
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Path</span></span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">definition</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">2 (</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block">&#8320;) </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
  open </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">

  mutual
    </span><span class="org-block"><span class="haskell-keyword">data</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">Path</span></span><span class="org-block">&#8322; </span><span class="org-block"><span class="haskell-type">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">Set</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
      </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">   </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Path</span></span><span class="org-block">&#8322;
      cons </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> (v </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">) (e </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">E</span></span><span class="org-block">) (ps </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Path</span></span><span class="org-block">&#8322;) (s </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> v </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> src e) (t </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> tgt e </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> head&#8322; ps) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Path</span></span><span class="org-block">&#8322;

    head&#8322; </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Path</span></span><span class="org-block">&#8322; </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">
    head&#8322; (v </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> v
    head&#8322; (cons v e p s t) </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> v
</span><span class="org-block-end-line">#+END_SRC
</span>
Defining paths for the parallel-pair approach to graphs leaves us with the need to carry
proofs around, and this is a tad too clunky in this case. Let's try yet again.

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Path</span></span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">definition</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">3 (</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">

  open </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">

  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">handy dandy syntax
</span></span><span class="org-block">  </span><span class="org-block"><span class="haskell-keyword">infixr</span></span><span class="org-block"> 5 cons
  syntax cons v ps e </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> v </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> ps </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">v goes, by e, onto path ps
</span></span><span class="org-block">
  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">we want well-formed paths
</span></span><span class="org-block">  mutual
    </span><span class="org-block"><span class="haskell-keyword">data</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">Path</span></span><span class="org-block">&#8323; </span><span class="org-block"><span class="haskell-type">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">Set</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
      </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">   </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> (v </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Path</span></span><span class="org-block">&#8323;
      cons </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> (v </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">) (ps </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Path</span></span><span class="org-block">&#8323;) (e </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> v </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> head&#8323; ps) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Path</span></span><span class="org-block">&#8323;

    head&#8323; </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Path</span></span><span class="org-block">&#8323; </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">
    head&#8323; (v </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> v
    head&#8323; (v </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> ps) </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> v

  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">motivation for the syntax declaration above
</span></span><span class="org-block">  example </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> (v&#8321; v&#8322; v&#8323; </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">) (e&#8321; </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> v&#8321; </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> v&#8322;) (e&#8322; </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> v&#8322; </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> v&#8323;) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Path</span></span><span class="org-block">&#8323;
  example v&#8321; v&#8322; v&#8323; e&#8321; e&#8322; </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> v&#8321; </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e&#8321; ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> v&#8322; </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e&#8322; ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> v&#8323; </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">

  end&#8323; </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Path</span></span><span class="org-block">&#8323; </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">
  end&#8323; (v </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> v
  end&#8323; (v </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> ps) </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> end&#8323; ps

  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">typed paths; squigarrowright
</span></span><span class="org-block">  record </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> (x y </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
    field
      path   </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Path</span></span><span class="org-block">&#8323;
      start  </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> head&#8323; path </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> x
      finish </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> end&#8323; path  </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> y
</span><span class="org-block-end-line">#+END_SRC
</span>This seems great, but there&#8217;s always room for improvement:


- Since the <span class="org-code">cons</span> constructor's third argument depends on its first, we must
  use a syntax declaration to get the desired look. Such aesthetic is not only
  pleasing but reminiscent of diagrammatic paths;
  moreover, it&#8217;s guaranteed to be an actual path and not just an
  alternating lists of vertices and edges.
  Using the clunky <span class="org-code">Path&#8322;</span>, we&#8217;d write
<span class="org-block-begin-line">  #+BEGIN_EXAMPLE
</span><span class="custom">  v&#8321; &#10230;[ v&#8321;&#8776;se&#8321; , e&#8321; , te&#8321;&#8776;v&#8322; ]&#10230; v&#8322; &#10230;[ v&#8322;&#8776;se&#8322; , e&#8322; , te&#8322;&#8776;v&#8323; ]&#10230; v&#8323; !
  where
  syntax cons v e ps s t = v &#10230;[ s , e , t ]&#10230; ps
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>  yuck!

  Finally, the syntax-declaration does not make the emacs agda-mode auto-case using
  the syntax, and so I have to write it out by hand, each time I want to use the syntax.

- Again since <span class="org-code">cons</span>'s third argument depends on the second argument, we need a mutual
  definition to extract the item of the dependence. Perhaps if we embed this item at
  the type level we may avoid the need of an auxiliary mutually-defined function.

- By defining what the start and finish of a path are, we can assign types to it.
  However, this approach is reminiscent of the parallel-pair approach to graphs,
  as in <span class="org-code">Graph&#8320;</span>, which we argued is less preferable to the typed-approach to graphs.
  Perhaps defining paths with types by default, we can reap the benefits and simplicity
  of the typed-approach to graphs.

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">TypedPaths</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">

  open </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> hiding(</span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">)
  open </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block">   using (</span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">)

  </span><span class="org-block"><span class="haskell-keyword">data</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
    </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">      </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> x
    </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> x {y &#969;} (e </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> y) (ps </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> y </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> &#969;) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> &#969;
</span><span class="org-block-end-line">#+END_SRC
</span>
One might think that since we can write
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">  src : {x y : V G} (e : x &#10230; y) &#8594; V G
  src {x} {y} e = x
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>we can again ignore vertices and it suffices to just keep a coherent list of edges.
Then what is an empty path at a vertex? This&#8217; enough to keep vertices around
---moreover, the ensuing terms look like diagrammatic paths! Cool!

<span class="org-block-begin-line">#+BEGIN_CENTER
</span>Finding this definitional <span class="italic">form</span> was a major hurdle in this endeavour.
<span class="org-block-end-line">#+END_CENTER
</span>
<span class="org-hide">*</span><span class="org-level-2">* Aside: An Adjunction between &#119982;&#8495;&#120009; and &#119966;&#119990;&#120009;</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
With paths in hand, we can now consider a neat sequence of <span class="org-link"><a href="https://math.stackexchange.com/questions/1640298/coforgetful-functors">exercises</a></span> :-)

0. Show that graphmaps preserve paths: <span class="org-code">(f : G &#10230; H)  &#8594; x &#8669; y &#8594; f&#7525; x &#8669; f&#7525; y</span>;
   this is nothing more than type-preservation for <span class="org-code">f</span> to be a functor <span class="org-code">&#119979;G &#10230; &#119979;H</span> ;)

   Hint: This is <span class="org-code">lift</span> from the next section.

1. Define
<span class="org-block-begin-line">  #+BEGIN_EXAMPLE
</span><span class="custom">a connected b  &#8801;  (a &#8669; b) &#8846; (b &#8669; a)  --  path &#8220;between&#8221; a and b; not &#8216;from a to b&#8217;.
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>
2. This is an equivalence relation whose equivalence classes <span class="writegood-passive-voice">are called</span> <span class="italic">the connected components of G</span>;
   denote them by <span class="org-code">&#119974;G</span>.

3.  For any category <span class="org-code">&#119966;</span>, define <span class="org-code">&#119974; &#119966; &#8788; &#119974; (&#119984;&#8320; &#119966;)</span> which is a subcategory of <span class="org-code">&#119966;</span>.

4.  Phrase the connected components subcategory using a universal property,
   thereby avoiding the need for quotient types.

5. Since graphmaps preserve paths, every graph map can <span class="writegood-passive-voice">be extended</span> to connected components,
  <span class="org-code">&#119974;f : &#119974;G &#10230; &#119974;H : (connected component of x) &#8614; (connected component of f&#7525; x)</span>.

7. Hence, we have a functor <span class="org-code">&#119974; : Graph &#10230; Set</span>.

8. Then there is a natural transformation <span class="org-code">&#119985; &#10230; &#119974;</span>, where &#119985; is the vertices functor.

  Hint: Such a transformation means we can realise vertices as connected components and this suggests
  taking assigning a vertex to the connected-component block that contains it.

<span class="org-drawer">  :Solution:...
</span>
  yeah!

Finally, if we let <span class="org-code">&#119967; : &#119982;&#8495;&#120009; &#8594; &#119966;&#119990;&#120009;</span> be the free category functor that associates each set with
the discrete category over it, then we have <span class="org-code">&#119974;</span> is the associated forgetful functor.

<span class="org-drawer">:Solution:...
</span>
<span class="org-hide">*</span><span class="org-level-2">* Equality Combinators for Paths</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
Here's a handy-dandy combinator for forming certain equality proofs of paths.
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Preprend preserves path equality
</span></span><span class="org-block">  </span><span class="org-block"><span class="haskell-operator">&#10230;-&#8801;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{x y &#969;} {e </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> y} {ps qs </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> y </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> &#969;}
      </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> ps </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> qs </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> ps) </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> (x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> qs)
  </span><span class="org-block"><span class="haskell-operator">&#10230;-&#8801;</span></span><span class="org-block"> {x} {y} {&#969;} {e} {ps} {qs} eq </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">cong (&#955; r </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> r) eq
</span><span class="org-block-end-line">#+END_SRC
</span>Less usefully, we leave as exercises:
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">  edges : &#8704; {x &#969;} (p : x &#8669; &#969;) &#8594; List (&#931; s &#8758; V G &#8226; &#931; t &#8758; V G &#8226; s &#10230; t)
  edges = {! exercise !}

  path-eq : &#8704; {x y} {p q : x &#8669; y} &#8594; edges p &#8801; edges q &#8594; p &#8801; q
  path-eq = {! exercise !}
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>Given time, <span class="org-code">path-eq</span> could be rewritten so as to be more <span class="writegood-weasels">easily</span> applicable.
For now, two path equality proofs occur in the document and both <span class="writegood-passive-voice">are realised</span> by
quick-and-<span class="writegood-weasels">easy</span> induction.

<span class="org-drawer">:Solution:...
</span>
<span class="org-hide">*</span><span class="org-level-2">* Category of paths over a graph</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
Now we turn back to the problem of <span class="org-link"><a href="https://english.stackexchange.com/a/125659/327685">catenating</a></span> two paths.
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">  </span><span class="org-block"><span class="haskell-keyword">infixr</span></span><span class="org-block"> 5 </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">++</span></span><span class="org-block"><span class="haskell-keyword"><span class="writegood-duplicates">_</span></span></span><span class="org-block"><span class="writegood-duplicates">

  </span></span><span class="org-block"><span class="haskell-keyword"><span class="writegood-duplicates">_</span></span></span><span class="org-block"><span class="haskell-operator">++</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{x y z} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> y </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> y </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> z </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> z
  x </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">++</span></span><span class="org-block"> q           </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> q                         </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">left unit
</span></span><span class="org-block">  (x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> p) </span><span class="org-block"><span class="haskell-operator">++</span></span><span class="org-block"> q </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> (p </span><span class="org-block"><span class="haskell-operator">++</span></span><span class="org-block"> q)     </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">mutual-associativity
</span></span><span class="org-block-end-line">#+END_SRC
</span>Notice that <span class="writegood-duplicates">the the</span> base case indicate that <span class="org-code">!</span> forms a left-unit for <span class="org-code">++</span>,
while the inductive case says that path-formation associates with path catenation.
Both observations also hold for the definition of list catenation ;-)

If we had not typed our paths, as in <span class="org-code">Path&#8322;</span>, we would need to carry around a
proof that paths are compatible for concatenation:
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">  catenate : (p q : Path) (coh : end p &#8801; head q) &#8594; Path
  syntax catenate p q compatibility = p ++[ compatibility ] q
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>Even worse, to show <span class="org-code">p </span><span class="org-code"><span class="custom-1">+[ coh ] q &#8801; p +</span></span><span class="org-code">[ coh&#8217; ] q</span> we need to invoke proof-irrelevance of
identity proofs to obtain <span class="org-code">coh &#8801; coh&#8217;</span>, each time we want such an equality! Moving the proof
obligation to the type level removes this need.

As can <span class="writegood-passive-voice">be seen</span>, being type-less is a terrible ordeal.

Just as the first clause of <span class="org-code">_++_</span> indicates <span class="org-code">_!</span> is a left unit,
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">  leftId </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {x y} {p </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> y} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">++</span></span><span class="org-block"> p </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> p
  leftId </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl
</span><span class="org-block-end-line">#+END_SRC
</span>Is it also a right identity?
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">  rightId </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {x y} {p </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> y} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> p </span><span class="org-block"><span class="haskell-operator">++</span></span><span class="org-block"> y </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> p
  rightId {x} {</span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block">x} {</span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block">x </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl
  rightId {x} {y } {</span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block">x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> ps} </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">cong (&#955; q </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> q) rightId
</span><span class="org-block-end-line">#+END_SRC
</span>
Is this operation associative?
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">  assoc </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{x y z &#969;} {p </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> y} {q </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> y </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> z} {r </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> z </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> &#969;}
        </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (p </span><span class="org-block"><span class="haskell-operator">++</span></span><span class="org-block"> q) </span><span class="org-block"><span class="haskell-operator">++</span></span><span class="org-block"> r </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> p </span><span class="org-block"><span class="haskell-operator">++</span></span><span class="org-block"> (q </span><span class="org-block"><span class="haskell-operator">++</span></span><span class="org-block"> r)
  assoc {x} {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block">x </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl
  assoc {x} {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block">x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> ps} {q} {r} </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">cong (&#955; s </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> s) (assoc {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> ps})
</span><span class="org-block-end-line">#+END_SRC
</span>
Hence, we&#8217;ve shown that the paths over a graph <span class="org-code">G</span> constitute a category! Let&#8217;s call it <span class="org-code">&#119979; G</span>.

<span class="org-hide">*</span><span class="org-level-2">* The &#119979;ath to freedom</span>
<span class="org-drawer">   :PROPERTIES:...
</span>In the last section, we showed that the paths over a graph make a category,
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block">
</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">let</span></span><span class="org-block"> open </span><span class="org-block"><span class="haskell-constructor">TypedPaths</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">in</span></span><span class="org-block">
    record
      { </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block">     </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph.V</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">
      ; </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">     </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">
      ; </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">     </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">++</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">
      ; assoc   </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; {x y z &#969; p q r} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> assoc {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> p}
      ; </span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block">      </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; {x} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">
      ; leftId  </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> leftId
      ; rightId </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> rightId
      }
</span><span class="org-block-end-line">#+END_SRC
</span>
Can we make <span class="org-code">&#119979;</span> into a functor by defining it on morphisms?
That is, to lift graph-maps to category-maps, i.e., functors.

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">GraphMap</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">) (</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">)
</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8321; {</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">} f </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> record
    { obj  </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> ver f
    ; mor  </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> amore
    ; id   </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl
    ; comp </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; {x} {y} {z} {p} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> comp {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> p}
    }
    </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
      open </span><span class="org-block"><span class="haskell-constructor">TypedPaths</span></span><span class="org-block"> &#10627;</span><span class="org-block"><span class="haskell-operator">...</span></span><span class="org-block">&#10628; public
      </span><span class="org-block"><span class="haskell-keyword">instance</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">G'</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">Graph</span></span><span class="org-block"> ; </span><span class="org-block"><span class="haskell-constructor">G'</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">
               </span><span class="org-block"><span class="haskell-constructor">H'</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block"> ; </span><span class="org-block"><span class="haskell-constructor">H'</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">

      amore </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> {x y </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph.V</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">  x </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> y </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (ver f x) </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> (ver f y)
      amore (x </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> ver f x </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">
      amore (x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> p) </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> ver f x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ edge f e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> amore p

      comp </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> {x y z </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph.V</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">} {p </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> y} {q </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> y </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> z}
          </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">  amore (p </span><span class="org-block"><span class="haskell-operator">++</span></span><span class="org-block"> q)  </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">  amore p </span><span class="org-block"><span class="haskell-operator">++</span></span><span class="org-block"> amore q
      comp {x} {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block">x </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl    </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">since ! </span></span><span class="org-block"><span class="comment"><span class="writegood-passive-voice">is left</span></span></span><span class="org-block"><span class="comment"> unit of ++
</span></span><span class="org-block">      comp {x} {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block">x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> ps} </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;-&#8801;</span></span><span class="org-block"> (comp {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> ps})
</span><span class="org-block-end-line">#+END_SRC
</span>Sweet!

With these two together, we have that <span class="org-code">&#119979;</span> is a functor.

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block">
</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> record { obj   </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8320;
            ; mor  </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8321;
            ; id   </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; {</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> funcext </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl (id &#10627; </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> &#10628;)
            ; comp </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> funcext </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl comp
            }
    </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
      open </span><span class="org-block"><span class="haskell-constructor">TypedPaths</span></span><span class="org-block"> &#10627;</span><span class="org-block"><span class="haskell-operator">...</span></span><span class="org-block">&#10628;
      open </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block">   &#10627;</span><span class="org-block"><span class="haskell-operator">...</span></span><span class="org-block">&#10628;

      </span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block">   </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block">
      </span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block">

      id </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> &#10627; </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> &#10628; {x y} {p </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> y}
        </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">   mor (</span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">}) p  </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">  mor (</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8321; (</span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block">)) p
      id {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl
      id {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> ps} </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;-&#8801;</span></span><span class="org-block"> (id {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> ps})

      comp </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">K</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block">} {f </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">GraphMap</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">} {g </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">GraphMap</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">K</span></span><span class="org-block">}
           </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> {x y </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph.V</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">} {p </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> TypedPaths._</span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> x y}
           </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">  mor (</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8321; f </span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8321; g) p  </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">  mor (</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8321; (f </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> g)) p
      comp {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl
      comp {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> ps} </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;-&#8801;</span></span><span class="org-block"> (comp {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> ps})
</span><span class="org-block-end-line">#+END_SRC
</span>
It seemed prudent in this case to explicitly delimit where the compositions lives
---this is for clarity, since Agda can quickly resolve the appropriate category instances.

Exercise: Show that we have a natural transformation <span class="org-code">Id &#10230; &#119984; &#8728; &#119979;</span>.
<span class="org-level-1">* Free at last</span>
<span class="org-drawer">:PROPERTIES:...
</span>
<span class="org-hide">*</span><span class="org-level-2">* Free Intro                                                        </span><span class="org-level-2"><span class="org-tag">:ignore:</span></span>
<span class="org-drawer">   :PROPERTIES:...
</span><span class="org-block-begin-line">#+BEGIN_QUOTE
</span><span class="org-quote">Free at last, free at last, thank God almighty we are free at last.

-- Martin Luther King Jr.
#
# Martin Luther King Jr., I Have a Dream: Writings and Speeches That Changed the World
</span><span class="org-block-end-line">#+END_QUOTE
</span>
Recall why lists give the &#8216;free monoid&#8217;: We can embed a type<span class="org-latex-and-related"> $A$ </span>into<span class="org-latex-and-related"> $\List A$ </span>by the map<span class="org-latex-and-related"> $[\_{}]$,</span>
and we can lift any map<span class="org-latex-and-related"> $f : A &#10230; B$ </span>to a monoid map
<span class="org-latex-and-related">\[\foldr \; (&#955; a b &#8594; f\, a &#8853; b)\; e \;:\; (\List A ,\_{}++\_{} , []) \,&#10230;\, (B,\_{}&#8853;\_{} , e)\]</span>
I.e.,<span class="org-latex-and-related"> $[a&#8321;, &#8230;, a&#8342;] \;&#8614;\; f\, a&#8321; &#8853; &#8943; &#8853; f\, a&#8342;$.</span> Moreover
this &#8216;preserves the basis&#8217;<span class="org-latex-and-related"> $A$
</span>-- i.e.,<span class="org-latex-and-related"> $&#8704; a &#8226;\; f\, a \,=\, \foldr \,f \,e \, [ a ]$ </span>--
and this lifted map is unique.

Likewise, let us show that<span class="org-latex-and-related"> $&#119979;G$ </span>is the &#8216;free category&#8217; over the graph<span class="org-latex-and-related"> $G$.</span>
This amounts to saying that there is a way, a graph-map, say<span class="org-latex-and-related"> $&#953;$,</span> that embeds<span class="org-latex-and-related"> $G$ </span>into<span class="org-latex-and-related"> $&#119979;G$,</span>
and a way to lift any graph-map<span class="org-latex-and-related"> $f \,:\, G \,&#119970;&#10230;\, &#119984;&#8320; &#119966;$ </span>to a functor<span class="org-latex-and-related"> $\mathsf{lift}\, f : &#119979;G &#10230; &#119966;$
</span>that &#8216;preserves the basis&#8217;<span class="org-latex-and-related"> $f \;=\; &#953; &#10814; &#119984;&#8321; (\mathsf{lift}\, f)$ </span>and uniquely so.

Let&#8217;s begin!

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> freedom (</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Obj</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block">) {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {&#8467;&#8320;} {&#8467;&#8320;} } </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">

  open </span><span class="org-block"><span class="haskell-constructor">TypedPaths</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> using (</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block"> ; </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> ;  </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> ; </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">++</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">)
  open </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> &#10627;</span><span class="org-block"><span class="haskell-operator">...</span></span><span class="org-block">&#10628;

  </span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block">
  </span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119982;&#8495;&#120009;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">&#119982;e&#120009;</span></span><span class="org-block"> {&#8467;&#8320;})
  </span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">
  </span><span class="org-block"><span class="haskell-keyword">instance</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">&#119966;</span></span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">Category</span></span><span class="org-block"> ; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">
</span><span class="org-block-end-line">#+END_SRC
</span>
<span class="org-hide">*</span><span class="org-level-2">* Defining the needed operations</span>
<span class="org-drawer">   :PROPERTIES:...
</span>The only obvious, and most natural, way to embed a graph into its &#8216;graph of paths&#8217; is to send
vertices to vertices and edges to paths of length 1.

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">  &#953; </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8320; (</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">)
  &#953; </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> record { ver </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block"> ; edge </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; {x} {y} e  </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">  x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> (y </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">) }
</span><span class="org-block-end-line">#+END_SRC
</span>
Given a graph map<span class="org-latex-and-related"> $f$,</span> following the list-analagoue of<span class="org-latex-and-related"> $[a&#8321;, &#8230;, a&#8342;] \;&#8614;\; f\, a&#8321; &#8853; &#8943; &#8853; f\, a&#8342;$
</span>we attempt to lift the map onto paths by taking the edges<span class="org-latex-and-related"> $e&#8321;, &#8230;, e&#8342;$ </span>of a path
to a morphism<span class="org-latex-and-related"> $\edge\, f\, e&#8321; &#10814; &#8943; &#10814; \edge\, f\, e&#8342;$.</span>
That is, a path of the form
<span class="org-latex-and-related">\[x_0 \xrightarrow{e_1} x_1 \xrightarrow{e_2} x_2 \xrightarrow{e_3} &#8943; \xrightarrow{e_k} x_k \]</span>
<span class="writegood-passive-voice">Is lifted</span> to the composition of morphisms
<span class="org-latex-and-related">\[\mathsf{ver}\, f\, x_0 \xrightarrow{\edge\, f\, e_1}
   \mathsf{ver}\, f\, x_1 \xrightarrow{\edge\, f\, e_2}
   \mathsf{ver}\, f\, x_2 \xrightarrow{\edge\, f\, e_3} &#8943; \xrightarrow{\edge\, f\, e_k}
   \mathsf{ver}\, f\, x_k \]</span>

Of course, we then need to verify that this construction <span class="writegood-passive-voice">is indeed</span>
functorial.

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">  lift </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">  </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">  </span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">
  lift f </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> record
     { obj  </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; v </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> ver f v </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Only way to obtain an object of &#119966;; hope it works!
</span></span><span class="org-block">     ; mor  </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> fmap
     ; id   </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl
     ; comp </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; {x y z p q} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> proof {x} {y} {z} {p} {q}
     }
     </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
          fmap </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {x y} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> y </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> ver f x </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10230;</span></span><span class="org-block"> ver f y
          fmap (y </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block">
          fmap (x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> p) </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> edge f e </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> fmap p

          </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">homomorphism property
</span></span><span class="org-block">          proof </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{x y z} {p </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> y} {q </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> y </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> z} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> fmap (p </span><span class="org-block"><span class="haskell-operator">++</span></span><span class="org-block"> q) </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> fmap p </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> fmap q
          proof {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">sym </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block">leftId
          proof {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> ps} </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block">  </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">cong (&#955; m </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> edge f e </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> m) (proof {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> ps})
                                     &#10216;</span><span class="org-block"><span class="haskell-operator">&#8801;&#8801;</span></span><span class="org-block">&#10217; </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">sym assoc
                                     </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Exercise: Rewrite this calculationally!
</span></span><span class="org-block-end-line">#+END_SRC
</span>
Now we have the embedding and the lifting, it remains to show that the aforementioned
&#8216;preserves basis&#8217; property holds as does uniqueness.

<span class="org-hide">*</span><span class="org-level-2">* Realising the proof-obligations</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
Let's begin with the &#8216;basis preservation&#8217; property:

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">  property </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{f </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">}  </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">  f  </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">  (&#953; </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; (lift f))
  property {f} </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> graphmapext
    </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Proving: &#8704; {v} &#8594; ver f v &#8801; ver (&#953; &#119966;.&#10814; &#119984;&#8321; (lift f)) v
</span></span><span class="org-block">    </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">by starting at the complicated side and simplifying
</span></span><span class="org-block">    (&#955; {v} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">sym (begin
              ver (&#953; </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; (lift f)) v
            </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216;</span><span class="org-block"><span class="string">" definition of ver on composition "</span></span><span class="org-block">&#10217;</span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block">
              (ver &#953; </span><span class="org-block"><span class="haskell-constructor">&#119982;&#8495;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> ver (</span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; (lift f))) v
            </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216;</span><span class="org-block"><span class="string">" definition of &#119984;&#8321; says: ver (&#119984;&#8321; F) = obj F "</span></span><span class="org-block">&#10217;</span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block">
              (ver &#953; </span><span class="org-block"><span class="haskell-constructor">&#119982;&#8495;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> obj (lift f)) v
            </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216;</span><span class="org-block"><span class="string">" definition of lift says: obj (lift f) = ver f "</span></span><span class="org-block">&#10217;</span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block">
              (ver &#953; </span><span class="org-block"><span class="haskell-constructor">&#119982;&#8495;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> ver f) v
            </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216;</span><span class="org-block"><span class="string">" definition of &#953; on vertices is identity "</span></span><span class="org-block">&#10217;</span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block">
              ver f v
            </span><span class="org-block"><span class="haskell-operator">&#8718;</span></span><span class="org-block">))

    </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Proving: edge (&#953; &#10814;g &#119984;&#8321; (lift f)) e &#8801; edge f e
</span></span><span class="org-block">    (&#955; {x} {y} {e} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> begin
               edge (&#953; </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; (lift f)) e
             </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216;</span><span class="org-block"><span class="string">" definition of edge on composition "</span></span><span class="org-block">&#10217;</span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block">
               (edge &#953; </span><span class="org-block"><span class="haskell-constructor">&#119982;&#8495;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> edge (</span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; (lift f))) e
             </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216;</span><span class="org-block"><span class="string">" definition of &#119984; says: edge (&#119984;&#8321; F) = mor F "</span></span><span class="org-block">&#10217;</span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block">
               (edge &#953; </span><span class="org-block"><span class="haskell-constructor">&#119982;&#8495;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> mor (lift f)) e
             </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216;</span><span class="org-block"><span class="string">" definition chasing gives: mor (lift f) (edge &#953; e) = edge f e &#10814; Id "</span></span><span class="org-block">&#10217;</span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block">
               edge f e </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Id</span></span><span class="org-block">
             </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block">rightId &#10217;
               edge f e
             </span><span class="org-block"><span class="haskell-operator">&#8718;</span></span><span class="org-block">)
</span><span class="org-block-end-line">#+END_SRC
</span>
Observe that we <span class="writegood-weasels">simply</span> chased definitions and as such <span class="org-code">graphmapext &#8801;-refl rightId</span> suffices as a proof,
but it&#8217;s not terribly clear why, for human consumption, and so we choose to elaborate with the
detail.

Finally, it remains to show that there is a unique way to preserve &#8216;basis&#8217;:

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">  uniqueness </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{f </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> f </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> (&#953; </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> lift f </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">
  uniqueness {</span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block">(&#953; </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">)} {</span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> funcext </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl (</span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">sym pf)
    </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
      pf </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{x y} {p </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> y} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">  mor (lift (&#953; </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">)) p  </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">  mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> p
      pf {x} {</span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block">x} {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block">x </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">sym (Functor.id </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">)
      pf {x} {y} {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block">x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> ps} </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> begin
         mor (lift (&#953; </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">)) (x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> ps)
       </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216;</span><span class="org-block"><span class="string">" definition of mor on lift, the inductive clause "</span></span><span class="org-block">&#10217;</span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block">
         edge (&#953; </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">) e </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> mor (lift (&#953; </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">)) ps
       </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216; </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">cong&#8322; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl (pf {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> ps}) &#10217; </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">inductive step
</span></span><span class="org-block">         edge (&#953; </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">) e </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> ps
       </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216;</span><span class="org-block"><span class="string">" definition of edge says it preserves composition "</span></span><span class="org-block">&#10217;</span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block">
         (edge &#953; </span><span class="org-block"><span class="haskell-constructor">&#119982;&#8495;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> edge (</span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">)) e </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> ps
       </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216;</span><span class="org-block"><span class="string">" definition of &#119984; gives: edge (&#119984;&#8321; F) = mor F "</span></span><span class="org-block">&#10217;</span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block">
         (edge &#953; </span><span class="org-block"><span class="haskell-constructor">&#119982;&#8495;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">) e </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> ps
       </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216;</span><span class="org-block"><span class="string">" definition of functional composition &#119982;&#8495;&#120009; "</span></span><span class="org-block">&#10217;</span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block">
          mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> (edge &#953; e) </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> ps
       </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216; </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">sym (Functor.comp </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">) </span><span class="org-block"><span class="comment-delimiter">{- </span></span><span class="org-block"><span class="comment">i.e., functors preserve composition -}</span></span><span class="org-block"> &#10217;
          mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> (edge &#953; e </span><span class="org-block"><span class="haskell-operator">++</span></span><span class="org-block"> ps)
       </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216;</span><span class="org-block"><span class="string">" definition of embedding and concatenation "</span></span><span class="org-block">&#10217;</span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block">
         mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> (x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> ps)
       </span><span class="org-block"><span class="haskell-operator">&#8718;</span></span><span class="org-block">
</span><span class="org-block-end-line">#+END_SRC
</span>
Challenge:
Define graph-map equality &#8216;&#8776;g&#8217; by <span class="italic">extensionality</span> --two graph maps are equal iff
their vertex <span class="italic">and</span> edge maps are extensionally equal. This is far more relaxed
than using propositional equality &#8216;&#8801;&#8217;. Now show the stronger uniqueness claim:
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">&#8704;{f : G &#10230; &#119984;&#8320; &#119966;} {F : &#119979;&#8320; G &#10230; &#119966;}   &#8594;   f  &#8776;g  (&#953; &#10814; &#119984;&#8321; F)   &#8594;   lift f  &#8801;  F
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>
<span class="org-drawer">:Solution:...
</span>
<span class="org-hide">*</span><span class="org-level-2">* Another freedom proof</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
However, saying each graph-map gives rise to exactly one unique functor is tantamount to
saying the type <span class="org-code">GraphMap G (&#119984;&#8320; &#119966;)</span> is isomorphic to <span class="org-code">Functor (&#119979;&#8320; G) &#119966;</span>, that is
<span class="org-code">(&#119979;&#8320; G &#10230; &#119966;) &#8773; (G &#10230; &#119984;&#8320; &#119966;)</span> ---observe that this says we can &#8216;move&#8217; <span class="org-code">&#119979;&#8320;</span> from the left to
the right of an arrow at the cost of it (and the arrow) changing.

A <span class="writegood-weasels">few</span> healthy exercises,

<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">  lift&#728; : Functor &#119979;G &#119966; &#8594; GraphMap G (&#119984;&#8320; &#119966;)
  lift&#728; F = &#953; &#10814;g &#119984;&#8321; F  --  i.e., record {ver = obj F , edge = mor F &#8728; edge &#953;}

  rid : &#8704;{f : GraphMap G (&#119984;&#8320; &#119966;)} &#8594; &#8704;{x y} {e : x &#10230;g y} &#8594; lift&#728; (lift f) &#8801; f
  rid = {! exercise !}

  lid : &#8704;{F : Functor &#119979;G &#119966;} &#8594; lift (lift&#728; F) &#8801; F
  lid = {! exercise !}
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>
One can of course obtain these proofs from the other ones without recourse to definitions,
however for comprehension one would do well to prove them from first principles.
The worked out solutions are available in the literate source file of this document.

<span class="org-drawer">:Solutions:...
</span>
We can then provide an alternative, and more succinct, proof of uniqueness for &#8216;basis preservation&#8217;:

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">  uniqueness&#8217;  </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block">  </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{f h}   </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">    f  </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">  (&#953; </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; h)   </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">   lift f  </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">  h
  uniqueness&#8217; {f} {h} f</span><span class="org-block"><span class="haskell-operator">&#8776;</span></span><span class="org-block">&#953;</span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321;h </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> begin
      lift f
    </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216; </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">cong lift f</span><span class="org-block"><span class="haskell-operator">&#8776;</span></span><span class="org-block">&#953;</span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321;h &#10217;
      lift (&#953; </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; h)
    </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216;</span><span class="org-block"><span class="string">" definition of lift&#728; "</span></span><span class="org-block">&#10217;</span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block">
      lift (lift</span><span class="org-block"><span class="haskell-operator">&#728;</span></span><span class="org-block"> h)
    </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216; lid &#10217;
      h
    </span><span class="org-block"><span class="haskell-operator">&#8718;</span></span><span class="org-block">
</span><span class="org-block-end-line">#+END_SRC
</span>
The difference between this proof and the original one is akin
to the difference between heaven and earth! That or it's much more elegant ;-)

<span class="org-hide">*</span><span class="org-level-2">* </span><span class="org-level-2"><span class="org-code">&#119979; &#8867; &#119984;</span></span>
<span class="org-drawer">   :PROPERTIES:...
</span>
<span class="org-drawer">:RecallingDefinitions:...
</span>
Thus far, we have essentially shown
<span class="org-latex-and-related">\[(&#119979;&#8320;\, G \,&#10230;\, &#119966;) \quad&#8773;\quad (G \,&#10230;\, &#119984;&#8320;\, &#119966;)\]</span>
We did so by finding a pair of inverse maps:

<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">lift   :  (    G &#10230; &#119984;&#8320; &#119966;)  &#8594;  (&#119979;&#8320; G &#10230;     &#119966;)
lift&#728;  :  (&#119979;&#8320; G  &#10230;    &#119966;)  &#8594;  (   G &#10230;  &#119984;&#8320; &#119966;)
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>
This is nearly <span class="org-code">&#119979; &#8867; &#119984;</span> which implies <span class="org-code">&#119979;</span> is a &#8216;free-functor&#8217; since it <span class="writegood-passive-voice">is left</span>-adjoint to a forgetful-functor.

&#8216;Nearly&#8217; since we need to exhibit naturality:
For every graph map <span class="org-code">g</span> and functors <span class="org-code">F, k</span> we have
<span class="org-code">lift&#728; (&#119979; g &#10814; k &#10814; F) &#8776; g &#10814; lift&#728; k &#10814; &#119984; F</span> in the category of graphs.

<span class="org-link"><a href="http://maartenfokkinga.github.io/utwente/mmf92b.pdf">Fokkinga (Theorem A.4)</a></span>, among others, would call these laws &#8216;fusion&#8217;
instead since they inform us how to compose, or &#8216;fuse&#8217;, a morphism with a
<span class="org-code">lift&#728;</span>-ed morphism: Taking <span class="org-code">F</span> to be the identity and remembering that functors preserve
identities, we have that <span class="org-code">g &#10814; lift&#728; K &#8801; lift&#728;( &#119979;&#8321; g &#10814; K)</span> --we can push a morphism into a <span class="org-code">lift&#728;</span>
at the cost of introducing a <span class="org-code">&#119979;&#8321;</span>; dually for <span class="org-code">lift</span>-ed morphisms.

First the setup,
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> {&#8467;&#8320;} {&#8467;&#8320;}}
          (g </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">GraphMap</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">) (</span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">

  private
    lift</span><span class="org-block"><span class="haskell-operator">&#728;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; {</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">C</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> freedom</span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block">lift</span><span class="org-block"><span class="haskell-operator">&#728;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">C</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block">
    lift </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; {</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">C</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> freedom</span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block">lift </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">C</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block">
  open </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> &#10627;</span><span class="org-block"><span class="haskell-operator">...</span></span><span class="org-block">&#10628;

  </span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">     </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">
  </span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">     </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">
  </span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block">
  </span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block">   </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block"> {&#8467;&#8320;} {&#8467;&#8320;})
  </span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119982;&#8495;&#120009;</span></span><span class="org-block">   </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">&#119982;e&#120009;</span></span><span class="org-block"> {&#8467;&#8320;})
</span><span class="org-block-end-line">#+END_SRC
</span>
Just as we needed to prove two inverse laws for <span class="org-code">lift</span> and <span class="org-code">lift&#728;</span>,
we need two naturality proofs.

<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">  naturality</span><span class="org-block"><span class="haskell-operator">&#728;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">K</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Functor</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">}
              </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">  lift</span><span class="org-block"><span class="haskell-operator">&#728;</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8321; g </span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">K</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">)  </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">  (g </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> lift</span><span class="org-block"><span class="haskell-operator">&#728;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">K</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">)
  naturality</span><span class="org-block"><span class="haskell-operator">&#728;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> graphmapext </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl
</span><span class="org-block-end-line">#+END_SRC
</span>
That was easier than assumed!
Hahaha: Hard to formalise but so <span class="writegood-weasels">easy</span> to prove lolz!
It says we can &#8216;shunt&#8217; <span class="org-code">lift&#728;</span> into certain compositions at the cost
of replacing functor instances.

Now for the other proof:
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">  naturality </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {k </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">GraphMap</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8320; </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">)} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">     lift (g </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> k </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">)
                                              </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">  (</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8321; g </span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> lift k </span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">)
  naturality {k} </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> funcext </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl (&#955; {x y p} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> proof {x} {y} {p})
    </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
      open </span><span class="org-block"><span class="haskell-constructor">TypedPaths</span></span><span class="org-block"> &#10627;</span><span class="org-block"><span class="haskell-operator">...</span></span><span class="org-block">&#10628;
      </span><span class="org-block"><span class="haskell-keyword">instance</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">G</span></span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">Graph</span></span><span class="org-block"> ; </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">
               </span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block"> ; </span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">
      proof </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {x y </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph.V</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">} {p </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> y}
            </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">    mor (</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8321; g </span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> lift {</span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} k </span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">) p
               </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">  mor (lift {</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">} (g </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> k </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">)) p
      proof {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> functor (</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8321; g </span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> lift {</span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} k </span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">) preserves</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">identities
      proof {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> ps} </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> begin
            mor (</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8321; g </span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> lift {</span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} k </span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">) (x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> ps)
         </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216;</span><span class="org-block"><span class="string">" By definition, &#8220;mor&#8221; distributes over composition "</span></span><span class="org-block">&#10217;</span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block">
            (mor (</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8321; g) </span><span class="org-block"><span class="haskell-constructor">&#119982;&#8495;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> mor (lift {</span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} k) </span><span class="org-block"><span class="haskell-constructor">&#119982;&#8495;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">) (x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> ps)
         </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216;</span><span class="org-block"><span class="string">" Definitions of function composition and &#8220;&#119979;&#8321; &#10814; mor&#8221; "</span></span><span class="org-block">&#10217;</span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block">
            mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> (mor (lift {</span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} k) (mor (</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8321; g) (x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> ps)))
                                                  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">This explicit path is in G
</span></span><span class="org-block">         </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216;</span><span class="org-block"><span class="string">" Lifting graph-map &#8220;g&#8221; onto a path "</span></span><span class="org-block">&#10217;</span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block">
            mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> (mor (lift {</span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} k) (ver g x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ edge g e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> mor (</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8321; g) ps))
                                                  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">This explicit path is in H
</span></span><span class="org-block">         </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216;</span><span class="org-block"><span class="string">" Definition of &#8220;lift &#10814; mor&#8221; on inductive case for paths "</span></span><span class="org-block">&#10217;</span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block">
            mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> (edge k (edge g e) </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> mor (lift {</span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} k) (mor (</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8321; g) ps))
         </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216; functor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> preserves</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">composition &#10217;
                mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> (edge k (edge g e))
           </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block">  mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block"> (mor (lift {</span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} k) (mor (</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8321; g) ps))
         </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216;</span><span class="org-block"><span class="string">" Definition of function composition, for top part "</span></span><span class="org-block">&#10217;</span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block">
               (edge g </span><span class="org-block"><span class="haskell-constructor">&#119982;&#8495;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> edge k </span><span class="org-block"><span class="haskell-constructor">&#119982;&#8495;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">) e  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">&#8776; mor F &#8728; edge k &#8728; edge g
</span></span><span class="org-block">           </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> (mor (</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8321; g) </span><span class="org-block"><span class="haskell-constructor">&#119982;&#8495;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> mor (lift {</span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} k) </span><span class="org-block"><span class="haskell-constructor">&#119982;&#8495;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> mor </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">) ps
         </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216;</span><span class="org-block"><span class="string">" &#8220;&#119984;&#8321; &#10814; edge = mor&#8221; and &#8220;edge&#8221; and &#8220;mor&#8221; are functorial by definition "</span></span><span class="org-block">&#10217;</span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block">
                edge (g </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> k </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">) e
           </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block">  mor (</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block">&#8321; g </span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> lift {</span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} k </span><span class="org-block"><span class="haskell-constructor">&#119966;&#119990;&#120009;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">) ps
         </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216; </span><span class="org-block"><span class="comment-delimiter">{- </span></span><span class="org-block"><span class="comment">Inductive Hypothesis: -}</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">cong&#8322; </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10814;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl (proof {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> ps}) &#10217;
                edge (g </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> k </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">) e
           </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block">  mor (lift {</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">} (g </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> k </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">)) ps
         </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">&#10216;</span><span class="org-block"><span class="string">" Definition of &#8220;lift &#10814; mor&#8221; on inductive case for paths "</span></span><span class="org-block">&#10217;</span><span class="org-block"><span class="haskell-operator">&#8242;</span></span><span class="org-block">
            mor (lift {</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">} (g </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> k </span><span class="org-block"><span class="haskell-constructor">&#119970;&#120007;&#119990;&#120005;&#119997;</span></span><span class="org-block"><span class="haskell-operator">.&#10814;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">&#8321; </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">)) (x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> ps)
         </span><span class="org-block"><span class="haskell-operator">&#8718;</span></span><span class="org-block">
</span><span class="org-block-end-line">#+END_SRC
</span>
Formally, we now have an adjunction:
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block"><span class="haskell-operator">&#8867;</span></span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8867;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block">
</span><span class="org-block"><span class="haskell-constructor">&#119979;</span></span><span class="org-block"><span class="haskell-operator">&#8867;</span></span><span class="org-block"><span class="haskell-constructor">&#119984;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> record{
    &#8970;</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">&#8971; </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> lift</span><span class="org-block"><span class="haskell-operator">&#728;</span></span><span class="org-block">
  ; &#8968;</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block">&#8969; </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> lift
  ; lid </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> lid
  ; rid </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; {</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> c} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> rid {</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} {c}
  ; lfusion </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; {</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> </span><span class="org-block"><span class="writegood-duplicates">f </span></span><span class="org-block"><span class="haskell-constructor"><span class="writegood-duplicates">F</span></span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">K</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> naturality</span><span class="org-block"><span class="haskell-operator">&#728;</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">} f </span><span class="org-block"><span class="haskell-constructor">K</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">}
  ; rfusion </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; {</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block"> f k </span><span class="org-block"><span class="haskell-constructor">F</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> naturality {</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">H</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">&#119967;</span></span><span class="org-block">} </span><span class="org-block"><span class="writegood-duplicates">f </span></span><span class="org-block"><span class="haskell-constructor"><span class="writegood-duplicates">F</span></span></span><span class="org-block"> {k} }
  </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
    </span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block">} {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Category</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block"> open freedom </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">&#119966;</span></span><span class="org-block">} public
</span><span class="org-block-end-line">#+END_SRC
</span><span class="org-level-1">* Folds Over Paths</span>
<span class="org-drawer">:PROPERTIES:...
</span>
<span class="org-hide">*</span><span class="org-level-2">* Folds Intro                                                       </span><span class="org-level-2"><span class="org-tag">:ignore:</span></span>
<span class="org-drawer">   :PROPERTIES:...
</span>Observe that for the freedom proof we recalled
that ists determine a form of quantification, &#8216;folding&#8217;:
given an operation &#8853;, we may form the operation <span class="org-code">[x&#8321;, &#8230;, x&#8342;] &#8614; x&#8321; &#8853; &#8943; &#8853; x&#8342;</span>.
Then used that to define our operation <span class="org-code">lift</span>, whose core was essentially,
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> folding (</span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
  open </span><span class="org-block"><span class="haskell-constructor">TypedPaths</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">
  open </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">G</span></span><span class="org-block">
                                              </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Given:
</span></span><span class="org-block">  fold </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block">} (v </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block">)               </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">realise G's vertices as X elements
</span></span><span class="org-block">         (f </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> x {y} (e </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> y) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block">) </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">realise paths as X elements
</span></span><span class="org-block">       </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {a b} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> a </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> b </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block">)            </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Then: Any path is an X value
</span></span><span class="org-block">  fold v f (b </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> v b
  fold v f (x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> ps) </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> f x e (fold v f ps)
</span><span class="org-block-end-line">#+END_SRC
</span>
For example, what is the length of a path?
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">  length </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{x y} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> y </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#8469;</span></span><span class="org-block">
  length </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> fold (&#955; </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> 0)          </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">single walks are length 0.
</span></span><span class="org-block">                (&#955; </span><span class="org-block"><span class="haskell-keyword"><span class="writegood-duplicates">_</span></span></span><span class="org-block"><span class="writegood-duplicates"> </span></span><span class="org-block"><span class="haskell-keyword"><span class="writegood-duplicates">_</span></span></span><span class="org-block"> n </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> 1 </span><span class="org-block"><span class="haskell-operator">+</span></span><span class="org-block"> n)  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">edges are one more than the
</span></span><span class="org-block">                                    </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">length of the remaining walk
</span></span><span class="org-block-end-line">#+END_SRC
</span>Let&#8217;s verify that this is actually what we intend by the length of a path.
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">  length</span><span class="org-block"><span class="haskell-operator">-!</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{x} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> length (x </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> 0
  length</span><span class="org-block"><span class="haskell-operator">-!</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl
  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">True by definition of &#8220;length&#8221;: The first argument to the &#8220;fold&#8221;
</span></span><span class="org-block">
  length</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">ind </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {x y &#969;} {e </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> y} {ps </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> y </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> &#969;}
            </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">  length (x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> ps)  </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block">  1 </span><span class="org-block"><span class="haskell-operator">+</span></span><span class="org-block"> length ps
  length</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">ind </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">refl
  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">True by definition of &#8220;length&#8221;: The second-argument to the &#8220;fold&#8221;
</span></span><span class="org-block-end-line">#+END_SRC
</span>
Generalising on <span class="org-code">length</span>, suppose we have a &#8216;cost function&#8217; <span class="org-code">c</span> that assigns a cost of traversing
an edge. Then we can ask what is the total cost of a path:
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">  path</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">cost </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> (c </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{x y}(e </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> y) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#8469;</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{x y}(ps </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> y) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#8469;</span></span><span class="org-block">
  path</span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block">cost c </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> fold (&#955; </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> 0)           </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">No cost on an empty path.
</span></span><span class="org-block">                     (&#955; x e n </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> c e </span><span class="org-block"><span class="haskell-operator">+</span></span><span class="org-block"> n) </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Cost of current edge plus
</span></span><span class="org-block">                                          </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">cost of remainder of path.
</span></span><span class="org-block-end-line">#+END_SRC
</span>Now, we have <span class="org-code">length = path-cost (&#955; _ &#8594; 1)</span>: Length is just assigning a cost of 1 to each edge.

Under suitable conditions, list fold distributes over list catenation, can we find an analogue
for paths? Yes. Yes, we can:
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">  fold</span><span class="org-block"><span class="haskell-operator">-++</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block">  </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{</span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block">} {v </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block">} {g </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> x {y} (e </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> y) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block">}
          </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#8853;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block">)
          </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{x y z </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block">} {p </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> y} {q </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> y </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> z}
          </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (unitl </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{x y} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> y </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> v x </span><span class="org-block"><span class="haskell-operator">&#8853;</span></span><span class="org-block"> y)        </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Image of &#8216;v&#8217; </span></span><span class="org-block"><span class="comment"><span class="writegood-passive-voice">is left</span></span></span><span class="org-block"><span class="comment"> unit of &#8853;
</span></span><span class="org-block">          </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (assoc </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {x y z} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#8853;</span></span><span class="org-block"> (y </span><span class="org-block"><span class="haskell-operator">&#8853;</span></span><span class="org-block"> z) </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> (x </span><span class="org-block"><span class="haskell-operator">&#8853;</span></span><span class="org-block"> y) </span><span class="org-block"><span class="haskell-operator">&#8853;</span></span><span class="org-block"> z )  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">&#8853; is associative
</span></span><span class="org-block">          </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">let</span></span><span class="org-block"> f </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> x {y} (e </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> y) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block">
                f </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; x e ps </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> g x e </span><span class="org-block"><span class="haskell-operator">&#8853;</span></span><span class="org-block"> ps
             </span><span class="org-block"><span class="haskell-keyword">in</span></span><span class="org-block">
               fold v f (p </span><span class="org-block"><span class="haskell-operator">++</span></span><span class="org-block"> q) </span><span class="org-block"><span class="haskell-operator">&#8801;</span></span><span class="org-block"> fold v f p </span><span class="org-block"><span class="haskell-operator">&#8853;</span></span><span class="org-block"> fold v f q
  fold</span><span class="org-block"><span class="haskell-operator">-++</span></span><span class="org-block"> {g </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> g} </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#8853;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> {x </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> x} {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block">x </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">} unitl assoc </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block">  unitl
  fold</span><span class="org-block"><span class="haskell-operator">-++</span></span><span class="org-block"> {g </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> g} </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#8853;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> {x </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> x} {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">.</span></span><span class="org-block">x </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ e ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> ps} unitl assoc </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block">
    </span><span class="org-block"><span class="haskell-operator">&#8801;-</span></span><span class="org-block">cong (&#955; exp </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> g x e </span><span class="org-block"><span class="haskell-operator">&#8853;</span></span><span class="org-block"> exp) (fold</span><span class="org-block"><span class="haskell-operator">-++</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#8853;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> {p </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> ps} unitl assoc) &#10216;</span><span class="org-block"><span class="haskell-operator">&#8801;&#8801;</span></span><span class="org-block">&#10217; assoc
</span><span class="org-block-end-line">#+END_SRC
</span>
Compare this with the proof-obligation of <span class="org-code">lift</span>.

<span class="org-hide">*</span><span class="org-level-2">* Lists are special kinds of paths</span>
<span class="org-drawer">   :PROPERTIES:...
</span>We called our path catenation <span class="org-code">_++_</span>, why the same symbol as that for
list catenation?

How do we interpret a list over<span class="org-latex-and-related"> $A$ </span>as a graph?
Well the vertices can be any element of<span class="org-latex-and-related"> $A$
</span>and an edge<span class="org-latex-and-related"> $x &#10230; y$ </span>merely indicates that
&#8216;&#8216;the item after<span class="org-latex-and-related"> $x$ </span>in the list is the element<span class="org-latex-and-related"> $y$&#8217;</span>&#8217;,
so we want it to be always true; or always inhabited
without distinction of the inhabitant:
So we might as well use a unit type.
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block"><span class="haskell-keyword">module</span></span><span class="org-block"> lists (</span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">

  open </span><span class="org-block"><span class="haskell-keyword">import</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Data.Unit</span></span><span class="org-block">

  listGraph </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Graph</span></span><span class="org-block">
  listGraph </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> record { </span><span class="org-block"><span class="haskell-constructor">V</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> ; </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; </span><span class="org-block"><span class="writegood-duplicates">a a</span></span><span class="org-block">&#8217; </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8868;</span></span><span class="org-block"> }
</span><span class="org-block-end-line">#+END_SRC
</span>I haven&#8217;t a clue if this works, you read my reasoning above.

The only thing we can do is test our hypothesis by looking at the
typed paths over this graph. In particular, we attempt to show every
non-empty list of<span class="org-latex-and-related"> $A$&#8217;</span>s corresponds to a path. Since a typed path needs
a priori the start and end vertes, let us construe
<span class="org-code">List A  &#8773;  &#931; n &#8758; &#8469; &#8226; Fin n &#8594; A</span>
--later note that <span class="org-code">Path G  &#8773;  &#931; n &#8758; &#8469; &#8226; [n] &#119970;&#10230; G</span>.
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">  open </span><span class="org-block"><span class="haskell-constructor">TypedPaths</span></span><span class="org-block"> listGraph
  open folding listGraph

  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Every non-empty list [x&#8320;, &#8230;, x&#8342;] of A&#8217;s corresonds to a path x&#8320; &#8669; x&#8342;.
</span></span><span class="org-block">  toPath </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{n} (list </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Fin</span></span><span class="org-block"> (suc n) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block">  list fzero </span><span class="org-block"><span class="haskell-operator">&#8669;</span></span><span class="org-block"> list (from&#8469; n)
  toPath {zero} list </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> list fzero </span><span class="org-block"><span class="haskell-operator">!</span></span><span class="org-block">
  toPath {suc n} list </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> list fzero </span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block">[ tt ]</span><span class="org-block"><span class="haskell-operator">&#10230;</span></span><span class="org-block"> toPath {n} (&#955; i </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> list(fsuc i))
    </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Note that in the inductive case, &#8220;list : Fin (suc (suc n)) &#8594; A&#8221;
</span></span><span class="org-block">    </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">whereas &#8220;suc &#10814; list : Fin (suc n) &#8594; A&#8221;.
</span></span><span class="org-block">    </span><span class="org-block"><span class="comment-delimiter">--</span></span><span class="org-block"><span class="comment">
</span></span><span class="org-block">    </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">For example, if &#8220;list &#8776; [x , y , z]&#8221; yields
</span></span><span class="org-block">    </span><span class="org-block"><span class="comment-delimiter">--          </span></span><span class="org-block"><span class="comment">&#8220;fsuc &#10814; list &#8776; [y , z ]&#8221; and
</span></span><span class="org-block">    </span><span class="org-block"><span class="comment-delimiter">--   </span></span><span class="org-block"><span class="comment">&#8220;fsuc &#10814; fsuc &#10814; list &#8776; [z]&#8221;.
</span></span><span class="org-block-end-line">#+END_SRC
</span>Hm! Look at that, first guess and it worked! Sweet.

Now let&#8217;s realize the list fold as an instance of path fold,
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">List type former
</span></span><span class="org-block">  </span><span class="org-block"><span class="haskell-constructor">List</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> &#955; (</span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#931;</span></span><span class="org-block"> n </span><span class="org-block"><span class="haskell-operator">&#8758;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#8469;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8226;</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">Fin</span></span><span class="org-block"> n </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block">)

  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Usual list folding, but it's in terms of path folding.
</span></span><span class="org-block">  foldr </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{</span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block">} (f </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block">) (e </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">List</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block">
  foldr f e (zero , l) </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> e
  foldr f e (suc n , l) </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> fold (&#955; a </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> f a e) (&#955; a </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> rem </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> f a rem) (toPath l)

  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">example
</span></span><span class="org-block">  listLength </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">List</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">&#8469;</span></span><span class="org-block"> </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">result should </span></span><span class="org-block"><span class="comment"><span class="writegood-weasels">clearly</span></span></span><span class="org-block"><span class="comment"> be &#8220;proj&#8321;&#8221; of the list, anyhow:
</span></span><span class="org-block">  listLength </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> foldr
    (&#955; a rem </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> 1 </span><span class="org-block"><span class="haskell-operator">+</span></span><span class="org-block"> rem) </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Non-empty list has length 1 more than the remainder.
</span></span><span class="org-block">    0                    </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Empty list has length 0.
</span></span><span class="org-block-end-line">#+END_SRC
</span>
Let&#8217;s prepare for a more useful example
<span class="org-block-begin-line">#+BEGIN_src haskell
</span><span class="org-block">  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Empty list
</span></span><span class="org-block">  </span><span class="org-block"><span class="haskell-constructor">[]</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{</span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">List</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block">
  </span><span class="org-block"><span class="haskell-constructor">[]</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> 0 , &#955; </span><span class="org-block"><span class="haskell-constructor">()</span></span><span class="org-block">

  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Cons for lists
</span></span><span class="org-block">  </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#8759;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{</span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Set</span></span><span class="org-block">} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">List</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">List</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block">
  </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#8759;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block">} x (n , l) </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> 1 </span><span class="org-block"><span class="haskell-operator">+</span></span><span class="org-block"> n , cons x l
    </span><span class="org-block"><span class="haskell-keyword">where</span></span><span class="org-block">
      </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">&#8220;cons a l  &#8776;  &#955; i : Fin (1 + n) &#8594; if i &#8776; 0 then a else l i&#8221;
</span></span><span class="org-block">      cons </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block">{n} </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">Fin</span></span><span class="org-block"> n </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">Fin</span></span><span class="org-block"> (suc n) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">X</span></span><span class="org-block">)
      cons x l fzero </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> x
      cons x l (fsuc i) </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> l i

  map </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8704;</span></span><span class="org-block"> {</span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block">} (f </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block">) </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">List</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">List</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">B</span></span><span class="org-block">
  map f </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block">  foldr (&#955; a rem </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> f a </span><span class="org-block"><span class="haskell-operator">&#8759;</span></span><span class="org-block"> rem) </span><span class="org-block"><span class="haskell-constructor">[]</span></span><span class="org-block">  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">looks like the usual map don&#8217;t it ;)
</span></span><span class="org-block">
  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">list concatenation
</span></span><span class="org-block">  </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">++</span></span><span class="org-block">&#8467;_ </span><span class="org-block"><span class="haskell-constructor">:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">List</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">List</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">&#8594;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">List</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">A</span></span><span class="org-block">
  l </span><span class="org-block"><span class="haskell-operator">++</span></span><span class="org-block">&#8467; r </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> foldr </span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"><span class="haskell-operator">&#8759;</span></span><span class="org-block"><span class="haskell-keyword">_</span></span><span class="org-block"> r l </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">fold over &#8216;l&#8217; by consing its elements infront of &#8216;r&#8217;
</span></span><span class="org-block">
  </span><span class="org-block"><span class="comment-delimiter">-- </span></span><span class="org-block"><span class="comment">Exercise: Write path catenation as a path-fold.
</span></span><span class="org-block-end-line">#+END_SRC
</span>
These <span class="writegood-weasels">few</span> adventures would suggest that much of list theory can <span class="writegood-passive-voice">be
brought</span> over to the world of paths. It looks promising, let me know
dear reader if you make progress on related explorations!
<span class="org-level-1">* That was fun; Bye!</span>
<span class="org-drawer">:PROPERTIES:...
</span>
This note took longer to write than I had initally assumed; perhaps I should have taken into
account
+ <span class="org-list-dt">Hofstadter&#8217;s Law ::</span>
  It always takes longer than you expect, even when you take into account Hofstadter&#8217;s Law.

  &#9472;<span class="org-link"><a href="https://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach">G&#246;del, Escher, Bach: An Eternal Golden Braid</a></span>

Lessons learned:

+ In Agda, Use implicits when possible in-favour of instance variables
  since the former can <span class="writegood-passive-voice">be inferred</span> from the local context,
  whereas the latter must <span class="writegood-passive-voice">be resolved</span> using the entire global context
  thereby incurring possibly more unification problems to solve
  thereby costing more time.

+ If you really want to learn something, teach it to someone:
  A proof assistant wont let you get away with skipping over anything!

+ Coming up with the right data representation for the tasks <span class="writegood-passive-voice">being tackled</span>
  is a matter of discovery!

The astute reader <span class="writegood-weasels">may have</span> noticed that the tone of writing sometimes
changes drastically. This is because <span class="writegood-weasels">some</span> of this article <span class="writegood-passive-voice">was written</span>
by me in March 2016 and I wished to preserve interesting writing style
I then had --if anything to contrast with my now somewhat semi-formal style.

This article <span class="writegood-passive-voice">was motivated</span> while I was reading <span class="org-link"><a href="https://www.amazon.ca/Conceptual-Mathematics-First-Introduction-Categories/dp/052171916X">Conceptual Mathematics</a></span>
for fun. One of the problems was to show that paths over a graph form
a category and do so freely. It took me about 20 minutes on paper and pencil,
but this resulting mechanisation took much more time --but it was also
much more fun!

I had fun writing this up &amp; I hope you enjoy it too :-)

+ <span class="org-list-dt">Highly Recommended Read ::</span>
  The diligent reader may <span class="writegood-passive-voice">be interested</span> to know that Maarten Fokkinga has written a <span class="writegood-weasels">very</span>
  accessible and <span class="org-link"><a href="http://maartenfokkinga.github.io/utwente/mmf92b.pdf">gentle introduction to category theory using the calculational approach</a></span>.

<span class="org-meta-line">#+HTML: &lt;small&gt;</span>
<span class="org-block-begin-line">#+BEGIN_CENTER
</span>( This article is not yet &#8216;done&#8217;, but good enough for now. )
<span class="org-block-end-line">#+END_CENTER
</span><span class="org-meta-line">#+HTML: &lt;/small&gt;</span>

<span class="org-level-1">* </span><span class="org-special-keyword">COMMENT</span><span class="org-level-1"> Setoid Approach                                         </span><span class="org-level-1"><span class="org-tag">:solutions:</span></span>
<span class="org-drawer">  :PROPERTIES:...
</span>Herein are the solutions to a setoid approach going all the way to the
lifting of graphmaps to functors.

I wrote this rushedly; <span class="writegood-weasels">very</span> rough solutions.

<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">module _ where -- category definitions
 record Category&#8217; {i j k : Level} : Set (&#8467;suc (i &#8845; j &#8845; k)) where
  infixr 10 _&#10814;_
  infix 5 _&#8776;_
  field
    -- graph structure
    Obj&#8217;  : Set i
    _&#10230;_ : Obj&#8217; &#8594; Obj&#8217; &#8594; Set j

    -- setoid structure
    _&#8776;_  : &#8704; {A B} (f g : A &#10230; B) &#8594; Set k
    &#8776;-refl  : &#8704; {A B} {f : A &#10230; B} &#8594; f &#8776; f
    &#8776;-sym   : &#8704; {A B} {f g : A &#10230; B} &#8594; f &#8776; g &#8594; g &#8776; f
    &#8776;-trans : &#8704; {A B} {f g h : A &#10230; B} &#8594; f &#8776; g &#8594; g &#8776; h &#8594; f &#8776; h

    -- typed-monoid-like structure
    _&#10814;_     : &#8704;{A B C : Obj&#8217;} &#8594; A &#10230; B &#8594; B &#10230; C &#8594; A &#10230; C
    &#10814;-cong  : &#8704; {A B C} {</span><span class="custom"><span class="writegood-duplicates">f f</span></span><span class="custom">&#8217; : A &#10230; B} {</span><span class="custom"><span class="writegood-duplicates">g g</span></span><span class="custom">&#8217; : B &#10230; C} &#8594; f &#8776; f&#8217; &#8594; g &#8776; g&#8217; &#8594; f &#10814; g &#8776; f&#8217; &#10814; g&#8217;
    assoc   : &#8704;{A B C D} {f : A &#10230; B}{g : B &#10230; C} {h : C &#10230; D} &#8594; (f &#10814; g) &#10814; h &#8776; f &#10814; (g &#10814; h)
    Id      : &#8704;{A : Obj&#8217;} &#8594; A &#10230; A
    leftId  : &#8704; {A B} {f : A &#10230; B} &#8594; Id &#10814; f &#8776; f
    rightId : &#8704; {A B} {f : A &#10230; B} &#8594; f &#10814; Id &#8776; f
 open Category&#8217; &#10627;...&#10628; renaming (_&#10230;_ to _&#10230;&#8217;_ ; _&#10814;_ to _&#10814;&#8217;_ ; Id to Id&#8217; ; leftId to leftId&#8217; ; rightId to rightId&#8217; ; assoc to assoc&#8217; ; _&#8776;_ to _&#8776;&#8217;_) public

 record Functor&#8217; {i j k i&#8217; j&#8217; k&#8217;} (&#119966; : Category&#8217; {i} {j} {k}) (&#119967; : Category&#8217; {i&#8217;} {j&#8217;} {k&#8217;}) : Set (&#8467;suc (i &#8845; j &#8845; k &#8845; i&#8217; &#8845; j&#8217; &#8845; k&#8217;)) where
  field
    -- graph-map structure
    obj&#8217;  : Category&#8217;.Obj&#8217; &#119966; &#8594; Category&#8217;.Obj&#8217; &#119967;                               -- object map
    mor&#8217;  : &#8704;{x y : Category&#8217;.Obj&#8217; &#119966;} &#8594; x &#10230;&#8217; y &#8594; obj&#8217; x &#10230;&#8217; obj&#8217; y    -- morphism preservation

    -- interaction with setoid structure
    cong : &#8704; {x y : Category&#8217;.Obj&#8217; &#119966;} {f g : x &#10230;&#8217; y} &#8594; f &#8776;&#8217; g &#8594; mor&#8217; f &#8776;&#8217; mor&#8217; g

    -- preservation of finite compositions
    id   : &#8704;{x : Category&#8217;.Obj&#8217; &#119966;} &#8594; mor&#8217; (Id&#8217; {A = x}) &#8776;&#8217; Id&#8217;       -- identities preservation
    comp : &#8704;{x y z : Category&#8217;.Obj&#8217; &#119966;} {f : x &#10230;&#8217; y} {g : y &#10230;&#8217; z} &#8594; mor&#8217; (f &#10814;&#8217; g) &#8776;&#8217; mor&#8217; f &#10814;&#8217; mor&#8217; g  -- composition preservation

 subst-sym : &#8704; {a} {A : Set a} (P : A &#8594; A &#8594; Set) {</span><span class="custom"><span class="writegood-duplicates">x x</span></span><span class="custom">&#8217; </span><span class="custom"><span class="writegood-duplicates">y y</span></span><span class="custom">&#8217; : A} (xeq : x &#8801; x&#8217;) (yeq : y &#8801; y&#8217;) {p : P x y} {q : P x&#8217; y&#8217;} &#8594; q &#8801; &#8801;-subst&#8322; P xeq yeq p &#8594; p &#8801; &#8801;-subst&#8322; P (&#8801;-sym xeq) (&#8801;-sym yeq) q
 subst-sym P &#8801;-refl &#8801;-refl {p} {.p} &#8801;-refl = &#8801;-refl

 subst-trans : &#8704; {a} {A : Set a} (P : A &#8594; A &#8594; Set) {</span><span class="custom"><span class="writegood-duplicates">x x</span></span><span class="custom">&#8217; x&#8217;&#8217; </span><span class="custom"><span class="writegood-duplicates">y y</span></span><span class="custom">&#8217; y&#8217;&#8217; : A} (xeq : x &#8801; x&#8217;) (yeq : y &#8801; y&#8217;) (xeq&#8217; : x&#8217; &#8801; x&#8217;&#8217;) (yeq&#8217; : y&#8217; &#8801; y&#8217;&#8217;) {p : P x y} {q : P x&#8217; y&#8217;} {r : P x&#8217;&#8217; y&#8217;&#8217;} &#8594; r &#8801; &#8801;-subst&#8322; P xeq&#8217; yeq&#8217; q &#8594; q &#8801; &#8801;-subst&#8322; P xeq yeq p &#8594; r &#8801; &#8801;-subst&#8322; P (xeq &#10216;&#8801;&#8801;&#10217; xeq&#8217;) (yeq &#10216;&#8801;&#8801;&#10217; yeq&#8217;) p
 subst-trans P &#8801;-refl &#8801;-refl &#8801;-refl &#8801;-refl {p} {.p} {.p} &#8801;-refl &#8801;-refl = &#8801;-refl

       -- this&#8217; like subst-dist, with ~&#8801;-cong~ of two equations using </span><span class="custom"><span class="writegood-duplicates">subst
 subst</span></span><span class="custom">-compose : &#8704; {a} {A : Set a} (P : A &#8594; A &#8594; Set) {</span><span class="custom"><span class="writegood-duplicates">x x</span></span><span class="custom">&#8217; </span><span class="custom"><span class="writegood-duplicates">y y</span></span><span class="custom">&#8217; </span><span class="custom"><span class="writegood-duplicates">z z</span></span><span class="custom">&#8217; : A} (xeq : x &#8801; x&#8217;) (yeq : y &#8801; y&#8217;) (zeq : z &#8801; z&#8217;) (p : P x y) (p&#8217; : P x&#8217; y&#8217;) (q : P y z) (q&#8217; : P y&#8217; z&#8217;) &#8594; (_&#9671;_  : &#8704;{m n k} &#8594; P m n &#8594; P n k &#8594; P m k) &#8594; p&#8217; &#8801; &#8801;-subst&#8322; P xeq yeq p &#8594; q&#8217; &#8801; &#8801;-subst&#8322; P yeq zeq q &#8594; (p&#8217; &#9671; q&#8217;) &#8801; &#8801;-subst&#8322; P xeq zeq (p &#9671; q)
 subst-compose P &#8801;-refl &#8801;-refl &#8801;-refl p .p q .q _&#9671;_ &#8801;-refl &#8801;-refl = &#8801;-refl
       -- taking cases ~p&#8217; = subst ... p~ and ~q&#8217; = subst ... q~ gives subst-dist ?

 subst-cong : &#8704; {a} {A : Set a} (P : A &#8594; A &#8594; Set) {</span><span class="custom"><span class="writegood-duplicates">x x</span></span><span class="custom">&#8217; </span><span class="custom"><span class="writegood-duplicates">y y</span></span><span class="custom">&#8217; : A} (xeq : x &#8801; x&#8217;) (yeq : y &#8801; y&#8217;) {p : P x y} {p&#8217; : P x&#8217; y&#8217;} &#8594; p&#8217; &#8801; &#8801;-subst&#8322; P xeq yeq p &#8594;
                    &#8704; {b} {B : Set b} (Q : B &#8594; B &#8594; Set) {f&#8320; : A &#8594; B} (f : &#8704; {m n} &#8594; P m n &#8594; Q (f&#8320; m) (f&#8320; n)) {f&#8217;&#8320; : A &#8594; B} {f&#8217; : &#8704; {m n} &#8594; P m n &#8594; Q (f&#8217;&#8320; m) (f&#8217;&#8320; n)}
                    &#8594; (eq&#8320; : &#8704; {x} &#8594; f&#8320; x &#8801; f&#8217;&#8320; x) (eq : &#8704; {m n} {r : P m n} &#8594; f&#8217; r &#8801; &#8801;-subst&#8322; Q </span><span class="custom"><span class="writegood-duplicates">eq&#8320; eq&#8320;</span></span><span class="custom"> (f r))
                    &#8594; f&#8217; p&#8217; &#8801; &#8801;-subst&#8322; Q (&#8801;-cong f&#8320; xeq &#10216;&#8801;&#8801;&#10217; eq&#8320;) (&#8801;-cong f&#8320; yeq &#10216;&#8801;&#8801;&#10217; eq&#8320;) (f p)
 subst-cong P &#8801;-refl &#8801;-refl {p} {.p} &#8801;-refl Q f eq&#8320; eq rewrite eq {r = p} = &#8801;-refl

 open import Function using (_&#8728;_)
 instance
  &#119966;&#119990;&#120009;&#8217; : Category&#8217; {&#8467;suc &#8467;&#8320;} {&#8467;suc &#8467;&#8320;} {_}
  &#119966;&#119990;&#120009;&#8217; =
   record
     { Obj&#8217; = Category&#8217; {&#8467;&#8320;} {&#8467;&#8320;} {_}
     ; _&#10230;_ = Functor&#8217;
     ; _&#8776;_ = &#955; {&#119966;} {&#119967;} F G &#8594; &#931; oeq &#8758; (&#8704; {o} &#8594; Functor&#8217;.obj&#8217; F o &#8801; Functor&#8217;.obj&#8217; G o) &#8226; ((&#8704; {X Y} {f : X &#10230;&#8217; Y} &#8594; Functor&#8217;.mor&#8217; G f &#8801; &#8801;-subst&#8322; _&#10230;&#8217;_ </span><span class="custom"><span class="writegood-duplicates">oeq oeq</span></span><span class="custom"> (Functor&#8217;.mor&#8217; </span><span class="custom"><span class="writegood-duplicates">F f</span></span><span class="custom">)))
     ; &#8776;-refl = &#8801;-refl , &#8801;-refl
     ; &#8776;-sym = &#955; pf &#8594; let (oeq , meq) = pf in &#8801;-sym oeq , subst-sym _&#10230;&#8217;_ </span><span class="custom"><span class="writegood-duplicates">oeq oeq</span></span><span class="custom"> meq
     ; &#8776;-trans = &#955; pf1 pf2 &#8594; let (oeq&#8321; , meq&#8321;) = pf1 ; (oeq&#8322; , meq&#8322;) = pf2 in oeq&#8321; &#10216;&#8801;&#8801;&#10217; oeq&#8322; , subst-trans _&#10230;&#8217;_ oeq&#8321; oeq&#8321; oeq&#8322; oeq&#8322; meq&#8322; meq&#8321;
     ; _&#10814;_ = &#955; {A} {B} {C} F G &#8594; record { obj&#8217; = Functor&#8217;.obj&#8217; G &#8728; Functor&#8217;.obj&#8217; F ; mor&#8217; = Functor&#8217;.mor&#8217; G &#8728; Functor&#8217;.mor&#8217; F ; cong = Functor&#8217;.cong G &#8728; Functor&#8217;.cong F ; id = &#955; {x} &#8594; Category&#8217;.&#8776;-trans C (Functor&#8217;.cong G (Functor&#8217;.id F)) (Functor&#8217;.id G) ; comp = Category&#8217;.&#8776;-trans C (Functor&#8217;.cong G (Functor&#8217;.comp F)) (Functor&#8217;.comp G) }
     ; &#10814;-cong = &#955; {C D A} {F} {F&#8217;} {G} {G&#8217;} feq geq &#8594; let (oeq&#8321; , meq&#8321;) = feq ; (oeq&#8322; , meq&#8322;) = geq in &#8801;-cong (Functor&#8217;.obj&#8217; G) oeq&#8321; &#10216;&#8801;&#8801;&#10217; oeq&#8322; , subst-cong (Category&#8217;._&#10230;_ D) oeq&#8321; oeq&#8321; meq&#8321; (Category&#8217;._&#10230;_ A) (Functor&#8217;.mor&#8217; G) oeq&#8322; meq&#8322;
     ; assoc = &#8801;-refl , &#8801;-refl
     ; Id = record { obj&#8217; = &#955; x &#8594; x ; mor&#8217; = &#955; x &#8594; x ; cong = &#955; {x} {y} {f} {g} z &#8594; z ; id = &#8776;-refl ; comp = &#8776;-refl }
     ; leftId = &#8801;-refl , &#8801;-refl
     ; rightId = &#8801;-refl , &#8801;-refl
     }
     where

 instance
  &#119982;et&#8217; : Category&#8217;
  &#119982;et&#8217; =
    record
      { Obj&#8217; = Set
      ; _&#10230;_ = &#955; A B &#8594; (A &#8594; B)
      ; _&#8776;_ = &#955; f g &#8594; &#8704; {x} &#8594; f x &#8801; g x
      ; &#8776;-refl = &#8801;-refl
      ; &#8776;-sym = &#955; eq &#8594; &#8801;-sym eq
      ; &#8776;-trans = &#955; f&#8776;</span><span class="custom"><span class="writegood-duplicates">g g</span></span><span class="custom">&#8776;h &#8594; f&#8776;g &#10216;&#8801;&#8801;&#10217; g&#8776;h
      ; _&#10814;_ = &#955; f g &#8594; g &#8728; f
      ; &#10814;-cong = &#955; {A B C} {</span><span class="custom"><span class="writegood-duplicates">f f</span></span><span class="custom">&#8217;} {</span><span class="custom"><span class="writegood-duplicates">g g</span></span><span class="custom">&#8217;} f&#8776;f&#8217; g&#8776;g&#8217; &#8594; &#8801;-cong g f&#8776;f&#8217; &#10216;&#8801;&#8801;&#10217; g&#8776;g&#8217;
      ; assoc = &#8801;-refl
      ; Id = &#955; x &#8594; x
      ; leftId = &#8801;-refl
      ; rightId = &#8801;-refl
      }

  -- make this as an excercise, since it is essentially CAT but without extra proof obligations for functors
  &#119970;&#120007;&#119990;&#120005;&#119997;&#8217; : Category&#8217;
  &#119970;&#120007;&#119990;&#120005;&#119997;&#8217; =
    record
      { Obj&#8217; = Graph
      ; _&#10230;_ = GraphMap
      ; _&#8776;_ = &#955; {G} {H} f g &#8594; &#931; veq &#8758; (&#8704; {v} &#8594; ver f v &#8801; ver g v) &#8226;
    (&#8704; {x y e} &#8594; edge g {x} {y} e &#8801; &#8801;-subst&#8322; (&#955; a b &#8594; Graph._&#10230;_ H a b) </span><span class="custom"><span class="writegood-duplicates">veq veq</span></span><span class="custom"> (edge f {x} {y} e))
      ; &#8776;-refl = &#8801;-refl , &#8801;-refl
      ; &#8776;-sym = &#955; f&#8776;g &#8594; let (veq , eeq) = f&#8776;g in &#8801;-sym veq , subst-sym (Graph._&#10230;</span><span class="custom"><span class="writegood-duplicates">_ _</span></span><span class="custom">) </span><span class="custom"><span class="writegood-duplicates">veq veq</span></span><span class="custom"> eeq
      ; &#8776;-trans = &#955; f&#8776;</span><span class="custom"><span class="writegood-duplicates">g g</span></span><span class="custom">&#8776;h &#8594; let (veq&#8321; , eeq&#8321;) = f&#8776;g ; (veq&#8322; , eeq&#8322;) = g&#8776;h in veq&#8321; &#10216;&#8801;&#8801;&#10217; veq&#8322; , subst-trans (Graph._&#10230;</span><span class="custom"><span class="writegood-duplicates">_ _</span></span><span class="custom">) veq&#8321; veq&#8321; veq&#8322; veq&#8322; eeq&#8322; eeq&#8321;
      ; _&#10814;_ = &#955; f g &#8594; record { ver = ver f &#10814;&#8217; ver g ; edge = edge f &#10814;&#8217; edge g } -- using ~&#119982;et~
      ; &#10814;-cong = &#955; {G} {H} {K} {f} {f&#8217;} {g} {g&#8217;} f&#8776;f&#8217; g&#8776;g&#8217; &#8594; let (veq&#8321; , eeq&#8321;) = f&#8776;f&#8217; ; (veq&#8322; , eeq&#8322;) = g&#8776;g&#8217; in &#8801;-cong (ver g) veq&#8321; &#10216;&#8801;&#8801;&#10217; veq&#8322; , subst-cong (Graph._&#10230;</span><span class="custom"><span class="writegood-duplicates">_ _</span></span><span class="custom">) veq&#8321; veq&#8321; eeq&#8321; (Graph._&#10230;</span><span class="custom"><span class="writegood-duplicates">_ _</span></span><span class="custom">) (edge g) veq&#8322; eeq&#8322;
      ; assoc = &#8801;-refl , &#8801;-refl
      ; Id = record { ver = Category&#8217;.Id &#119982;et&#8217; ; edge = Category&#8217;.Id &#119982;et&#8217; }
      ; leftId = &#8801;-refl , &#8801;-refl
      ; rightId = &#8801;-refl , &#8801;-refl
      }

  &#119984;&#8217; : Functor&#8217; &#119966;&#119990;&#120009;&#8217; &#119970;&#120007;&#119990;&#120005;&#119997;&#8217;
  &#119984;&#8217; =  record {
     obj&#8217; = &#955; &#119966; &#8594; record { V = Category&#8217;.Obj&#8217; &#119966; ; _&#10230;_ = Category&#8217;._&#10230;_ &#119966; }
   ; mor&#8217; = &#955; F  &#8594; record { ver = Functor&#8217;.obj&#8217; F ; edge = Functor&#8217;.mor&#8217; F }
   ; cong = &#955; f&#8776;g &#8594; f&#8776;g ; id = &#8801;-refl , &#8801;-refl ; comp = &#955; {x} {y} {z} {f} {g} &#8594; &#8801;-refl , &#8801;-refl }


&#119979;&#8217;&#8320; : Graph &#8594; Category&#8217;
&#119979;&#8217;&#8320; G = let open TypedPaths G in
  record
    { Obj&#8217; = Graph.V G
    ; _&#10230;_ = _&#8669;_
    ; _&#8776;_ = _&#8801;_
    ; &#8776;-refl = &#8801;-refl
    ; &#8776;-sym = &#8801;-sym
    ; &#8776;-trans = _&#10216;&#8801;&#8801;&#10217;_
    ; _&#10814;_ = _++_
    ; &#10814;-cong = &#955; p&#8776;p&#8217; q&#8776;q&#8217; &#8594; &#8801;-cong&#8322; _++_ p&#8776;p&#8217; q&#8776;q&#8217;
    ; assoc = &#955; {x y z &#969; p q r} &#8594; assoc {p = p}
    ; Id = &#955; {x} &#8594; x !
    ; leftId = leftId
    ; rightId = rightId
    }

&#119979;&#8321;&#8217; : &#8704;{G H} &#8594; GraphMap G H &#8594; Functor&#8217; (&#119979;&#8217;&#8320; G) (&#119979;&#8217;&#8320; H)
&#119979;&#8321;&#8217; {G} {H} f = record { obj&#8217; = ver f ; mor&#8217; = fmap ; cong = &#8801;-cong fmap ; id = &#8801;-refl ; comp = &#955; {x} {y} {z} {p} &#8594; comp {p = p} }
    where
      open TypedPaths &#10627;...&#10628; public

      fmap : {x y : Graph.V G} &#8594;  x &#8669; y &#8594; (ver f x) &#8669; (ver f y)
      fmap (x !) = ver f x !
      fmap (x &#10230;[ e ]&#10230; p) = ver f x &#10230;[ edge f e ]&#10230; fmap p

      comp : {x y z : Graph.V G} {p : x &#8669; y} {q : y &#8669; z} &#8594; fmap (p ++ q) &#8801; fmap p ++ fmap q
      comp {x} {p = .x !} = &#8801;-refl -- since ! </span><span class="custom"><span class="writegood-passive-voice">is left</span></span><span class="custom"> unit of ++
      comp {x} {p = .x &#10230;[ e ]&#10230; ps} = &#10230;-&#8801; (comp {p = ps})

&#119979;&#8217; : Functor&#8217; &#119970;&#120007;&#119990;&#120005;&#119997;&#8217; &#119966;&#119990;&#120009;&#8217;
&#119979;&#8217; = record { obj&#8217; = &#119979;&#8217;&#8320; ; mor&#8217; = &#119979;&#8321;&#8217; ; cong = &#955; f&#8776;g &#8594; proj&#8321; f&#8776;g ,  gg f&#8776;g ; id = &#8801;-refl , idm ; comp = &#8801;-refl , compmor }
    where
      open TypedPaths &#10627;...&#10628; public

      idm : &#8704; {G} {x y} {p : x &#8669; y} &#8594; Functor&#8217;.mor&#8217; (Category&#8217;.Id &#119966;&#119990;&#120009;&#8217; {&#119979;&#8217;&#8320; G}) p &#8801; Functor&#8217;.mor&#8217; (&#119979;&#8321;&#8217; (Category&#8217;.Id &#119970;&#120007;&#119990;&#120005;&#119997;&#8217;)) p
      idm {G} {x} {p = .x !} = &#8801;-refl
      idm {G} {x} {p = .x &#10230;[ e ]&#10230; ps} = &#10230;-&#8801; (idm {p = ps})

      -- general version of gelping, keep it around, possibly as an excercise
      helping : &#8704; {a b} {A : Set a} (B : A &#8594; A &#8594; Set b) (P : A &#8594; A &#8594; Set) (cons : (s : A) (i : A) &#8594; B s i &#8594; (t : A) &#8594; P i t &#8594; P s t) &#8594;
                  {</span><span class="custom"><span class="writegood-duplicates">x x</span></span><span class="custom">&#8217; </span><span class="custom"><span class="writegood-duplicates">i i</span></span><span class="custom">&#8217; </span><span class="custom"><span class="writegood-duplicates">t t</span></span><span class="custom">&#8217; : A} {e : B x i} {e&#8217; : B x&#8217; i&#8217;} {ps : P i&#8217; t&#8217;}
                  (eqi : i&#8217; &#8801; i) (eqt : t&#8217; &#8801; t) (eqx : x&#8217; &#8801; x) (eqe : e&#8217; &#8801; &#8801;-subst&#8322; B (&#8801;-sym eqx) (&#8801;-sym eqi) e)
                &#8594; cons x i e t (&#8801;-subst&#8322; P eqi eqt ps) &#8801; &#8801;-subst&#8322; P eqx eqt (cons x&#8217; i&#8217; e&#8217; t&#8217; ps)
      helping B P cons &#8801;-refl &#8801;-refl &#8801;-refl &#8801;-refl = &#8801;-refl

      gelping :  {G : Graph} {</span><span class="custom"><span class="writegood-duplicates">x x</span></span><span class="custom">&#8217; </span><span class="custom"><span class="writegood-duplicates">i i</span></span><span class="custom">&#8217; </span><span class="custom"><span class="writegood-duplicates">t t</span></span><span class="custom">&#8217; : Graph.V G} {e : Graph._&#10230;_ G x i} {e&#8217; : Graph._&#10230;_ G x&#8217; i&#8217;} {ps : i&#8217; &#8669; t&#8217;}
                  (eqi : i&#8217; &#8801; i) (eqt : t&#8217; &#8801; t) (eqx : x&#8217; &#8801; x) (eqe : e&#8217; &#8801; &#8801;-subst&#8322; (Graph._&#10230;_ G) (&#8801;-sym eqx) (&#8801;-sym eqi) e)
                &#8594; x &#10230;[ e ]&#10230; (&#8801;-subst&#8322; _&#8669;_ eqi eqt ps) &#8801; &#8801;-subst&#8322; _&#8669;_ eqx eqt (x&#8217; &#10230;[ e&#8217; ]&#10230; ps) -- read right-to-left this says we can shunt a subst over the inductive path constructor
      gelping &#8801;-refl &#8801;-refl &#8801;-refl &#8801;-refl = &#8801;-refl

      -- or in the case of graph maps
      gelpingg : {G H : Graph} {f g : GraphMap G H} {x i t : Graph.V G} {e : Graph._&#10230;_ G x i} {ps : ver f i &#8669; ver f t}
                 (eq : Category&#8217;._&#8776;_ &#119970;&#120007;&#119990;&#120005;&#119997;&#8217; f g)
                &#8594; let veq = proj&#8321; eq in
                  ver g x &#10230;[ edge g e ]&#10230; (&#8801;-subst&#8322; _&#8669;_ </span><span class="custom"><span class="writegood-duplicates">veq veq</span></span><span class="custom"> ps) &#8801; &#8801;-subst&#8322; _&#8669;_ </span><span class="custom"><span class="writegood-duplicates">veq veq</span></span><span class="custom"> (ver f x &#10230;[ edge f e ]&#10230; ps)
      gelpingg (veq , eeq) = gelping </span><span class="custom"><span class="writegood-duplicates">veq veq</span></span><span class="custom"> veq (subst-sym (Graph._&#10230;</span><span class="custom"><span class="writegood-duplicates">_ _</span></span><span class="custom">) </span><span class="custom"><span class="writegood-duplicates">veq veq</span></span><span class="custom"> eeq)

      gg : &#8704; {x y} {f g : GraphMap x y} (f&#8776;g : Category&#8217;._&#8776;_ &#119970;&#120007;&#119990;&#120005;&#119997;&#8217; f g) {X Y : Category&#8217;.Obj&#8217; (&#119979;&#8217;&#8320; x)} {p : (&#119979;&#8217;&#8320; x Category&#8217;.&#10230; X) Y}
         &#8594; Functor&#8217;.mor&#8217; (&#119979;&#8321;&#8217; g) p &#8801; &#8801;-subst&#8322; (Category&#8217;._&#10230;_ (&#119979;&#8217;&#8320; y)) (proj&#8321; f&#8776;g) (proj&#8321; f&#8776;g) (Functor&#8217;.mor&#8217; (&#119979;&#8321;&#8217; f) p)
      gg eq {X = X} {p = .X !} rewrite (proj&#8321; eq) {X} = &#8801;-refl
      gg eq {X = X} {p = .X &#10230;[ e ]&#10230; ps} rewrite gg eq {p = ps} = gelpingg eq

      open Category &#10627;...&#10628;
      compmor : &#8704; {G H K} {f : G &#10230; H} {g : H &#10230; K} {x y} {p : x &#8669; y} &#8594; Functor&#8217;.mor&#8217; (&#119979;&#8321;&#8217; f &#10814;&#8217; &#119979;&#8321;&#8217; g) p &#8801; Functor&#8217;.mor&#8217;(&#119979;&#8321;&#8217; (f &#10814;&#8217; g)) p
      compmor {x = x} {p = .x !} = &#8801;-refl
      compmor {x = x} {p = .x &#10230;[ e ]&#10230; ps} = &#10230;-&#8801; (compmor {p = ps})

module freedom&#8217; (G : Obj &#119970;&#120007;&#119990;&#120005;&#119997;) {&#119966;&#8217; : Category&#8217; {&#8467;&#8320;} {&#8467;&#8320;} {&#8467;&#8320;} } where

  open TypedPaths G using (_! ; _&#10230;[_]&#10230;_ ;  _&#8669;_ ; _++_)
  open Category &#10627;...&#10628;

  &#953;&#8217; : G &#10230; Functor&#8217;.obj&#8217; &#119984;&#8217; (&#119979;&#8217;&#8320; G)
  &#953;&#8217; = record { ver = Id ; edge = &#955; {x} {y} e &#8594; x &#10230;[ e ]&#10230; y ! }

  lift&#8217; : G &#10230; (Functor&#8217;.obj&#8217; &#119984;&#8217;) &#119966;&#8217; &#8594; &#119979;&#8217;&#8320; G &#10230;&#8217; &#119966;&#8217;
  lift&#8217; f = record { obj&#8217; = &#955; v &#8594; ver f v ; mor&#8217; = toMap ; cong = cong ; id = &#8776;-refl ; comp = &#955; {x y z p q} &#8594; proof {x} {y} {z} {p} {q} }
     where
          toMap : &#8704; {x y} &#8594; x &#8669; y &#8594; ver f x &#10230;&#8217; ver f y
          toMap (y !) = Id&#8217;
          toMap (x &#10230;[ e ]&#10230; p) = edge f e &#10814;&#8217; toMap p
          cong : &#8704; {x y} {p q : x &#8669; y} &#8594; p &#8801; q &#8594; Category&#8217;._&#8776;_ &#119966;&#8217; (toMap p) (toMap q)
          cong &#8801;-refl = &#8776;-refl

          proof : &#8704;{x y z} {p : x &#8669; y} {q : y &#8669; z} &#8594; Category&#8217;._&#8776;_ &#119966;&#8217; (toMap (p ++ q)) (toMap p &#10814;&#8217; toMap q)
          proof {p = ._ !} = &#8776;-sym leftId&#8217; -- &#8801;-sym (Category&#8217;.leftId {!!})
          proof {p = ._ &#10230;[ e ]&#10230; ps} = &#8776;-trans (&#10814;-cong &#8776;-refl (proof {p = ps})) (&#8776;-sym (Category&#8217;.assoc &#119966;&#8217;))
{-
  property&#8217; : &#8704;{f : G &#10230; (Functor&#8217;.obj&#8217; &#119984;&#8217;) &#119966;&#8217;} &#8594; Category&#8217;._&#8776;_ &#119970;&#120007;&#119990;&#120005;&#119997;&#8217; f (&#953;&#8217; &#10814;&#8217; (Functor&#8217;.mor&#8217; &#119984;&#8217;) (lift&#8217; f))
  property&#8217; {f} = &#8801;-refl , {!now need to add setoid structure to graphs!}
-}
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>
<span class="org-level-1">* </span><span class="org-special-keyword">COMMENT</span><span class="org-level-1"> Random thoughts on: Relations &#8773; Graph Paths</span>
<span class="org-drawer">  :PROPERTIES:...
</span>Can we turn any relation into a category? Well we know that preorder relations yield categories,
so let&#8217;s consider transforming arbitrary relations to preorders.

Suppose we have a relation <span class="org-code">R : X &#8594; X &#8594; Set</span> and we want it to be a preorder such as
<span class="org-code">&#8804; : &#8469; &#8594; &#8469; &#8594; Set</span>. Then we need it to be reflexive and transitivie; that is,
<span class="org-code">&#8704; x &#8758; X &#8226; R </span><span class="org-code"><span class="writegood-duplicates">x x</span></span>, <span class="org-code">&#8704; x y &#8758; X &#8226; R x y &#8594; R y x</span>, and <span class="org-code">&#8704; x y z &#8758; X &#8226; R x y &#8594; R y z &#8594; R x z</span> are
provable, respectively.

(As it stands, this relation is precicely a graph-path!
If we want a relation in the traditional sense of ordered pairs, then we want a <span class="writegood-weasels">simple</span>-graph.
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom"><span class="writegood-weasels">simple</span></span><span class="custom"> : &#8704; {x y} (p q : R x y) &#8594; p &#8801; q    -- at most one edge between any two pair
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>)


[[

above when defined poset category, or rather after hom <span class="writegood-passive-voice">is defined</span>,

mention how intervals a..b <span class="writegood-passive-voice">are realised</span> in the cat, say via hom??

]]

Then, <span class="org-code">&#8804;R</span> is a partial order.
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">data _&#8804;R : X &#8594; X &#8594; Set where
  embed : &#8704; {x y} &#8594; R x y &#8594; x &#8804;R y                      -- existing edges
  refl  : &#8704; {x} &#8594; x &#8804;R x                                 -- empty path
  trans : &#8704; {x y z} &#8594; x &#8804;R y &#8594; y &#8804;R z &#8594; x &#8804;R z         -- path concatenation
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>Observe that <span class="org-code">embed</span> says that the order <span class="org-code">&#8804;R</span> contains <span class="org-code">R</span>.

(<span class="org-code">&#8804;R</span> is also known as the "reachiability poset of R" ??)

Usual definition is <span class="org-code">&#8804;R &#8788; R* = &#955; x y &#8594; &#931; n &#8758; &#8469; &#8226; R&#8319; x y</span> where
<span class="org-code">R&#8304; x y = (x &#8801; y)</span> and <span class="org-code">R&#8319;&#8314;&#185; x y &#8801; &#931; i &#8226; R x y &#8743; R&#8319; i y</span>; the reflexive transitive closure of
<span class="org-code">R</span>. While this is more compact, the Agda version is easier to work with and it is equivalent
since <span class="org-code">embed</span> corresponds to <span class="org-code">n=1</span>, <span class="org-code">refl</span> corresponds to <span class="org-code">n = 0</span>, and <span class="org-code">trans</span> corresponds to
the &#8216;multiplication&#8217; operation since <span class="org-code">R&#8319;&#8314;&#185; x y &#8660; &#931; a,b &#8758; &#8469; &#8226; a + b &#8801; n &#8743; &#931; i &#8226; R&#7491; x i &#8743; R&#7495; i y</span>
---or so I claim!

For example, if <span class="org-code">R = { (1,2) , (3,4) }</span> then
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">&#8804;R =
{
  (1,2) , (3,2),               -- embed
  (1,1), (2,2), (3,3),         -- refl
  -- trans gives no new pairs
}
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>An example algorithm for finding the transitive closure is Warshall&#8217;s algorithm.

Notice that if <span class="org-code">R</span> reflexive or transitive, then we do not have uniqunenss of proofs for
<span class="org-code">&#8804;R</span>. In particular, suppose <span class="org-code">R</span> is reflexive and such proofs <span class="writegood-passive-voice">are constructed</span> by <span class="org-code">r_</span>.
Then a proof of <span class="org-code">x &#8804;R x</span> can <span class="writegood-passive-voice">be obtained</span> in two ways: <span class="org-code">refl {x}</span> or <span class="org-code">embed (r x)</span>.

Now the resulting category can <span class="writegood-passive-voice">be thought</span> of as the free-category on <span class="org-code">R</span>; what&#8217;s the associated
adjunctin to this claim o mine? That is, functors from this free cat correspond to relational
homomorphisms?? Consider consulting Schmidt and Strohnelin.

Is this is the least preorder relation on R?
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">suppose &#8849; is a reflexive relation that contains R, then

given p : x &#8804;R y  --ignoring transitivity
there are two cases.

Case p = embed q. Then q yields a proof of x &#8849; y since &#8849; contians R and q is an R proof.
Case p = refl {x}. Then x &#8849; x holds since &#8849; is relfexive.

Hence, &#8804;R (ignoring transitivity) is the least reflexive relation contianing R.

Suppose &#8849; is also transitive.

Then the only remaining case is

Case p = trans q r, where q : x &#8804;R y, r : y &#8804;R z, Then by induction we have proofs
  x &#8849; y &#8849; z, but &#8849; is transitive and so we have a proof of x &#8849; z.

Thus, &#8804;R is the least preorder containing R!! Woah! Awesome!

</span><span class="org-block-end-line">#+END_EXAMPLE
</span>

Every preorder can <span class="writegood-passive-voice">be obtained</span> as the closure of its Hasse/covers relation:
<span class="org-code">&#8704; R preorder &#8226; R &#8773; &#8804;[ R ] &#8773; &#8804;[ Covers R ]</span> (in the category of relations and relation homomorphisms),
where <span class="org-code">Covers R x y &#8801; x &#8800; y &#8743; x R y &#8743; &#172; &#931; z &#8226; z &#8800; x R z R y &#8800; z</span>. ?? Is this true, or do I just
think it to be true...

In particular, taking <span class="org-code">R = &#8473;&#8345;</span>, which is a hasse relation, yields the free preorder on R
which is essentially the free category on the poset <span class="org-code">&#8804;[ R ]</span>.


----

Now R can <span class="writegood-passive-voice">be thought</span> of as a directed graph.
If we take <span class="org-code">R = { (i, i+1) &#8739; i &#8712; 0..n-1} ~
then </span><span class="org-code"><span class="org-code">&#8804;R</span></span> is the free graph on <span class="org-code">&#8473;&#8345;</span>, right??

moreover it is a total order: we can show
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">total : &#8704; {x y} &#8594; x &#8804;R y &#8846; y &#8804;R x
antisym : &#8704; {x y} &#8594; x &#8804;R y &#8594; y &#8804;R x &#8594; x &#8801; y
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>Also such categories of paths <span class="writegood-passive-voice">are known</span> as simplicies??

\url{<span class="org-link"><a href="https://ncatlab.org/nlab/show/simplex+category">https://ncatlab.org/nlab/show/simplex+category</a></span>}

\url{<span class="org-link"><a href="http://mathoverflow.net/questions/159989/internal-logic-of-the-topos-of-simplicial-sets">http://mathoverflow.net/questions/159989/internal-logic-of-the-topos-of-simplicial-sets</a></span>}

<span class="org-level-1">* </span><span class="org-special-keyword">COMMENT</span><span class="org-level-1"> Kopka D-poset                    </span><span class="org-level-1"><span class="org-tag">:CategoryTheory:Functors:Examples:</span></span>
<span class="org-drawer">  :PROPERTIES:...
</span>They&#8217;re also instances of a structure known
as a \emph{Kopka D-poset}, or Kopka difference-poset:
such a structure <span class="org-code">(D, &#8804;, &#8760;, *, 0, 1)</span> consists of a poset <span class="org-code">(D, &#8804;)</span> with least element <span class="org-code">0</span>,
greates element <span class="org-code">1</span>, abelian po-monoid <span class="org-code">(D, &#8804;, *, 1)</span>, and a binary operation
<span class="org-code">_&#8760;_ : D &#215; D &#8594; D</span> satisfying
begin{itemize}
\item <span class="org-code">a &#8804; b &#8658; b &#8760; a</span> <span class="writegood-passive-voice">is defined</span>  %% contravariance.
\item <span class="org-code">a &#8760; 0 = a</span> %% since <span class="org-code">0 &#8804; a</span> and what??
\item <span class="org-code">a &#8804; b &#8804; c &#8658; c - b &#8804; c - a</span> %% contravariance.
\item <span class="org-code">a &#8804; b &#8804; c &#8658; (c &#8760; a) &#8760; (c &#8760; b) = b &#8760; a</span> %% composition via functoricality?
\item <span class="org-code">a &#8760; (a * b) &#8804; 1 &#8760; b</span>, compare with<span class="org-latex-and-related"> $\frac{y}{y \times x} = \frac{1}{x}$.</span>
\end{itemize}

The similarity <span class="writegood-passive-voice">is obtained</span> as follows:
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="custom">Assuming

(A0) a &#8760; 0 = a, for all a
(A1) a &#8804; b &#8804; c &#8658; c &#8760; b &#8804; c &#8760; a
(A2) a &#8804; b &#8804; c &#8658; (c &#8760; a) &#8760; (c &#8760; b) = b &#8760; a

(i)
   a &#8804; b
&#8658; 0 &#8804; a &#8804; b         0 is bottom
&#8658; b &#8760; a &#8804; b &#8760; 0     (A1)
&#8658; b &#8760; a &#8804; b         (A0)

(ii) a &#8760; a = 0
Proof.
  Suffices to show a &#8760; a &#8804; 0, since 0 is bottom element.

    a &#8760; a
  = (a &#8760; 0) &#8760; (a &#8760; 0)   (A0)
  = 0 &#8760; 0               (A2) since 0 &#8804; 0 &#8804; a , since 0 bottom
  = 0                   (A0)
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>
<span class="org-level-1">* </span><span class="org-special-keyword">COMMENT</span><span class="org-level-1"> footer</span>
<span class="org-drawer">  :PROPERTIES:...
</span>
(org-babel-tangle)

---

Note the existence of: (agda2-restart)

eval: (progn (org-babel-goto-named-src-block "make-readme") (org-babel-execute-src-block) (outline-hide-sublevels 1))

NOTE that AlBasmala calls the source file NAME.org, so below we change that to
this file&#8217;s name.

<span class="bold">WARNING</span> To use agda-mode to convert agda blocks to org blocks,
the blocks cannot contain any <span class="org-code">\</span> within them!

(makunbound &#8217;agda2-include-dirs)

<span class="comment"># Local Variables&#58;</span>
<span class="comment"># eval: (visual-line-mode t)</span>
<span class="comment"># eval: (load-file "~/alhassy.github.io/content/AlBasmala.el")</span>
<span class="comment"># eval: (setq NAMEorg (buffer-name))</span>
<span class="comment"># eval: (setq pdfsLocation "~/alhassy.github.io/assets/pdfs/")</span>
<span class="comment"># eval: (setq SOURCE "<a href="https://raw.githubusercontent.com/alhassy/CatsCheatSheet/master/PathCat.lagda">https://raw.githubusercontent.com/alhassy/CatsCheatSheet/master/PathCat.lagda</a>")</span>
<span class="comment"># compile-command: (preview-article)</span>
<span class="comment"># eval: (org-mode)</span>
<span class="comment"># eval: (load-file "~/Projects/org-agda-mode/literate.el")</span>
<span class="comment"># End:</span>
</pre>
  </body>
</html>
