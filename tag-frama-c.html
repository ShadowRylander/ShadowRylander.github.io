<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://alhassy.github.io/rss.xml"
      title="RSS feed for https://alhassy.github.io/"/>
<title>Life and Computing Science</title>
<meta name="author" content="Musa Al-hassy">
<meta name="referrer" content="no-referrer">
<link href="usual-org-front-matter.css" rel="stylesheet" type="text/css" />
<link href="org-notes-style.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="images/favicon.png">


<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>

</head>
<body>
<div id="preamble" class="status"><div class="header">
  <a href="https://alhassy.github.io/">Life and Computing Science</a>
</div>
</div>
<div id="content">
<h1 class="title">Posts tagged "frama-c":</h1>
<div class="post-date">12 Jan 2019</div><h1 class="post-title"><div class="title"><a href="https://alhassy.github.io/InteractiveWayToC.html">An Interactive Way To C</a></h1></div>
<center> <img src="images/interactive_way_to_c.png" alt="Article image"
  width="450" height="450" align="top" /> </center><br><center><strong>Abstract</strong></center>
<nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org79278d5">Introduction</a>
<ul>
<li><a href="#org301f10c">Getting Started</a></li>
<li><a href="#org64673dc">A Prelude</a></li>
</ul>
</li>
<li><a href="#org8db0f86">Basic Constructs</a>
<ul>
<li><a href="#org8ffb863">Assignment</a></li>
<li><a href="#org11e2412">Sequence</a></li>
<li><a href="#orga6d9497">Skip</a></li>
<li><a href="#org2ee9a8d">Examples Using the Assignment, Sequence, Skip Rules</a></li>
<li><a href="#org0e01e04">Test; Conditional</a></li>
<li><a href="#org2de7e42">Loop</a></li>
</ul>
</li>
<li><a href="#orgd983a20">ACSL Properties</a>
<ul>
<li><a href="#orgb0a9e87">Predicates</a></li>
<li><a href="#orgaf7f0da">Logic Functions</a></li>
<li><a href="#org94ddcbb">Axiomatic Definitions</a></li>
</ul>
</li>
<li><a href="#orge1c72e5">Functions</a>
<ul>
<li><a href="#org835b0ac">What are Functions?</a></li>
<li><a href="#org9fb83d7">An Example Functional Contract</a></li>
<li><a href="#org28c7ac8">Proving is Programming</a></li>
<li><a href="#orgdbf0ea0">Maintaining The Sequence Rule</a></li>
<li><a href="#orga1cf596">Passing Arguments by Value and by Reference</a></li>
<li><a href="#orgd951e6f">Side-effects: <code>assigns</code></a></li>
<li><a href="#orgc2c9f5a">Pointer Aliasing: <code>separated</code></a></li>
<li><a href="#org3ec5b4c">Functional Composition</a></li>
</ul>
</li>
<li><a href="#org341dd03">Records</a>
<ul>
<li><a href="#org0c3edb1">Allocation of a Record</a></li>
<li><a href="#orgf0e6a55">The Four Constructs of Records</a></li>
<li><a href="#org12e0f6f">Sharing, Equality, &amp; Garbage</a></li>
<li><a href="#org7e726dd">Arrays</a></li>
</ul>
</li>
<li><a href="#orgb4b669b">Arrays &#x2013; <code>\forall, \exists</code></a></li>
<li><a href="#orge76afa1">Recursion</a>
<ul>
<li><a href="#org3a0fedf">Recursive Definitions and Fixed Point Equations</a></li>
<li><a href="#org621d337">Programming without Assignment &#x2013;the Functional Core</a></li>
</ul>
</li>
<li><a href="#orgdec375b">Hehner's Problem</a></li>
<li><a href="#orgc39c4af">Advanced Data Structures</a></li>
<li><a href="#org0e72004">The Underlying Elisp</a></li>
</ul>
</div>
</nav>

<p>
Do you know what the above program accomplishes?
If you do, did you also spot a special edge case?
</p>

<p>
We aim to present an approach to program proving in C using a minimal Emacs setup
so that one may produce literate C programs and be able to prove them correct
&#x2013;or execute them&#x2013; using a single button press; moreover the output is again in Emacs.
</p>

<p>
The goal is to learn program proving using the Frama-C tool
&#x2013;without necessarily invoking its gui&#x2013; by loading the source of this file into
Emacs then editing, executing, &amp; proving as you read along.
One provides for the formal specification of properties of C programs &#x2013;e.g., using ACSL&#x2013;
 which can then be verified for the implementations using tools that interpret such annotation
&#x2013;e.g., Frama-C invoked from within our Emacs setup.
</p>

<p>
Read on, and perhaps you'll figure out how to solve the missing <code>FixMe</code> pieces üòâ
</p>

<p>
The intent is for rapid editing and checking.
Indeed, the Frama-c gui does not permit editing in the gui, so one must switch between
their text editor and the gui.
<a href="https://orgmode.org/worg/org-tutorials/org4beginners.html">Org mode beginning at the basics</a> is a brief tutorial that covers a lot of Org and,
from the get-go, covers ‚Äúthe absolute minimum you need to know about Emacs!‚Äù
</p>

<p>
If anything, this effort can be construed as a gateway into interactive theorem proving
such as with Isabelle, Coq, or Agda.
</p>

<p>
The article <i>aims</i> to be self-contained &#x2013;not even assuming familiarity with any C!
</p>


<blockquote>
<p>
The presentation and examples are largely inspired by
</p>

<ul class="org-ul">
<li>Gilles Dowek's exquisite text <a href="https://www.springer.com/gp/book/9781848820319">Principles of Programming Languages</a>.
<ul class="org-ul">
<li>It is tremendously accessible!</li>
</ul></li>

<li>Allan Blanchard's excellent tutorial
<a href="https://allan-blanchard.fr/publis/frama-c-wp-tutorial-en.pdf">Introduction to C Program Proof using Frama-C and its WP Plugin</a>.</li>
</ul>

<p>
Another excellent and succinct tutorial is Virgile Prevosto's <a href="https://frama-c.com/download/acsl-tutorial.pdf">ACSL Mini-Tutorial</a>.
In contrast, the tutorial <a href="https://www.cs.umd.edu/class/spring2016/cmsc838G/frama-c/ACSL-by-Example-12.1.0.pdf">ACSL By Example</a> aims to provide a variety of algorithms
rendered in ACSL.
</p>
</blockquote>

<p>
There are no solutions since it's too easy to give up and look at the solutions that're
nearby. Moreover, I intend to use some of the exercises for a class I'm teaching ;-)
</p>

<div id="outline-container-org79278d5" class="outline-2">
<h2 id="org79278d5">Introduction</h2>
<div class="outline-text-2" id="text-org79278d5">
<p>
Despite its age, C is a widely used language and so is available on many platforms.
Moreover, many systems rely on code historically written in C that needs to be maintained.
</p>

<p>
The traditional way to obtain confidence that a program correctly works is to provide
inputs we believe to be representative of the actual use of the program and
verify the results we get are correct. Incidentally, the unexpected cases are often not
considered whereas they are generally the most dangerous ones.
Since we cannot test everything, we need to employ great care in selecting good tests.
</p>

<p>
Since it is hard to answer ‚ÄúIs our software tested enough?‚Äù, we consider mathematically
proving that there cannot be problems at runtime. That is, a specification of the expected
behaviour is provided, which is satisfied by the <i>resulting</i> program
&#x2013;note the order: Specify <i>then obtain</i> code! This two-stage process can produce errors
in either stage, yet whereas testing ensures ‚Äúthe program avoids the bugs we tested against‚Äù
this approach is a big step ensuring ‚Äúthe program doesn't contain bugs that don't exist in
the specification.‚Äù
</p>

<p>
The goal here is to use a tool to learn the basics of C program proof
&#x2013;Frama-C: FRAmework for Modular Analysis of C code.
In particular, to demonstrate the ability to write programs without any error
by emphasising the simple notions needed to write programs more confidently.
</p>

<p>
Testing is ‚Äòdynamic analysis‚Äô since it requires the actual execution of programs,
whereas our program proof approach is ‚Äòstatic‚Äô since no execution is performed but instead
we reason on a semantic model of the reachable states.
The semantics associated with the C language control structures and statements we will
use is known as Hoare Logic. One writes a ‚ÄúHoare Triple‚Äù <i>{G} S {R}</i> to express that
‚ÄúStarting in a given state (satisfying) <i>G</i>, the execution of <i>S</i> terminates such that the
resulting state (satisfies) R‚Äù.
</p>

<p>
How does one <i>prove</i> such a triple? Programs are constructed from a variety of pieces,
so it suffices to look at each of those. That is, <i>{G} S {R}</i> has the code <i>S</i> transform
the required predicate <i>R</i> to the given <i>G</i> &#x2013;since we usually know what is required
and it is the goal of the program. In general, we find the <i>weakest</i> precondition that
works since then it allows the largest possible number of inputs;
if <i>G</i> is at least as strong as the weakest precondition, then our program is correct but
may allow less then the largest amount of possible inputs.
</p>

<p>
For example, <i>{5 ‚â§ x ‚â§ 10} x ‚âî x + 1 { 3 ‚â§ x ‚â§ 11}</i> is a correct program that ends in state
<i>3 ‚â§ x ‚â§ 11</i>, however its precondition could be weakened to <i>2 ‚â§ x ‚â§ 10</i> thereby allowing
many more  valid inputs.
</p>

<p>
In Frama-C, we do not use curly braces like this for such assertions but instead
express our properties as code annotations using the ANSI C Specification Language
&#x2013;ACSL or ‚Äúaxel‚Äù. The weakest precondition plugin uses the annotation and the code to
automatically ensure the program is correct according to the Hoare Logic fashion
mentioned earlier.
</p>
</div>

<div id="outline-container-org301f10c" class="outline-3">
<h3 id="org301f10c">Getting Started</h3>
<div class="outline-text-3" id="text-org301f10c">
<p>
The aim of this section is to introduce the Emacs controls that bring C to life within
literate code.
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><span class="underline">Key Press</span></td>
<td class="org-left"><span class="underline">Elisp Command</span></td>
<td class="org-left"><span class="underline">Description</span></td>
</tr>

<tr>
<td class="org-left">Enter <code>&lt;s</code> then <code>TAB</code></td>
<td class="org-left">‚îÄ</td>
<td class="org-left">Produces a ‚ÄúHello World‚Äù C template program.</td>
</tr>

<tr>
<td class="org-left"><code>F6</code></td>
<td class="org-left"><code>(interpret)</code></td>
<td class="org-left">Execute currently focused code blocks in a new buffer.</td>
</tr>

<tr>
<td class="org-left"><code>F7</code></td>
<td class="org-left"><code>(show-code)</code></td>
<td class="org-left">Shows currently focused code blocks in a new buffer.</td>
</tr>

<tr>
<td class="org-left"><code>F8</code></td>
<td class="org-left"><code>(frama-c)</code></td>
<td class="org-left">Open the Frama-C gui on the currently focused code blocks.</td>
</tr>

<tr>
<td class="org-left"><code>F9</code></td>
<td class="org-left"><code>(frama-c-no-gui)</code></td>
<td class="org-left">Invoke Frama-C on the currently focused code blocks in a new buffer.</td>
</tr>
</tbody>
</table>

<p>
Which code blocks are currently under focus is controlled by the command
<code>(currently-working-with "nameHere")</code>, which produces a file <code>nameHere.c</code> that is used
for the utility functions. If multiple blocks use the same filename, then the file is
appended to.
While reading this tutorial, bring/take code blocks in/out of focus by
toggling between <code>(currently-working-with "nameHere")</code> and
<code>(not-currently-working-with "nameHere")</code> &#x2014;that is, simply prepend <code>not-</code>.
Remember to undo such a toggle when you're done with a code block.
</p>

<p>
When no name is provided to <code>[not-]currently-working-with</code>, the name of the buffer is used.
</p>
</div>

<div id="outline-container-org462864d" class="outline-4">
<h4 id="org462864d">Exercise: Hello World</h4>
<div class="outline-text-4" id="text-org462864d">
<ol class="org-ol">
<li>Insert the text <code>&lt;s</code> then press the <code>TAB</code> key.</li>
<li>A new C program template has appeared.</li>
<li>Press <code>F6</code> to execute the code in another buffer.</li>
<li>Press <code>F7</code> to inspect the code in another buffer.</li>
<li>Alter the program to output your name, press <code>F6</code>.</li>
</ol>

<p>
Now toggle that code block so that you are <code>not</code> currently working with it.
</p>
<ul class="org-ul">
<li>Make a change to the code block, such as printing 42. Notice that <code>F6</code> refers
to the old file on disk since there is no currently focused block.</li>
</ul>
</div>
</div>

<div id="outline-container-org3973b74" class="outline-4">
<h4 id="org3973b74">Exercise: Verifying Swap</h4>
<div class="outline-text-4" id="text-org3973b74">
<p>
Consider the fully annotated <code>swap</code> algorithm, i.e., remove the <code>not-</code> prefix,
</p>
<div class="org-src-container">
<pre class="src src-c" id="orgeac49e1"><span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">#include&lt;stdio.h&gt; // for IO</span>

<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@</span>
<span style="color: #96A7A9; font-style: italic;">requires \valid(a) &amp;&amp; \valid(b);</span>
<span style="color: #96A7A9; font-style: italic;">assigns *a, *b;</span>
<span style="color: #96A7A9; font-style: italic;">ensures *a == \old(*b);</span>
<span style="color: #96A7A9; font-style: italic;">ensures *b == \old(*a);</span>
<span style="color: #96A7A9; font-style: italic;">*/</span>
<span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">swap</span>(<span style="color: #b58900; font-style: italic;">int</span>* <span style="color: #268bd2;">a</span>, <span style="color: #b58900; font-style: italic;">int</span>* <span style="color: #268bd2;">b</span>)
{
  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">tmp</span> = *a;
  *a = *b;
  *b = tmp;
}

<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">main</span>()
{
  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">printf("Hello World!\n");</span>

  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">a</span> = 42;
  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">b</span> = 37;

  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ assert Before_Swap</span><span style="color: #96A7A9; font-style: italic;">: a == 442 &amp;&amp; b == 37;</span>
  swap(&amp;a, &amp;b);
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ assert After_Swap</span><span style="color: #96A7A9; font-style: italic;">: a == 37 &amp;&amp; b == 42;</span>

  <span style="color: #859900; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
We can see that Frama-C proves these assertions by obtaining ‚Äúgreen bullets‚Äù
beside them if we execute
</p>
<pre class="example">
frama-c-gui -wp -rte myfile.c
</pre>
<p>
Or check-boxes beside them if we instead execute
</p>
<pre class="example">
frama-c-gui -gui-theme colorblind -wp -rte myfile.c
</pre>
<p>
The best way to know which options are available is to use
</p>
<pre class="example">
frama-c -wp-help
</pre>

<p>
We will however use the special Emacs calls defined at the bottom of this file,
<code>frama-c</code> and <code>frama-c-no-gui</code>, to avoid having to switch between a terminal and a
text editor. Thank-you extensible editor Emacs ‚å£Ãà ‚ô•
</p>

<ul class="org-ul">
<li>Press <code>F8</code> to invoke the Frama-C gui.</li>
<li>Press <code>F9</code> to invoke Frama-C within Emacs and obtain status about the program proof.</li>
</ul>

<p>
If you uncomment the IO matter, Frama-C may yield an error.
<b>Separate your IO into its own driver file!</b>
Invoke Frama-C only on programs you want to prove &#x2013;without any IO.
</p>

<p>
Go back to the above example, and change the first assertion in <code>main,
~a == 42</code>, to assert that <code>a</code> equals <code>432</code>. Now invoke <code>M-x framac-no-gui</code>, or press <code>F9</code>,
to obtain the message,
</p>
<pre class="example">
Frama-C: 90Ôπ™ of proof complete!
</pre>
<p>
Moreover, another buffer will be open and in red will be highlighted,
</p>
<pre class="example">
[wp] [Alt-Ergo] Goal typed_main_assert_Before_Swap : Unknown (Qed:0.63ms) (57ms)
</pre>
<p>
This indicates that, in method <code>main</code>, the named assertion <code>Before_Swap</code> could not be proven.
</p>

<p>
Now revert all alterations and in the specification of <code>swap</code>, alter
<code>ensures *a ==== \old(*b);</code> to become <code>ensures *a == \old(*a);</code>, thereby expressing
that the value of <code>a</code> is unaltered by the program. Checking this yields a false
assertion! Neato.
</p>

<p>
As such, I suggest the following literate process:
</p>
<ol class="org-ol">
<li>Write your code in Org-mode code blocks,</li>
<li>Check it works with <code>frama-c-no-gui</code> (F9) or <code>frama-c</code> (F8).
<ul class="org-ul">
<li>If we open the gui, we may right-click on a function name and select
<code>Prove function annotations by WP</code> to have our assertions checked.</li>
<li>Remember that the frama-c gui does not allow source code edition.</li>
</ul></li>
<li>Investigate output, then make changes in source file and re-check.</li>
</ol>

<p>
Observe
</p>
<ul class="org-ul">
<li>Program proof is a way to ensure that our programs only have correct behaviours,
described by our specification;</li>
<li>It is still our work to ensure that this specification is correct.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org64673dc" class="outline-3">
<h3 id="org64673dc">A Prelude</h3>
<div class="outline-text-3" id="text-org64673dc">
<p>
Since C's <code>#include</code> is essentially a copy-paste, we can re-export other libraries
from a make-shift ‚ÄòPrelude‚Äô.
</p>

<div class="org-src-container">
<pre class="src src-c" id="orgafe8fe2">
<span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Artefacts so that exercises let the system progress as much as possible.</span>
<span style="color: #96A7A9; font-style: italic;">//</span>
<span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ predicate Exercise = \false;</span>
<span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ predicate FixMe = \false;</span>
<span style="color: #268bd2; font-weight: bold;">#define</span> <span style="color: #268bd2;">FixMeCode</span>

<span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Tendency to require this header file to specfiy avoidance of overflow.</span>
<span style="color: #96A7A9; font-style: italic;">//</span>
<span style="color: #268bd2; font-weight: bold;">#include</span><span style="color: #2aa198;">&lt;limits.h&gt;</span>
</pre>
</div>

<p>
We will continue to be <code>(currently-working-with "Prelude")</code> in the future to add more
content. For now, we put the artefacts needed to let the exercises pass.
</p>

<blockquote>
<p>
The use of <code>\false</code> is not the most appropriate, since its occurrence in a precondition
  vacuously makes everything true! This is something that should change.
</p>

<p>
The current setup produces only <code>.c</code> files, whence we use the prelude by declaring
<code>#include "Prelude.c".</code> Forgive my use of a <code>.c</code> file in-place of a header file.
The alternative is to force all code block names to end in a <code>.c</code>.
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-org8db0f86" class="outline-2">
<h2 id="org8db0f86">Basic Constructs</h2>
<div class="outline-text-2" id="text-org8db0f86">
<p>
Recall that a Hoare Triple <i>{G} S {R}</i> expresses that if execution of program <code>S</code> is begun
in a state satisfying proposition <i>G</i> then it terminates in a state satisfying proposition <i>R</i>.
We usually know <i>R</i> &#x2013;it is the required behaviour on <code>S</code> after all&#x2013; but otherwise we usually
only have a vague idea of what <i>G</i> could possible be.
Dijkstra's <i>weakest precondition</i> operator ‚Äòwp‚Äô tells us how to <b>compute</b> <i>G</i> from <i>R</i>
&#x2013;in the process we usually <b>discover</b> <code>S</code>.
</p>

<p>
Hence, all in all, programming begins with the required goal from which code is then derived.
</p>

<details>
<p>
Post-conditions <i>R</i> are expressed using the <code>ensures</code> clause, and dually pre-conditions <i>G</i>
are expressed using <code>requires</code> clauses. These <i>G</i> are properties assumed for the input
and it is the callers responsibility to ensure that they are true
&#x2013;recall that when a contract is breached, the implementation may behave arbitrarily.
</p>
</details>

<p>
Since ‚Äòwp‚Äô is intended to <b>compute</b> the weakest precondition establishing a given
postcondition <i>R</i> for a statement <code>S</code>, it necessarily satisfies
</p>
<pre class="example">
    { G } S { R }   ‚â°   G ‚áí wp S R
</pre>

<p>
The left side may be rendered using ACSL,
</p>
<pre class="example">
// @ assert G;
S;
// @ assert R;
</pre>

<p>
The WP plugin for Frama-C essentially works by computing <code>wp S R</code> then attempts to obtain
a proof for <code>G ‚áí wp S R</code>.
In particular, by the reflexivity of implication, ‚Äòwp‚Äô guarantees to produce a
precondition so that the following Hoare triple is valid.
</p>
<pre class="example">
   { wp S R } S { R }
</pre>

<p>
Most programming languages have, among others, five constructs:
Assignment, variable declaration, sequence, test, and loop.
These constructs from the <i>imperative core</i> of the language.
Since programs are built using such primitive control structures, it suffices to define
wp ‚Äúby induction‚Äù on the shape of <code>S</code>.
</p>

<p>
One reasonable property we impose on wp from the outset is: <br>
If <i>S</i> establishes <i>R</i> which implies <i>R‚Ä≤</i>, then <i>S</i> also establishes <i>R‚Ä≤</i>.
</p>
<pre class="example">
Monotonicity: R ‚áí R‚Ä≤   implies  wp S R ‚áí wp S R‚Ä≤
                       That is, {wp S R} S {R‚Ä≤}
</pre>
<p>
Whence for each definitional clause of wp, we must ensure this desirable property is held.
</p>

<details>
<p>

</p>

<p>
Imperative programs alter state, as such a statement <code>S</code> is essentially a function
that transforms the memory state of the computer.
Expressing in English what happens when a statement is executed is possible
for simple examples, but such explanations quickly become complicated and imprecise.
Therefore, one introduces a theoretical framework reifying statements as state transformers.
</p>

<p>
The two popular notions are the ‚Äúforwards‚Äù <code>‚ü¶S‚üß</code> moves current state to a new state,
whereas we are working with ‚Äúbackwards‚Äù <code>wp S</code> which takes a desired state and yields
a necessary previous state. The forward notion ‚Äòexecutes‚Äô a program by starting in
the empty state and stepping through each command to result in some final state.
Whereas the backwards notion takes an end goal and suggests which programming constructs
are needed to obtain it.
Hence, ‚Äòforwards‚Äô is verification whereas ‚Äòbackwards‚Äô is correct-by-construction
programming.
</p>

<p>
Suppose there is an infinite set <code>Var</code> of variables and an infinite set <code>Val</code> of values,
which are integers, booleans, etc. In the ‚Äòforwards‚Äô notion, a <i>state</i> is a partial
function from variables to values &#x2013;`partial' since it may be undefined at some
variables, since we usually use only finitely many
in our programs anyways. E.g., state <code>{x ‚Ü¶ 5, y ‚Ü¶ 6}</code> associates the value 5 to variable <code>x</code>
but is undefined for variable <code>z</code>. Dually, in the ‚Äòbackwards‚Äô notion, a <i>state</i> is a predicate of the
variables and their values that satisfy the predicate; e.g., the previous example state
corresponds to the predicate <code>x = 5 ‚àß y = 6</code>, where <code>z</code> can have <i>any</i> value.
Hence the predicate formulation is more relaxed and we shall refer to it instead.
</p>
</details>
</div>

<div id="outline-container-org8ffb863" class="outline-3">
<h3 id="org8ffb863">Assignment</h3>
<div class="outline-text-3" id="text-org8ffb863">
<p>
The <i>assignment</i> construct allows the creation of a statement with a variable
<code>x</code> and an expression <code>E</code>. The assignment statement is written <code>x = E;</code>.
</p>
<ul class="org-ul">
<li>Variables are identifiers which are written with one or more letters.</li>
<li>Expressions are composed of variables, constants, and operator calls.</li>
<li>Sometimes one <i>notates</i> assignment by <code>x ‚âî E</code> even though it is invalid C code.</li>
</ul>

<p>
To understand the execution of an assignment, suppose that within the
recesses of your computer's memory, there is a compartment labelled <code>x</code>.
Obtain the <i>value</i> of <code>E</code> &#x2013;possibly having to look up values of variables
that <code>E</code> mentions&#x2013; then erase the contents of <code>x</code> and fill the compartment
with the newly obtained value.
</p>

<p>
The whole of the contents of the computer's memory is called a <i>state</i>.
We also say ‚Äúpredicate <i>R</i> is the current state‚Äù as shorthand for:
The current state is (non-deterministically) <i>any</i> variable-value assignment
such that predicate <i>R</i> is true.
</p>

<p>
All in all, executing <code>x ‚âî E</code> loads memory location <code>x</code> with the value of expression <code>E</code>;
hence state <i>R</i> is satisfied after an assignment precisely when it is satisfied
with variable <code>x</code> replaced by expression <code>E</code>. For example, <code>wp (x ‚âî x+1) (x = 5)  ‚â°  (x+1 = 5)</code>.
</p>
<pre class="example">
wp (x ‚âî E) R  ‚â°  R[x ‚âî E]
</pre>

<p>
Before being able to assign values to a variable <code>x</code>, it must be <i>declared</i>,
which associates the name <code>x</code> to a location in the computer's memory.
<i>Variable declaration</i> is a construct that allows the creation of a statement
composed of a variable, an expression, and a statement. This is written
<code>{T x = e; p}</code>, then variable <code>x</code> can be used in statement <code>p</code>, which is called
the <i>scope</i> of variable <code>x</code>.
( When <code>p</code> has no assignments, functional programmers would call this statement
  a <i>let statement</i> since it lets <code>x</code> take on the value <code>e</code> in <code>p</code>. )
</p>

<details>
<ul class="org-ul">
<li>Division:
If both arguments are integers, then the operation rounds down; write, e.g., <code>5 / 2.0</code>
to mark the result as floating point.</li>

<li>Modulo: The number <code>a % b</code> is <code>a - b * (a / b).</code></li>

<li>Ternary Conditional: For all types, the expression <code>(c) ? t : f</code>
yields <code>t</code> if boolean <code>c</code> holds and is <code>f</code> otherwise.</li>

<li>A useful inclusion: <i>2*10<sup>9</sup> &lt;= 2<sup>32</sup> &lt;= 2*10<sup>10</sup></i></li>
</ul>
</details>
</div>

<div id="outline-container-org52ec47c" class="outline-4">
<h4 id="org52ec47c">Overshadowing &amp; Explicit Scope Delimitation</h4>
<div class="outline-text-4" id="text-org52ec47c">
<p>
Imperative languages generally do not allow the declaration of the same variable multiple
times, e.g., the following program crashes with <code>error: redefinition of ‚Äòx‚Äô</code>.
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">#include</span><span style="color: #2aa198;">&lt;stdio.h&gt;</span> <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">for IO</span>

<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">main</span>()
{
  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">x</span> = 3;
  printf(<span style="color: #2aa198;">"x has value: %d"</span>, x);

  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">x</span> = 4;
  printf(<span style="color: #2aa198;">"x has value: %d"</span>, x);

  <span style="color: #859900; font-weight: bold;">return</span> 0;
}
</pre>
</div>
<p>
However, if we <i>explicitly delimit the scope</i> of a variable by using braces, then we can
obtain multiple declarations:
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">#include</span><span style="color: #2aa198;">&lt;stdio.h&gt;</span> <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">for IO</span>

<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">main</span>()
{
  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">x</span> = 3;
  printf(<span style="color: #2aa198;">" x has value: %d"</span>, x);  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">3</span>

  { <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">x</span> = 4;
    printf(<span style="color: #2aa198;">"\n x has value: %d"</span>, x); <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">4</span>
  }
  <span style="color: #859900; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
When explicitly delimiting scope, it is the most recent declarations
that are used. We say that earlier declarations are <i>hidden</i>, or <i>overshadowed</i>,
by the later declarations.
</p>

<details>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">main</span>()
{
  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">x</span> = 3;

  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert x == 3;</span>

  { <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Begun new scope</span>

    <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Old facts are still true.</span>
    <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert x == 3;</span>

    <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Now overshadowing &#8216;x&#8217;</span>
    <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">x</span> = 4;

    <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">This new &#8216;x&#8217; is equal to 4.</span>
    <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert x == 4;</span>
  }

  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Back to the parent scope.</span>
  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">In this scope, &#8216;x&#8217; still has its orignal value.</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert x == 3;</span>

  <span style="color: #859900; font-weight: bold;">return</span> 0;
}
</pre>
</div>
</details>
</div>
</div>

<div id="outline-container-org6aeee9c" class="outline-4">
<h4 id="org6aeee9c">Constant Variables</h4>
<div class="outline-text-4" id="text-org6aeee9c">
<p>
<i>Constant variables</i> are variables which may have only one initial value that
can never be changed. A non-constant variable is called <i>mutable</i>, which is
the default in imperative languages. For example, the following
crashes with <code>error: assignment of read-only variable ‚Äòx‚Äô</code>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">#include</span><span style="color: #2aa198;">&lt;stdio.h&gt;</span> <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">for IO</span>

<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">main</span>()
{
  <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">x</span> = 3;
  x = 4;
  printf(<span style="color: #2aa198;">"x has value: %d"</span>, x);

  <span style="color: #859900; font-weight: bold;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org11e2412" class="outline-3">
<h3 id="org11e2412">Sequence</h3>
<div class="outline-text-3" id="text-org11e2412">
<p>
A <i>sequence</i> is a construct that allows a single statement to be created out of
two statements <code>p</code> and <code>q</code>; it is written <code>{p q}</code>.
The sequence is executed in state <code>s</code> by first executing <code>p</code> in state <code>s</code> thereby
producing a new state <code>s'</code> in which statement <code>q</code> is then executed.
</p>
<ul class="org-ul">
<li>The statement <code>{p‚ÇÅ {p‚ÇÇ { ... p‚Çô } ...}}</code> can also be written <code>{p‚ÇÅ p‚ÇÇ ... p‚Çô}</code>.</li>
</ul>

<p>
Usually a ‚Äò;‚Äô symbol is used in favour of a space, with braces, to yield,
</p>
<pre class="example">
wp (S‚ÇÅ;S‚ÇÇ) R  ‚â°  wp S‚ÇÅ (wp S‚ÇÇ R)
</pre>
<p>
The pre-condition of the second statement becomes the post-condition of the first
statement. Hence, we ‚Äúpush‚Äù along the post-condition into a sequence:
In the upcoming swapping example, we read the proof steps from bottom to top!
</p>

<p>
Rendered pointfree, i.e., ignoring <i>R</i>, this rule becomes: <i>wp (S‚ÇÅ;S‚ÇÇ)  = wp S‚ÇÅ ‚àò wp S‚ÇÇ</i>.
</p>

<p>
Recall that we need to ensure monotonicity is satisfied, and indeed: If <i>R ‚áí R‚Ä≤</i>, then
</p>
<pre class="example">
  wp (S‚ÇÅ;S‚ÇÇ) R
‚â° wp S‚ÇÅ (wp S‚ÇÇ R)    -- Definition of wp on sequence
‚áí wp S‚ÇÅ (wp S‚ÇÇ R‚Ä≤)   -- Monotoncity for S·µ¢, twice; with assumption R ‚áí R‚Ä≤
‚â° wp (S‚ÇÅ;S‚ÇÇ) R      -- Definition of wp on sequence
</pre>
<p>
Neato!
</p>

<p>
Moreover, notice we have the useful ‚Äòtransitivity‚Äô property for Hoare triples:
</p>
<pre class="example">
   {G} S‚ÇÅ {R‚Ä≤}  ‚àß  {R‚Ä≤} S‚ÇÇ {R}
‚â°  (G ‚áí wp S‚ÇÅ R‚Ä≤)  ‚àß  (R‚Ä≤ ‚áí wp S‚ÇÇ R)              -- Characterisation of wp
‚áí (G ‚áí wp S‚ÇÅ R‚Ä≤)  ‚àß  (wp S‚ÇÅ R‚Ä≤ ‚áí wp S‚ÇÅ (wp S‚ÇÇ R)) -- Monotonicity of wp
‚áí (G ‚áí wp S‚ÇÅ (wp S‚ÇÇ R))                           -- Transitivity of implication
‚â°  G ‚áí wp (S‚ÇÅ;S‚ÇÇ) R                               -- Definition of wp on sequence
‚â°  {G} S‚ÇÅ;S‚ÇÇ {R}                                  -- Characterisation of wp
</pre>

<p>
Exercise: Show that <code>wp (x ‚âî E; S) R  ‚â°  (wp S R)[x ‚âî E]</code>.
</p>
</div>
</div>

<div id="outline-container-orga6d9497" class="outline-3">
<h3 id="orga6d9497">Skip</h3>
<div class="outline-text-3" id="text-orga6d9497">
<p>
The ‚Äúempty sequence‚Äù is denoted <code>{}</code> or just <code>;</code> in the C language.
It is also commonly known as the <code>skip</code> construct and its importance is akin to that
of zero to addition.
</p>

<pre class="example">
wp skip R  ‚â°  R
</pre>
<p>
The ‚Äúdo nothing‚Äù program <code>skip</code> is rendered as simple <code>;</code> or as whitespace in the C language.
This program does not alter the state at all, thus it truthifies <i>R</i> precisely when <i>R</i>
was true to begin with.
</p>

<p>
Most often this appears in a weakening/strengthening form,
</p>
<pre class="example">
...code here...
//@ assert P;
//@ assert Q;
...code here...
</pre>
<p>
Where <i>P ‚áí Q</i> is provable.
</p>

<p>
More concretely,
</p>
<div class="org-src-container">
<pre class="src src-c" id="orgdec7f8f"><span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ requires 3 &lt; a &lt; 9;</span>
<span style="color: #96A7A9; font-style: italic;">  @ ensures  -20 &lt;= \result &lt;= 99;</span>
<span style="color: #96A7A9; font-style: italic;">  */</span>
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">using_skip</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">a</span>)
{
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ assert our_strong_pre</span><span style="color: #96A7A9; font-style: italic;">:         3 &lt; a &lt; 9;</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ assert weakened_intermediary</span><span style="color: #96A7A9; font-style: italic;">: -7 &lt;= a &lt;= 14;</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ assert weakening_futher</span><span style="color: #96A7A9; font-style: italic;">:     -20 &lt;= a &lt;= 99;</span>
  <span style="color: #859900; font-weight: bold;">return</span> a;
}
</pre>
</div>
<p>
Woah! It looks like the identity function somehow transforms input satisfying
<i>3 &lt; x &lt; 9</i> to input satisfying <i>-20 ‚â§ x ‚â§ 99</i>.
Wait, the former implies the latter and that's just the definition of <i>wp</i> on <code>skip</code>.
</p>

<p>
The above example suggests the following calculation,
</p>
<pre class="example">
   (G‚Ä≤ ‚áí G)  ‚àß  {G} S {R}  ‚àß  (R ‚áí R‚Ä≤)
‚â°  (G‚Ä≤ ‚áí G)  ‚àß  (G ‚áí wp S R)  ‚àß  (R ‚áí R‚Ä≤) -- Characterisation of wp
‚áí (G‚Ä≤ ‚áí wp S R)  ‚àß  (R ‚áí R‚Ä≤)              -- Transitivity of implication
‚áí (G‚Ä≤ ‚áí wp S R)  ‚àß  (wp S R ‚áí wp S R‚Ä≤)    -- Monotonicity of wp
‚áí (G‚Ä≤ ‚áí wp S R‚Ä≤)                          -- Transitivity of implication
‚â°  {G‚Ä≤} S {R‚Ä≤}                            -- Characterisation of wp
</pre>
<p>
That is, strengthening the precondition or weakening the post-condition leaves
a Hoare triple valid. In some industry circles &#x2013;e.g., C#&#x2013;, this is referred to as
contravariance (antitone) in the input and covariance (monotone) in the output.
</p>

<p>
For example, if <code>G‚Ä≤, G, R, R‚Ä≤</code> were classes such that <code>G‚Ä≤</code> is a subclass of <code>G</code>
and <code>R</code> is a subclass of <code>R‚Ä≤</code>, then the program <code>S</code> takes an input of type <code>G</code> yielding an
output of type <code>R‚Ä≤</code>. However, any input of type <code>G‚Ä≤</code> can be cast into the parent-class
type <code>G</code> and, likewise, <code>R</code> objects can be cast into the parent-type <code>R‚Ä≤</code>.
Thus, program <code>S</code> can also take the type of <code>G‚Ä≤</code> to <code>R‚Ä≤</code>.
</p>

<p>
Writing <code>&lt;:</code> for ‚Äòsub-type‚Äô, or ‚Äòsub-class‚Äô, we have argued,
</p>
<pre class="example">
Provided    G‚Ä≤ &lt;: G  and R &lt;: R‚Ä≤
Then
       G ‚Üí R  &lt;:  G‚Ä≤ ‚Üí R‚Ä≤
</pre>
<p>
It is now easier to see that the second argument of function-type former ‚Äò‚Üí‚Äô stays
on the same side of the <code>&lt;:</code> symbol, whereas it is flipped for the first argument.
</p>

<p>
Completely unrelated &#x2013;or not&#x2013; a nearly identical property holds for implication:
If <i>G‚Ä≤ ‚áí G</i> and <i>R ‚áí R‚Ä≤</i> then (G ‚áí R) ‚áí (G‚Ä≤ ‚áí R‚Ä≤). How coincidental &#x2026; or not!
\\ ( Foreshadowing: Curry-Howard Correspondence! )
</p>

<p>
Anyhow, this strengthening-weakening law will be useful when computing the <i>wp</i> of a
statement directly is difficult &#x2013;and possibly unhelpful&#x2013; but we have a stronger
precondition and so it suffices to use that.
( Foreshadowing: Loops! )
</p>

<p>
Before we close, here is an <b>exercise</b> to the reader: An alternate proof of the above law.
</p>
<pre class="example">
   (G‚Ä≤ ‚áí G)  ‚àß  {G} S {R}  ‚àß  (R ‚áí R‚Ä≤)
‚â°  {G‚Ä≤} skip {G} ‚àß {G} S {R} ‚àß {R} skip {R‚Ä≤}    -- ???
‚áí {G‚Ä≤} skip; S {R} ‚àß {R} skip {R‚Ä≤}             -- ???
‚áí {G‚Ä≤} skip; S; skip {R‚Ä≤}                      -- ???
‚â°  {G‚Ä≤} S {R‚Ä≤}                                  -- skip is no-op &amp; can be removed.
</pre>

<p>
The last hint in the above calculation deserves some attention.
</p>
<ol class="org-ol">
<li>Rendered pointfree, i.e., ignoring <i>R</i>, the skip rule becomes: <i>wp skip  = id</i>.
<ul class="org-ul">
<li>Where <i>id</i> is the identity function: <i>id(x) = x</i>.</li>
</ul></li>
<li>‚ÄúProgram Equality‚Äù: Say <code>S ‚âà T</code> precisely when <code>wp S = wp T</code>.
<ul class="org-ul">
<li>Two programs are considered equal precisely when they have the same
<i>observational</i> behaviour &#x2013;i.e., can satisfy the same set of post-conditions <i>R</i>.</li>
</ul></li>
<li>Identity of Sequence Theorem: <code>S ; skip  ‚âà  S  ‚âà  skip ; S</code>.</li>
<li>Likewise, define <i>wp abort R ‚â° false</i>  &#x2013; i.e., <code>abort</code> is a program that crashes on
any input.</li>
<li>Zero of Sequence Theorem: <code>S ; abort  ‚âà  abort  ‚âà  abort ; S</code>.</li>
</ol>
</div>
</div>

<div id="outline-container-org2ee9a8d" class="outline-3">
<h3 id="org2ee9a8d">Examples Using the Assignment, Sequence, Skip Rules</h3>
<div class="outline-text-3" id="text-org2ee9a8d">
<p>
To avoid having to write the verbose <code>\at(x, Pre)</code> to refer to the value of a variable <code>x</code>
before method execution, we may use a <i>ghost variable</i>: A variable whose purpose is only
to make the assertions provable, and otherwise is not an execution-relevant variable.
</p>

<div class="org-src-container">
<pre class="src src-c" id="org51bc572"><span style="color: #268bd2; font-weight: bold;">#include</span><span style="color: #2aa198;">&lt;limits.h&gt;</span>

<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ requires \valid(x) &amp;&amp; \valid(y);</span>
<span style="color: #96A7A9; font-style: italic;">  @ requires INT_MIN &lt; *x + *y &lt; INT_MAX;</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ requires \separated(x, y); // Exercise</span><span style="color: #96A7A9; font-style: italic;">: It's a swap, why is this needed?</span>
<span style="color: #96A7A9; font-style: italic;">  @ assigns *x, *y;</span>
<span style="color: #96A7A9; font-style: italic;">  */</span>
<span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">swap</span>(<span style="color: #b58900; font-style: italic;">int</span> *<span style="color: #268bd2;">x</span>, <span style="color: #b58900; font-style: italic;">int</span> *<span style="color: #268bd2;">y</span>)
{
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ ghost int X = *x;</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ ghost int Y = *y;</span>

  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert  *y == Y  &amp;&amp; *x == X;</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert  *y == Y  &amp;&amp; (*x + *y) - *y == X;</span>
  *x = *x + *y;
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert  *y == Y  &amp;&amp; *x - *y == X;</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert  *x - (*x - *y) == Y  &amp;&amp; *x - *y == X;</span>
  *y = *x - *y;
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert  *x - *y == Y  &amp;&amp; *y == X;</span>
  *x = *x - *y;
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert  *x == Y  &amp;&amp; *y == X;</span>

  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">&#120034;&#120061;&#120042;&#120059;&#120061; upwards reading from here;</span>
  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">each assertion is obtained by the assigment, skip, and sequence rules.</span>
}
</pre>
</div>

<p>
Here is a more complicated exercise that also makes use of external functions&#x2026;
</p>

<details>
<p>

</p>

<div class="org-src-container">
<pre class="src src-c" id="orgc6edc35"><span style="color: #268bd2; font-weight: bold;">#include</span> <span style="color: #2aa198;">"Prelude.c"</span>

<span style="color: #268bd2; font-weight: bold;">#define</span> <span style="color: #268bd2;">RAND_MAX</span> 32767

<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@</span>
<span style="color: #96A7A9; font-style: italic;">  @ assigns \nothing;</span>
<span style="color: #96A7A9; font-style: italic;">  @ ensures 0 &lt;= \result &lt;= RAND_MAX;</span>
<span style="color: #96A7A9; font-style: italic;">*/</span>
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">rand</span>();

<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ requires min &lt;= max;</span>
<span style="color: #96A7A9; font-style: italic;">  @ requires min + RAND_MAX &lt; INT_MAX;</span>
<span style="color: #96A7A9; font-style: italic;">  @ requires max - min &lt; INT_MAX;</span>
<span style="color: #96A7A9; font-style: italic;">  @ assigns \nothing;</span>
<span style="color: #96A7A9; font-style: italic;">  @ ensures min &lt;= \result &lt;= max;</span>
<span style="color: #96A7A9; font-style: italic;">*/</span>
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">random_between</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">min</span>, <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">max</span>)
{
  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">it</span> = rand();
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ assert weakening</span><span style="color: #96A7A9; font-style: italic;">: 0 &lt;= it &lt;= RAND_MAX;</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ assert assignment_rule_again</span><span style="color: #96A7A9; font-style: italic;">: FixMe;</span>
  it = it % (max - min + 1);
  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #b58900;">@ assert simplify</span><span style="color: #96A7A9; font-style: italic;">: FixMe;</span>
  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #b58900;">@ assert assignment_rule</span><span style="color: #96A7A9; font-style: italic;">: FixMe;</span>
  it = it + min;
  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">@ assert min &lt;= it;</span>

  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Start at the bottom, and push assertion upwards!</span>
  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">The assertion names are also intended to be read upwards;</span>
  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Each justifies how it was obtained.</span>

  <span style="color: #859900; font-weight: bold;">return</span> it;

  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">That is,</span>
  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">return (rand() % (max - min + 1)) + min;</span>
}
</pre>
</div>
</details>
</div>
</div>

<div id="outline-container-org0e01e04" class="outline-3">
<h3 id="org0e01e04">Test; Conditional</h3>
<div class="outline-text-3" id="text-org0e01e04">
<p>
A <i>test</i> is a statement formed from a Boolean expression and two statements; it is
written \\ <code>if (b) p else q</code> &#x2013;sometimes a ‚Äòthen‚Äô keyword is used for readability, but
such is not valid C code.
This is executed in a state by evaluating the Boolean
then deciding which branch to execute in the same state.
</p>

<pre class="example">
wp (if B then S‚ÇÅ else S‚ÇÇ) R  ‚â£  if B then wp S‚ÇÅ R else wp S‚ÇÇ R
                             ‚â° (B ‚áí wp S‚ÇÅ R) ‚àß (¬¨ B ‚áí wp S‚ÇÇ R)
</pre>
<p>
A conditional ensures <i>R</i> precisely when its branches each ensure <i>R</i>.
</p>

<p>
Observe the following calculation,
</p>
<pre class="example">
   { G } if B then S‚ÇÅ else S‚ÇÇ { R }
‚â°  G ‚áí wp (if B then S‚ÇÅ else S‚ÇÇ) R         -- Characterisation of wp
‚â°  G ‚áí (B ‚áí wp S‚ÇÅ R) ‚àß (¬¨ B ‚áí wp S‚ÇÇ R)     -- Definition of wp on conditional
‚â°  (G ‚áí B ‚áí wp S‚ÇÅ R) ‚àß (G ‚áí ¬¨ B ‚áí wp S‚ÇÇ R) -- Characterisation of meets
‚â°  (G ‚àß B ‚áí wp S‚ÇÅ R) ‚àß (G ‚àß ¬¨ B ‚áí wp S‚ÇÇ R) -- Shunting
‚â°  {G ‚àß B} S‚ÇÅ {R}  ‚àß  {G ‚àß ¬¨ B} S‚ÇÇ {R}     -- Characterisation of wp
</pre>
<p>
That is, Hoare triples on a conditional ‚Äòdistribute‚Äô into the branches
with each branch precondition obtaining the branch guard.
</p>
</div>
</div>

<div id="outline-container-org2de7e42" class="outline-3">
<h3 id="org2de7e42">Loop</h3>
<div class="outline-text-3" id="text-org2de7e42">
<p>
A <i>loop</i> is a construct formed from a Boolean expression and a statement; it is
written <code>while (b) p</code>.
A loop is one of the ways in which we can express an infinite object &#x2013;which may
fail to terminate&#x2013; using a finite expression. Indeed, its executional behaviour
can be understood by realising it as a shorthand for the expression
</p>
<pre class="example">
if (b) {p if (b) {p if (b) ...
                    else skip}
          else skip}
else skip
</pre>
<p>
Where <code>skip</code> is the fictional statement that performs no action when executed.
</p>

<p>
To understand the semantics of the loop:
</p>
<ol class="org-ol">
<li>Let <code>giveup, terminate</code> be aliases for <code>abort</code> and <code>skip</code>.</li>
<li><p>
Recalling that a loop is a shorthand for an infinite nesting of conditionals,
we try to approach it as a limit of finite approximations.
</p>
<pre class="example">
     while (b) q  ‚âà  lim‚Çô p‚Çô

  Where:
  p‚ÇÄ = if (b) giveup else terminate
  p‚ÇÅ = if (b) {q ; if b giveup else terminate} else terminate
  ‚ãØ
  p‚Çô‚Çä‚ÇÅ = if (b) {q; p‚Çô} else terminate;
</pre></li>

<li>The statement <code>p‚Çô</code> tries to execute the statement <code>while (b) q</code> by completing
a maximum of <code>n</code> trips through the loop. If, after <code>n</code> loops, it has not
terminated on its own, it gives up.</li>

<li><p>
If the loop terminates in <i>m</i> trips, it also terminates in <i>n ‚â• m</i> trips.
</p>
<ul class="org-ul">
<li><i>‚àÄ m. p‚Çò defined ‚áí ‚àÄ n ‚â• m. p‚Çô defined</i></li>
<li><i>‚àÄ m. p‚Çò defined ‚áí ‚àÄ n ‚â• m. p‚Çô ‚âà p‚Çò</i></li>
</ul>

<p>
Where ‚Äòdefined‚Äô means it terminates without aborting.
</p></li>
<li>Hence, by these two claims, we know that the sequence <i>p‚Çô</i> either never defined
or it is defined beyond a certain point, and in this case, it is constant over its domain.</li>
<li>Hence: <code>while(b) q ‚âà lim‚Çô p‚Çô</code>.</li>
</ol>

<p>
The definition of ‚Äòwp‚Äô for loops is complicated and generally unhelpful, however
from it we can prove the so called ‚ÄúInvariance Theorem‚Äù:
If a property is maintained by the body of the loop
and there is an integral value expressed using the body's variables
that starts out non-negative and is decreased by each loop pass,
then the loop will terminate and the property it maintained will be true.
</p>

<pre class="example">
   {Inv ‚àß B ‚àß bf = c} S {Inv ‚àß bf &lt; c}
‚áí
   {Inv ‚àß bf ‚â• 0}  while(B) S  {¬¨B ‚àß Inv}
</pre>
<p>
A property that is maintained to be true throughout the loop is referred to as an
<i>invariant</i>. In contrast, a value that changes through every pass
&#x2013;such as the number of passes remaining, the <code>bf</code>&#x2013; is known as a <i>variant</i>.
</p>

<p>
In Frama-C rendition,
</p>
<pre class="example">
/*@ loop invariant ‚ãØ  // property that is maintained by the loop body
  @ loop assigns ‚ãØ    // variables that are altered by the loop body
  @ loop variant ‚ãØ    // a bound on the total number of loops
  */
while(B) S;
</pre>

<p>
Incidentally the primary function of the <code>assigns</code> clause is that variables its does
not mention essentially have the invariant property of being equal to their value
before the loop. That is, the <code>assigns</code> clause reduces clutter regarding constants
from the invariant!
</p>
<details>
<div class="org-src-container">
<pre class="src src-c" id="org3ef0023"><span style="color: #268bd2; font-weight: bold;">#include</span><span style="color: #2aa198;">&lt;limits.h&gt;</span>
<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ requires N &gt;= 0;</span>
<span style="color: #96A7A9; font-style: italic;">  @ requires N * (N + 1) /2 &lt; INT_MAX;</span>
<span style="color: #96A7A9; font-style: italic;">  @ assigns \nothing;</span>
<span style="color: #96A7A9; font-style: italic;">  @ ensures \result == N * (N + 1) / 2;</span>
<span style="color: #96A7A9; font-style: italic;">  */</span>
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">euclid</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">N</span>)
{
  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">sum</span> = 0; <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">n</span> = 0;
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ assert invariant_intially_estabished</span><span style="color: #96A7A9; font-style: italic;">: 2 * sum == 0 * (0 + 1);</span>

  <span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #b58900;">@ loop invariant main_item</span><span style="color: #96A7A9; font-style: italic;">: sum == n * (n + 1) / 2;</span>
<span style="color: #96A7A9; font-style: italic;">    </span><span style="color: #b58900;">@ loop invariant always_in_range</span><span style="color: #96A7A9; font-style: italic;">: 0 &lt;= n &lt;= N;</span>
<span style="color: #96A7A9; font-style: italic;">    </span><span style="color: #b58900;">@ loop invariant range_for_sum</span><span style="color: #96A7A9; font-style: italic;">: 0 &lt;= sum;</span>
<span style="color: #96A7A9; font-style: italic;">    // Exercise: Why can we comment out the following two lines?</span>
<span style="color: #96A7A9; font-style: italic;">    </span><span style="color: #b58900;">@ loop invariant no_overflow1</span><span style="color: #96A7A9; font-style: italic;">: n &lt; INT_MAX;</span>
<span style="color: #96A7A9; font-style: italic;">    </span><span style="color: #b58900;">@ loop invariant no_overflow2</span><span style="color: #96A7A9; font-style: italic;">: sum &lt;= INT_MAX;</span>
<span style="color: #96A7A9; font-style: italic;">    @ loop assigns n, sum;</span>
<span style="color: #96A7A9; font-style: italic;">    @ loop variant N - n;</span>
<span style="color: #96A7A9; font-style: italic;">   */</span>
  <span style="color: #859900; font-weight: bold;">while</span>(n != N)
  {
    <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert sum + n &lt; INT_MAX;</span>
    n   = n + 1;
    <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert sum + n &lt;= INT_MAX;</span>
    sum = sum + n;
    <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert sum &lt;= INT_MAX;</span>
  }
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ assert invariant_and_not_guard</span><span style="color: #96A7A9; font-style: italic;">: n == N  &amp;&amp;  sum == n * (n + 1) / 2;</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ assert post_condition</span><span style="color: #96A7A9; font-style: italic;">:    sum == N * (N + 1) / 2;</span>
  <span style="color: #96A7A9; font-style: italic;">//         </span><span style="color: #96A7A9; font-style: italic;">rewrite_post:  2 * sum == N * (N + 1);  // Not true, due to &#8216;rounding&#8217;!</span>

  <span style="color: #859900; font-weight: bold;">return</span> sum;
}
</pre>
</div>
<p>
<b>Exercise:</b> Why is <code>sum ‚â§ INT_MAX</code> true at the end of the loop body? Fill in the proof:
</p>
<pre class="example">
   sum ‚â§ INT_MAX
‚â°  n * (n + 1) / 2 ‚â§ INT_MAX                     --  ???
‚áê n * (n + 1) / 2 ‚â§ N * (N + 1) / 2 ‚â§ INT_MAX   --  Transtivitity of ‚â§
‚â°  N * (N + 1) / 2 ‚â§ INT_MAX                     --  ???
‚â°  true                                          --  ???
</pre>
</details>
<p>
Here's a simple exercise,
</p>
<details>
<div class="org-src-container">
<pre class="src src-c" id="org1172e52"><span style="color: #268bd2; font-weight: bold;">#include</span><span style="color: #2aa198;">&lt;limits.h&gt;</span>

<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ requires a + 10 &lt; INT_MAX;</span>
<span style="color: #96A7A9; font-style: italic;">  @ ensures \result == \old(a) + 10;</span>
<span style="color: #96A7A9; font-style: italic;"> */</span>
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">look_ma_no_new_locals</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">a</span>)
{
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ ghost const int A = a;</span>

  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">i</span>;                   <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">So we can refer to this &#8216;i&#8217; *after* the loop.</span>
  <span style="color: #96A7A9; font-style: italic;">/* </span><span style="color: #96A7A9; font-style: italic;">// @ loop assigns ???;         // Fix me.</span>
<span style="color: #96A7A9; font-style: italic;">    @ loop invariant a == 666;      // Fix me.</span>
<span style="color: #96A7A9; font-style: italic;">    @ loop invariant 0 &lt;= i &lt;= 10;</span>
<span style="color: #96A7A9; font-style: italic;">    @ loop variant   666;           // Fix me.</span>
<span style="color: #96A7A9; font-style: italic;">    @</span><span style="color: #96A7A9; font-style: italic;">*/</span>
  <span style="color: #859900; font-weight: bold;">for</span>(i = 0; i != 10; i++) a++;
<span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ assert after_loop_guarantees</span><span style="color: #96A7A9; font-style: italic;">: i == 10  &amp;&amp; a == A + i;</span>
<span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ assert weakening_previous_gives</span><span style="color: #96A7A9; font-style: italic;">: a == A + 10;</span>
  <span style="color: #859900; font-weight: bold;">return</span> a;
}
</pre>
</div>
</details>

<p>
<b>Warning</b> Without the <code>loop assigns</code>, you are more likely to have trouble proving a loop
is correct!
</p>
<p>
Now a bit harder&#x2026;
</p>

<details>
<p>

</p>

<div class="org-src-container">
<pre class="src src-c" id="org45f86f1"><span style="color: #268bd2; font-weight: bold;">#include</span><span style="color: #2aa198;">&lt;limits.h&gt;</span>

<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ assigns \nothing;</span>
<span style="color: #96A7A9; font-style: italic;">  @ ensures 0 &lt;= \result &lt;= 1;</span>
<span style="color: #96A7A9; font-style: italic;"> */</span>
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">random_bool</span>(); <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">{ return random_between(0, 1); }</span>

<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ requires \valid(it);</span>
<span style="color: #96A7A9; font-style: italic;">  @ requires *it + max &lt;= INT_MAX;</span>
<span style="color: #96A7A9; font-style: italic;">  // @ requires FixMe -- a property on `max`;</span>
<span style="color: #96A7A9; font-style: italic;">  // @ assigns FixMe;</span>
<span style="color: #96A7A9; font-style: italic;">  @ ensures  \old(it) &lt;= it &lt;= it + max;</span>
<span style="color: #96A7A9; font-style: italic;">  */</span>
<span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">increment_randomly</span>(<span style="color: #b58900; font-style: italic;">int</span> *<span style="color: #268bd2;">it</span>, <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">max</span>)
{
   <span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ loop assigns i, *it;</span>
<span style="color: #96A7A9; font-style: italic;">     @ loop invariant *it == \at(*it, Pre) + i;</span>
<span style="color: #96A7A9; font-style: italic;">     // </span><span style="color: #b58900;">@ loop invariant range_of_i</span><span style="color: #96A7A9; font-style: italic;">: FixMe;</span>
<span style="color: #96A7A9; font-style: italic;">     // @ loop variant FixMe;</span>
<span style="color: #96A7A9; font-style: italic;">    */</span>
   <span style="color: #859900; font-weight: bold;">for</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">i</span> = 0; i != max &amp;&amp; random_bool(); i++) (*it)++;
}
</pre>
</div>
</details>
</div>
</div>
</div>

<div id="outline-container-orgd983a20" class="outline-2">
<h2 id="orgd983a20">ACSL Properties</h2>
<div class="outline-text-2" id="text-orgd983a20">
</div>

<div id="outline-container-orgb0a9e87" class="outline-3">
<h3 id="orgb0a9e87">Predicates</h3>
<div class="outline-text-3" id="text-orgb0a9e87">
<p>
Our invaraints were getting out of hand, the trouble can be mitigated by defining our own
predicates rather than just using the built in ones. However, such definitions must be
<i>functional</i> in nature: They do not produce side-effects, such as altering state.
Moreover, they are generally parameterised by a <i>label</i> that refers to the C memory state
in which they would be invoked &#x2013;within the definition we cannot however reference the
special labels <code>Here, Pre, Post</code>. Otherwise parameter passing is by value as in C.
</p>

<p>
The <code>predicate</code> keyword declares Boolean values functions:
</p>
<pre class="example">
/*@ predicate name_here {Label‚ÇÄ, ‚Ä¶, Label‚Çñ} (type‚ÇÄ arg‚ÇÄ, ‚Ä¶, type‚Çò arg‚Çò) =
  @ // A Boolean valued relationship between all these things.
  */
</pre>

<div class="org-src-container">
<pre class="src src-c" id="org8869faa"><span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">An integer memory location remains unaltered between given program points.</span>
<span style="color: #96A7A9; font-style: italic;">//</span>
<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ predicate unchanged{L0, L1} (int *i)   =  \at(*i, L0) == \at(*i, L1);</span>
<span style="color: #96A7A9; font-style: italic;"> */</span>

<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">main</span>()
{
  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">i</span> = 13, <span style="color: #268bd2;">j</span> = 12;

  <span style="color: #6c71c4; font-weight: bold;">DoSomeWork</span>:
  j = 32;

  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert unchanged{DoSomeWork, Here}(&amp;i);</span>

  <span style="color: #859900; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
More usefully, there is the need to ensure a given integer is indeed a non-negative
length of an array.
</p>
<div class="org-src-container">
<pre class="src src-c" id="orgc8b7ef1"><span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ predicate valid_array(int* arr, integer len) =</span>
<span style="color: #96A7A9; font-style: italic;">  @ 0 &lt;= len &amp;&amp; \valid(arr + (0 .. len - 1));</span>
<span style="color: #96A7A9; font-style: italic;"> */</span>
</pre>
</div>
<p>
Notice that we did not specify a memory label.
That's okay, one is provided for us and the entire definition is considered to transpire
at that memory location. In particular, unlike the previous example, we cannot refer to
distinct memory locations &#x2013;after all we haven't named any!
At the call site, the implicit memory location would be <code>Here</code> thereby referring to the
current memory state &#x2013;however we may still explicitly provide a different label at the
call site.
</p>
</div>
</div>

<div id="outline-container-orgaf7f0da" class="outline-3">
<h3 id="orgaf7f0da">Logic Functions</h3>
<div class="outline-text-3" id="text-orgaf7f0da">
<p>
Predicates must be either true or false, but <code>logic</code> functions are methods that
can be invoked in our specifications &#x2013;you may have noticed that C methods <b>cannot</b>
be called in a specification, which is reasonably since they may produce side-effects!
Since assignment, sequence, and loops rely on side effects they now suddenly become
useless and our definitions must rely on recursion.
Such logical functions generally need not worry about runtime issues such as overflow
&#x2013;which however must be handled at the call site, if need be.
</p>

<pre class="example">
/*@ logic return_type function_name {Label‚ÇÄ, ‚Ä¶, Label‚Çñ} (type‚ÇÄ arg‚ÇÄ, ‚Ä¶, type‚Çò arg‚Çò) =
  @  // A formula using the arguments arg·µ¢, possibly at labels Label·µ¢
 */

//@ logic integer factorial(integer n)  =  (n &lt;= 0) ? 1 : n * factorial(n-1);
</pre>

<p>
If we wrote a program that contained many occurrences to <code>factorial</code> then the definition
would need to be invoked each time. If the occurrences all happened, for example, on the
same input, say 12 &#x2013;any larger would be an <code>unsigned int</code> overflow&#x2013; then it might
make matters faster if we simply had that as a <i>lemma</i> that is proven once and used many
times by the underlying provers. Indeed this can be accomplished by using the <code>lemma</code>
phrase, and this can be done for any property.
</p>

<pre class="example">
//@ lemma name_of_property {Label‚ÇÄ, ‚Ä¶, Label‚ÇÄ}:  property_here ;
</pre>

<p>
For example,
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ lemma lt_plus_lt</span><span style="color: #96A7A9; font-style: italic;">: \forall integer i,j; i &lt; j ==&gt; i + 1 &lt; j + 1;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org94ddcbb" class="outline-3">
<h3 id="org94ddcbb">Axiomatic Definitions</h3>
<div class="outline-text-3" id="text-org94ddcbb">
<p>
Sometimes a proof may take too long to be proven, or it cannot be proven with the
back-end provers, and, moreover, we do not wish to bother with its proof directly.
In such cases, we may tell Frama-C to trust our judgement and take our word for it
&#x2013;if we're not careful, our ‚Äòword‚Äô may lead us to conclude <i>false = true</i>!
</p>

<div class="org-src-container">
<pre class="src src-c" id="org5e646b8"><span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ axiomatic my_axioms {</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ axiom antisymmetry</span><span style="color: #96A7A9; font-style: italic;">: \forall integer i, j; i &lt;= j &lt;= i  ==&gt;  i == j;</span>
<span style="color: #96A7A9; font-style: italic;">  @ }</span>
<span style="color: #96A7A9; font-style: italic;">*/</span>
</pre>
</div>

<p>
Unlike lemmas, which require a proof, axioms are simply assumed to be true.
It is the responsibility of the user to ensure no inconsistencies arise, as in:
</p>
<div class="org-src-container">
<pre class="src src-c" id="org44766d0"><span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ axiomatic UhOh{ axiom false_is_true</span><span style="color: #96A7A9; font-style: italic;">: \false; }</span>

<span style="color: #b58900; font-style: italic;">int</span> main()
{
  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Examples of proven properties</span>

  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert \false;</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert \forall integer x; x == 31;</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert \false == \true;</span>
  <span style="color: #859900; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
However, <code>axiomatic</code> definitions of recursive functions are useful since the underlying
provers do not unroll the recursion when possible
&#x2013;after all, we are simply declaring the type of a function and some properties about
it, which incidentally, happen to be its defining equations.
</p>

<div class="org-src-container">
<pre class="src src-c" id="orgc38f531"><span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ axiomatic Factorial</span>
<span style="color: #96A7A9; font-style: italic;">  {</span>
<span style="color: #96A7A9; font-style: italic;">     logic integer factorial(integer n);</span>

<span style="color: #96A7A9; font-style: italic;">     axiom factorial_base: \forall integer i;  i &lt;= 0  ==&gt;  factorial(i) == 0;</span>
<span style="color: #96A7A9; font-style: italic;">     axiom factorial_inductive:</span>
<span style="color: #96A7A9; font-style: italic;">          \forall integer i; i &gt;  0  ==&gt;  factorial(i) == i * factorial(i - 1);</span>
<span style="color: #96A7A9; font-style: italic;">  }</span>
<span style="color: #96A7A9; font-style: italic;">*/</span>
</pre>
</div>

<p>
A small subtlety is that access to memory locations must be specified in the function
headers, for example:
</p>
<div class="org-src-container">
<pre class="src src-c" id="orga732394"><span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ axiomatic is_constant</span>
<span style="color: #96A7A9; font-style: italic;">  {</span>
<span style="color: #96A7A9; font-style: italic;">     predicate constant{L}(int * a, integer b, integer e, integer val) reads a[b .. e-1];</span>

<span style="color: #96A7A9; font-style: italic;">     axiom constant_empty{L}:</span>
<span style="color: #96A7A9; font-style: italic;">       \forall int * a, integer b, e, val; b &gt;= e  ==&gt; constant{L}(a, b, e, val);</span>

<span style="color: #96A7A9; font-style: italic;">     axiom constant_non_empty{L}:</span>
<span style="color: #96A7A9; font-style: italic;">       \forall int * a, integer b, e, val; b &lt; e ==&gt;</span>
<span style="color: #96A7A9; font-style: italic;">          ( constant{L}(a,b,e, val)  &lt;==&gt;  constant{L}(a,b,e-1, val) &amp;&amp; a[e-1] == val );</span>
<span style="color: #96A7A9; font-style: italic;">  }</span>
<span style="color: #96A7A9; font-style: italic;">*/</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orge1c72e5" class="outline-2">
<h2 id="orge1c72e5">Functions</h2>
<div class="outline-text-2" id="text-orge1c72e5">
<p>
We will be proving code blocks satisfy Hoare triples, but code blocks are essentially
methods with the given predicate acting as a pre-condition and the required predicate
acting as post-condition. As such, we investigate Hoare triples by using methods.
</p>

<p>
A contract stipulates under what conditions a method will behave
&#x2013;if those conditions are not met, then it's behaviour may be arbitrary.
For example, a method may behave in a manner ensuring \\ <code>x &gt; 1/y</code> under the condition <code>y &gt; 0</code>,
and it may do anything it wants &#x2013;such as aborting the system or setting <code>x = -1</code>&#x2013;
when that condition is not met.
</p>

<p>
All in all, a function call establishes property <i>R</i> precisely when evaluating its
arguments then executing the function body together establish the property.
</p>
<pre class="example">
wp ‚Ñ±(t‚ÇÅ, ‚Ä¶, t‚Çô) R  ‚â°  wp (x‚ÇÅ ‚âî t‚ÇÅ; ‚ãØ ; x‚Çô ‚âî t‚Çô; ‚Ñ¨) R

where ‚Ñ±(x‚ÇÅ, ‚Ä¶, x‚Çô) = ‚Ñ¨  -- Definition of ‚Ñ±
</pre>
</div>

<div id="outline-container-org835b0ac" class="outline-3">
<h3 id="org835b0ac">What are Functions?</h3>
<div class="outline-text-3" id="text-org835b0ac">
<p>
Functions permit abstraction over program design since parts may
be constructed independently and also promotes avoidance of repetition.
</p>

<p>
Unlike functional languages where the result of a function is the final
term in its body, imperative languages signal result values by the <code>return</code> keyword;
which immediately stops execution of the function regardless of the keyword's position.
</p>

<p>
Functions which return no value but instead perform some effectful action, i.e., are <i>procedures</i>,
are marked with the <code>void</code> keyword in-place of a return type &#x2013;surprisingly, this ‚Äòreturn type‚Äô
is not a type at all! One cannot declare a variable of type <code>void</code>.
</p>

<p>
Function calls that yield a value are terms whereas those that do not constitute statements.
</p>
<details>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">#include</span><span style="color: #2aa198;">&lt;stdio.h&gt;</span> <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">for IO</span>

<span style="color: #b58900; font-style: italic;">int</span>  <span style="color: #b58900;">f</span>(){ <span style="color: #859900; font-weight: bold;">return</span> 3;}
<span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">g</span>(){ printf(<span style="color: #2aa198;">"g(): Hello There!"</span>); }

<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">main</span>()
{
  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Valid invocations</span>
  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">x</span> = f();
  f();           <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Bad form! Result is discarded.</span>
  g();

  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">T y = g(); // Type error! No possible type T!</span>
  <span style="color: #859900; font-weight: bold;">return</span> 0;
}
</pre>
</div>
</details>

<p>
A <i>program</i> is an sequence of global variables, function declarations, then a special
function called <code>main</code>. Since sequences are ordered, all names are declared before use!
In C, <code>main</code> usually exits with <code>return 0</code>. Global variables tend to pollute
the namespace and are more trouble than they're worth, so we shall ignore them
&#x2013;however they are already included by default since assignment is a top-level construct.
Incidentally, function declarations with no arguments may be used to simulate global
constants.
</p>

<p>
Note that C does not permit function overloading.
Moreover, C uses the same namespace for methods as well as simple variables
&#x2013;which in is not the case in, say, Java which permits naming a method <code>f</code> and a
variable <code>f</code> to obtain the valid invocation <code>f(f)</code>!
</p>

<details>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">it</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">x</span>){ <span style="color: #859900; font-weight: bold;">return</span> x; }
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">it</span> = 5;
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">maybe</span> = it(it);
</pre>
</div>
</details>
</div>

<div id="outline-container-orgcd2e011" class="outline-4">
<h4 id="orgcd2e011">Effectful Expressions</h4>
<div class="outline-text-4" id="text-orgcd2e011">
<p>
In C, any expression followed by a semicolon is a statement:
The value of the expression is simply ignored when it is used as a statement.
</p>

<p>
Conversely, statements may be regarded as an effectful expression.
For example, assignment <code>x ‚âî E</code> assigns the value of <code>E</code> to <code>x</code> and <i>returns</i> the value of <code>E</code>.
Whence, the notion of
</p>
<details>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">continued_assgns</span>()
{
  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">x</span> = 1, <span style="color: #268bd2;">y</span> = 2, <span style="color: #268bd2;">z</span> = 4;

  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert x == 1  &amp;&amp;  y == 2  &amp;&amp; z == 4;</span>

  x -= y += z;         <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Assignments are right-associative!</span>

  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert z == 4  &amp;&amp;  y == 2+4  &amp;&amp; x == 1-(2+4);</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert z == 4  &amp;&amp;  y == 6    &amp;&amp; x == -5;</span>
}
</pre>
</div>
</details>
</div>
</div>
</div>

<div id="outline-container-org9fb83d7" class="outline-3">
<h3 id="org9fb83d7">An Example Functional Contract</h3>
<div class="outline-text-3" id="text-org9fb83d7">
<p>
Look at the definition of <code>abs</code> below and notice:
</p>

<ul class="org-ul">
<li>Frama-C contracts are comments beginning with an <code>@</code> symbol and concluded with a <code>;</code> symbol.</li>
<li>The post-condition is introduced with the <code>ensures</code> clause; which may contain the
<code>\result</code> keyword to refer to the returned value of the method.</li>
<li>We may combine multiple <code>ensures</code> clauses by using conjunction <code>&amp;&amp;</code>, or have them on
separate lines. We may also use implication <code>==&gt;</code>, disjunction <code>||</code>, negation <code>!</code>,
value equality <code>==</code>, and Boolean equivalence <code>&lt;==&gt;</code>.
<ul class="org-ul">
<li>Notice that implication:  <code>A ==&gt; B</code> informs that when <code>A</code> is true then so is <code>B</code>,
and if <code>A</code> is false then we don't care and consider the whole thing to be true.</li>
</ul></li>
<li>Notice that we may <i>name</i> our conditions, which is helpful to remind us of their purpose
as well as being helpful in the frama-c output.</li>
</ul>

<div class="org-src-container">
<pre class="src src-c" id="org83869cf"><span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #b58900;">@ ensures always_nonnegative</span><span style="color: #96A7A9; font-style: italic;">: \result &gt;= 0;</span>
<span style="color: #96A7A9; font-style: italic;">  @ ensures val &gt; 0  ==&gt;  \result == val;</span>
<span style="color: #96A7A9; font-style: italic;">  @ ensures val &lt; 0  ==&gt;  \result == -val;</span>
<span style="color: #96A7A9; font-style: italic;"> */</span>
<span style="color: #b58900; font-style: italic;">int</span> abs(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">val</span>)
{
  <span style="color: #859900; font-weight: bold;">return</span> (val &lt; 0) ? -val : val;
}
</pre>
</div>

<p>
Pressing <code>F9</code>, you will notice that we are also checking for runtime errors by using the RTE plugin
whose goal is to ensure the program cannot create runtime errors such as integer overflow,
invalid pointer dereferencing, division by 0, etc.
</p>

<p>
In our case, we have runtime problems that do not crash but instead produce logical errors:
The return value of <code>abs</code> is not positive! Indeed, in addition to the above block, add focus
to the following block by removing the prefix <code>-not</code>, then run the code with <code>F6</code> to see the output.
&#x2013;Remember to undo this alteration when you're done, otherwise the next invocation to frama-c
will take a while dealing with <code>printf</code>!
</p>
<div class="org-src-container">
<pre class="src src-c" id="orgc18dcb7"><span style="color: #268bd2; font-weight: bold;">#include</span><span style="color: #2aa198;">&lt;stdio.h&gt;</span>   <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">for IO</span>
<span style="color: #268bd2; font-weight: bold;">#include</span><span style="color: #2aa198;">&lt;limits.h&gt;</span>  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">bounds on integers</span>
<span style="color: #268bd2; font-weight: bold;">#include</span><span style="color: #2aa198;">&lt;math.h&gt;</span>

<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">main</span>()
{
  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Our implementation is faulty..</span>
  printf(<span style="color: #2aa198;">"    INT_MIN      = %d\n"</span>, INT_MIN);
  printf(<span style="color: #2aa198;">"abs(INT_MIN)     = %d\n\n"</span>, abs(INT_MIN));

  printf(<span style="color: #2aa198;">"    INT_MIN + 1  = %d\n"</span>, INT_MIN+1);
  printf(<span style="color: #2aa198;">"abs(INT_MIN + 1) = %d\n\n"</span>, abs(INT_MIN+1));

  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Using standard library works..</span>
  printf(<span style="color: #2aa198;">"fabs(INT_MIN)    = %.0f"</span>, fabs(INT_MIN));

  <span style="color: #859900; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
The WP plugin forms the necessary proof obligations to ensure the program meets its
specification, simplifies them using a module called <code>Qed</code>, then asks a prover such as
<code>Alt-Ergo</code> whether the obligation is provable or not. Sometimes a property is not
verified for two possible reasons:
</p>
<ol class="org-ol">
<li>There is not enough information &#x2013;e.g., given assumptions&#x2013; for the proof to go through.</li>
<li>The proof search timed-out &#x2013;which can be configured.</li>
</ol>
</div>

<div id="outline-container-org50e6164" class="outline-4">
<h4 id="org50e6164">Exercise: Fixing <code>abs</code></h4>
<div class="outline-text-4" id="text-org50e6164">
<ol class="org-ol">
<li>Remove focus from the <code>main()</code> code block.</li>
<li>Go back to the Incomplete Absolute Value code block.</li>
<li>Include the limits header file.</li>
<li>Add <code>@ requires INT_MIN &lt; val;</code> to the top of the function contract.</li>
<li>Check that the contract passes by pressing <code>F9</code>.</li>
<li>What bound conditions can you place on the result?</li>
<li>Experiment by altering the conditions or method body.</li>
</ol>
</div>
</div>

<div id="outline-container-orge122993" class="outline-4">
<h4 id="orge122993">Behaviours</h4>
<div class="outline-text-4" id="text-orge122993">
<p>
Notice that our absolute value function has two disjoint behaviours
&#x2013;depending on whether the input is positive or negative.
Each behaviour has some assumptions and some conclusions.
Moreover, our behaviours are
</p>
<ul class="org-ul">
<li><code>disjoint</code>: Every input can only satisfy the assumptions of <i>at most</i> one of the behaviours.
As such, the program is ‚Äòdeterministic‚Äô: At most one of the behaviours is possible.
&#x2013;The program is really a relation and this ensures it is <i>univalent</i>; i.e., a <i>partial function</i>&#x2013;</li>
<li><code>complete</code>: Every input satisfies the assumptions of <i>at least</i> one of the behaviours.
As such, the program is ‚Äòtotal‚Äô: At least one behaviour is possible.
&#x2013;The program is really a relation and this ensures it is <i>total</i>; i.e., defined on all
inputs&#x2013;</li>
</ul>

<p>
We expressed our behaviours in the forms <code>ensures ‚ü®assumptions‚ü©  ==&gt;  ‚ü®consequences‚ü©</code>.
However this can get unruly when there are many assumptions and many consequences.
Moreover, expressing disjointness is tedious and error-prone even in our little
example, below, where it becomes the assertion: (<code>val &lt; 0 &amp;&amp; val &gt;= 0) &lt;==&gt; \false</code>.
As such there is the alternative <code>behavior</code> syntax &#x2013;note the American spelling!
Using this syntax, we can ask WP to verify that the behaviours are complete or disjoint,
or both.
</p>

<div class="org-src-container">
<pre class="src src-c" id="orgdda6624"><span style="color: #268bd2; font-weight: bold;">#include</span><span style="color: #2aa198;">&lt;limits.h&gt;</span>
<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ requires INT_MIN &lt; val;</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ ensures always_nonnegative</span><span style="color: #96A7A9; font-style: italic;">: \result &gt;= 0;</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ behavior positive_input</span><span style="color: #96A7A9; font-style: italic;">:</span>
<span style="color: #96A7A9; font-style: italic;">  @    assumes val &gt; 0;</span>
<span style="color: #96A7A9; font-style: italic;">  @    ensures \result == val;</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ behavior negative_input</span><span style="color: #96A7A9; font-style: italic;">:</span>
<span style="color: #96A7A9; font-style: italic;">  @    assumes val &lt;= 0;</span>
<span style="color: #96A7A9; font-style: italic;">  @    ensures \result == -val;</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  @ complete behaviors;</span>
<span style="color: #96A7A9; font-style: italic;">  @ disjoint behaviors;</span>
<span style="color: #96A7A9; font-style: italic;"> */</span>
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">abs</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">val</span>)
{
  <span style="color: #859900; font-weight: bold;">return</span> (val &lt; 0) ? -val : val;
}
</pre>
</div>

<details>
<p>

</p>

<p>
<b>Exercise</b>
Replace each FixMe so that the program is proven correct.
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">#include</span> <span style="color: #2aa198;">"Prelude.c"</span>
<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ requires INT_MIN &lt; val;</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ ensures always_nonnegative</span><span style="color: #96A7A9; font-style: italic;">: \result &gt;= 0;</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ ensures Exercise</span><span style="color: #96A7A9; font-style: italic;">:</span>
<span style="color: #96A7A9; font-style: italic;">  @      FixMe                             // Positive case</span>
<span style="color: #96A7A9; font-style: italic;">  @   &amp;&amp; (val &lt;= 0  ==&gt; \result == -val)   // Negative or 0 case</span>
<span style="color: #96A7A9; font-style: italic;">  @   &amp;&amp; !(val &gt; 0 &amp;&amp; val &lt;= 0)            // Disjointness condition</span>
<span style="color: #96A7A9; font-style: italic;">  @   &amp;&amp; FixMe                             // Completeness condition</span>
<span style="color: #96A7A9; font-style: italic;">  @   ;</span>
<span style="color: #96A7A9; font-style: italic;"> */</span>
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">abs</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">val</span>)
{
  <span style="color: #859900; font-weight: bold;">return</span> (val &lt; 0) ? -val : val;
}
</pre>
</div>

<p>
<b>Exercise</b>
Replace each FixMe with the weakest proposition so that the program is proven correct.
</p>

<div class="org-src-container">
<pre class="src src-c" id="org4c83d12"><span style="color: #268bd2; font-weight: bold;">#include</span> <span style="color: #2aa198;">"Prelude.c"</span>
<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ requires INT_MIN &lt; val;</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ ensures always_nonnegative</span><span style="color: #96A7A9; font-style: italic;">: \result &gt;= 0;</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ behavior positive_input</span><span style="color: #96A7A9; font-style: italic;">:</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@    assumes Exercise</span><span style="color: #96A7A9; font-style: italic;">: FixMe;</span>
<span style="color: #96A7A9; font-style: italic;">  @    ensures \result == val;</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ behavior negative_input</span><span style="color: #96A7A9; font-style: italic;">:</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@    assumes Exercise</span><span style="color: #96A7A9; font-style: italic;">: FixMe;</span>
<span style="color: #96A7A9; font-style: italic;">  @    ensures \result == -val;</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  @ complete behaviors;    // Frama-C complain here, but please fix the &#8220;Exercises&#8221;!</span>
<span style="color: #96A7A9; font-style: italic;"> */</span>
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">abs</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">val</span>)
{
  <span style="color: #859900; font-weight: bold;">return</span> (val &lt; 0) ? -val : val;
}
</pre>
</div>

<p>
<b>Exercise</b>
Replace each FixMe with the strongest proposition so that the program is proven correct.
</p>

<div class="org-src-container">
<pre class="src src-c" id="orgdeeceea"><span style="color: #268bd2; font-weight: bold;">#include</span> <span style="color: #2aa198;">"Prelude.c"</span>
<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ requires INT_MIN &lt; val;</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ ensures always_nonnegative</span><span style="color: #96A7A9; font-style: italic;">: \result &gt;= 0;</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ behavior positive_input</span><span style="color: #96A7A9; font-style: italic;">:</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@    assumes Exercise</span><span style="color: #96A7A9; font-style: italic;">: FixMe;</span>
<span style="color: #96A7A9; font-style: italic;">  @    ensures \result == val;</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ behavior negative_input</span><span style="color: #96A7A9; font-style: italic;">:</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@    assumes Exercise</span><span style="color: #96A7A9; font-style: italic;">: FixMe;</span>
<span style="color: #96A7A9; font-style: italic;">  @    ensures \result == -val;</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  @ disjoint behaviors;</span>
<span style="color: #96A7A9; font-style: italic;"> */</span>
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">abs</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">val</span>)
{
  <span style="color: #859900; font-weight: bold;">return</span> (val &lt; 0) ? -val : val;
}

<span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">This program passes 100%, but that is because it assumes false, the &#8220;FixMe&#8221;.</span>
</pre>
</div>
</details>
</div>
</div>
</div>
<div id="outline-container-org28c7ac8" class="outline-3">
<h3 id="org28c7ac8">Proving is Programming</h3>
<div class="outline-text-3" id="text-org28c7ac8">
<p>
In this section we step back a little to get more comfortable with <code>requires</code>
preconditions and <code>ensures</code> postconditions. Moreover, we use this time to remind
ourselves of some elementary logic. After all, we use logic to express properties
and hope Frama-C can verify them.
</p>

<p>
In some sense <i>false, true</i> behave for the ùîπooleans as <i>-‚àû, +‚àû</i> behave for the ‚Ñïumbers.
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><span class="underline">ùîπooleans</span></td>
<td class="org-left"><span class="underline">‚Ñïumbers</span></td>
</tr>

<tr>
<td class="org-left">p ‚áí true</td>
<td class="org-left">n ‚â§ +‚àû</td>
</tr>

<tr>
<td class="org-left">false ‚áí p</td>
<td class="org-left">-‚àû ‚â§ n</td>
</tr>

<tr>
<td class="org-left">Implication ‚áí</td>
<td class="org-left">Inclusion ‚â§</td>
</tr>

<tr>
<td class="org-left">Conjunction ‚àß</td>
<td class="org-left">Minimum ‚Üì</td>
</tr>

<tr>
<td class="org-left">Disjunction ‚à®</td>
<td class="org-left">Maximum ‚Üë</td>
</tr>
</tbody>
</table>

<p>
Using this correspondence we can rephrase the ‚ÄúGolden Rule‚Äù <i>p ‚àß q ‚â° p ‚â° q ‚â° p ‚à® q</i>
as the following trivial property <i>x ‚Üì y = x  ‚â°  y = x ‚Üë y</i>
&#x2013;‚ÄúThe minimum of two numbers is the first precisely when the second is their maximum.‚Äù
Neat Stuff!
</p>

<details>
<p>

</p>

<p>
<b>Ex falso quodlibet</b> From <i>false</i>, anything follows: <i>false ‚áí p,</i> for any <i>p</i>.
Edit <code>FixMe</code> in the following snippet so that it ensures the result is equal to 42.
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">#include</span> <span style="color: #2aa198;">"Prelude.c"</span>
<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #b58900;">@ requires uhOh</span><span style="color: #96A7A9; font-style: italic;">: a &lt; 0 &amp;&amp; a &gt; 0;</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ ensures  what: Exercise</span><span style="color: #96A7A9; font-style: italic;">: FixMe;</span>
<span style="color: #96A7A9; font-style: italic;">  */</span>
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">id</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">a</span>){ <span style="color: #859900; font-weight: bold;">return</span> a;}
</pre>
</div>

<p>
<b>Right Identity of Implication</b> Everything implies <i>true</i>; that is <i>p ‚áí true,</i> for any <i>p</i>.
Edit <code>FixMe</code> in the following snippet so that it there are no errors.
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">#include</span> <span style="color: #2aa198;">"Prelude.c"</span>
<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #b58900;">@ requires Exercise</span><span style="color: #96A7A9; font-style: italic;">: FixMe;   // &lt;-- Change this false positive.</span>
<span style="color: #96A7A9; font-style: italic;">  @ ensures \true;</span>
<span style="color: #96A7A9; font-style: italic;">  */</span>
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">id</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">a</span>){ <span style="color: #859900; font-weight: bold;">return</span> a; }
</pre>
</div>

<p>
<b>Exercise</b>
Replace each <code>FixMe</code> with the weakest possible predicate so that it passes.
</p>
<div class="org-src-container">
<pre class="src src-c" id="org08a7324"><span style="color: #268bd2; font-weight: bold;">#include</span> <span style="color: #2aa198;">"Prelude.c"</span>
<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ requires \true;</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ ensures UpperBound</span><span style="color: #96A7A9; font-style: italic;">: a &lt;= \result  &amp;&amp;  b &lt;= \result;</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ ensures Exercise: Selection1</span><span style="color: #96A7A9; font-style: italic;">: FixMe  ==&gt; \result == b;</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ ensures Exercise: Selection2</span><span style="color: #96A7A9; font-style: italic;">: FixMe  ==&gt; \result == a;</span>
<span style="color: #96A7A9; font-style: italic;">  @</span><span style="color: #96A7A9; font-style: italic;">*/</span>
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">max</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">b</span>)
{
  <span style="color: #859900; font-weight: bold;">return</span> a &lt; b ? b : a;
}
</pre>
</div>

<p>
Conversely, that maximum is the least upper bound,
<i>x ‚â§ z  ‚àß  y ‚â§ z  ‚â°  x ‚Üë y ‚â§ z</i>, corresponds to the
characterisation of disjunction <i>(p ‚áí r) ‚àß (q ‚áí r)  ‚â°  (p ‚à® q) ‚áí r</i>
&#x2013;incidentally this is also known as ‚Äúcase analysis‚Äù since one proves
<i>p ‚à® q ‚áí r</i> by providing a proofs that if <i>p ‚à® q</i> is true due to <i>p</i> then
with <i>p</i> in hand we need to show <i>r</i>, and likewise if <i>p ‚à® q</i> is true due to <i>q</i>.
</p>

<p>
<b>Exercise</b>
Replace <code>FixMeCode</code> with the least amount of code so that the following passes.
</p>
<div class="org-src-container">
<pre class="src src-c" id="orgbd9daad"><span style="color: #268bd2; font-weight: bold;">#include</span> <span style="color: #2aa198;">"Prelude.c"</span>
<span style="color: #268bd2; font-weight: bold;">#define</span> <span style="color: #b58900;">max</span>(<span style="color: #268bd2;">a</span>,<span style="color: #268bd2;">b</span>) (a &lt; b ? b : a)   <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Ignore me.</span>

<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ requires max(a, b) &lt;= c;</span>
<span style="color: #96A7A9; font-style: italic;">  @ ensures a &lt;= c  &amp;&amp;  b &lt;= c;</span>
<span style="color: #96A7A9; font-style: italic;">  @</span><span style="color: #96A7A9; font-style: italic;">*/</span>
<span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">case_analysis</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">b</span>, <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">c</span>)
{
  FixMeCode;
}
</pre>
</div>
</details>
</div>
</div>

<div id="outline-container-orgdbf0ea0" class="outline-3">
<h3 id="orgdbf0ea0">Maintaining The Sequence Rule</h3>
<div class="outline-text-3" id="text-orgdbf0ea0">
<p>
Since function calls may alter memory state, the computation of a term may now
not only produce a value, as before, but also alter the state altogether.
( Foreshadowing: The <code>assigns</code> ACSL keyword! )
</p>

<p>
Since a <code>return</code> interrupts executation, the sequence computation rule
<code>wp (S‚ÇÅ;S‚ÇÇ) = wp S‚ÇÅ ‚àò wp S‚ÇÇ</code> is no longer valid when the execution of <code>S‚ÇÅ</code> causes the
execution of a <code>return</code> thereby necessitating that <code>S‚ÇÇ</code> is not executed.
As we have already seen, we keep the rule valid by simply defining <code>wp U R ‚â° true</code>
for any unreachable code <code>U</code> &#x2013;as is <code>S‚ÇÇ</code> when <code>S‚ÇÅ</code> has a return.
</p>

<p>
That is, unreachable assertions are always ‚Äòtrue‚Äô:
They are never in a memory state, and so cannot even be evaluated, let alone be false!
</p>
<div class="org-src-container">
<pre class="src src-c" id="org0bad785"><span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">main</span>()
{
  <span style="color: #859900; font-weight: bold;">goto</span> <span style="color: #6c71c4; font-weight: bold;">End</span>;
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@assert my_cool_nonsense</span><span style="color: #96A7A9; font-style: italic;">: 0 == 1;    // This is unreachale but &#8216;true&#8217;.</span>

  <span style="color: #6c71c4; font-weight: bold;">End</span>:
  <span style="color: #859900; font-weight: bold;">return</span> 0;
}
</pre>
</div>
<p>
Likewise with infinite loops,
</p>
<div class="org-src-container">
<pre class="src src-c" id="org603b72c"><span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">main</span>()
{
  <span style="color: #859900; font-weight: bold;">while</span>(1 &gt; 0);
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@assert my_cool_nonsense</span><span style="color: #96A7A9; font-style: italic;">: 0 == 1;    // This is unreachale but &#8216;true&#8217;.</span>
  <span style="color: #859900; font-weight: bold;">return</span> 0;
}
</pre>
</div>
<p>
That is, Frama-C considers ‚Äòpartial correctness‚Äô: A specification is satisfied,
<i>provided</i> it terminates.
</p>

<p>
In addition, since imperative expressions can modify memory, considerations must be
given to the fact arguments of a function are evaluated from left to right.
For example, suppose <code>x,y</code> are imperative constructions yield integers, then
 <code>x + y</code> and <code>y + x</code> are not guaranteed to produce the same behaviour!
</p>

<details>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">#include</span><span style="color: #2aa198;">&lt;stdio.h&gt;</span> <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">for IO</span>

<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">f</span>(){ printf(<span style="color: #2aa198;">"\nf(): Hello with Four!"</span>);  <span style="color: #859900; font-weight: bold;">return</span> 4;}
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">g</span>(){ printf(<span style="color: #2aa198;">"\ng(): Hello with Three!"</span>); <span style="color: #859900; font-weight: bold;">return</span> 3;}

<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">main</span>()
{
  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">result</span>;

  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">The output to the screen changes,</span>
  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">even though the *value* of result does not.</span>
  result = f() + g();
  printf(<span style="color: #2aa198;">"\n---"</span>);
  result = g() + f();

  <span style="color: #859900; font-weight: bold;">return</span> 0;
}
</pre>
</div>
</details>

<p>
The C language does not specify the order of evaluation of function arguments
&#x2013;albeit it is usually left-to-right&#x2013;, and it is up to the programmer to write
programs whose result does not depend on the order of evaluation.
</p>

<p>
<b>Exercise:</b> Produce a Frama-C checked variant of this example.
Remember to remove all <code>printf</code>'s!
</p>
</div>
</div>

<div id="outline-container-orga1cf596" class="outline-3">
<h3 id="orga1cf596">Passing Arguments by Value and by Reference</h3>
<div class="outline-text-3" id="text-orga1cf596">
<p>
Applying the definition of <code>wp</code> to the body of the following <code>swap</code> gives us
<code>wp swap = id</code>, thereby demonstrating that <i>this</i> <code>swap</code> does not change the
values of two variables!
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">swap</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">b</span>){ <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">c</span>; c = a; a = b; b = c; }
</pre>
</div>
<p>
The default mechanism of argument passing is that of <i>pass by value</i>:
Only values are sent to function bodies, which cannot alter the original variables.
Indeed, what should <code>swap(x+y, 2)</code> perform if it were to ‚Äúalter the given variables‚Äù?
</p>

<p>
To say that two <i>distinct</i> variables share the <i>same location</i> in memory
requires us to formally introduce a notion of location that variables may reference.
Rather than introduce a new such type, C makes the convention that certain numeric
values act &#x2013;possibly dual roles&#x2013; as reference locations.
</p>

<p>
Hence we can associate variables to references which are then associated to values.
That is, a state now consists of two pieces: An <i>environment</i> mapping variables to
references and a <i>memory state</i> mapping references to values.
The key insight is that the environment may be non-injective thereby associating
distinct variables to the same reference thereby permitting them to alter the shared value.
Incidentally, the shared value can be thought of as a buffer for message passing between
the two variable agents. Neato!
</p>

<p>
In C, passing by reference is not a primitive construct, but it can be simulated.
The type of references that can be associated with a value of type <code>T</code> in memory
is written <code>T*</code> in C. Incidentally, the dereference operator is written <code>*</code> in C.
For example, in environment <code>u ‚Ü¶ r‚ÇÅ</code> and memory state <code>r‚ÇÅ ‚Ü¶ r‚ÇÇ, r‚ÇÇ ‚Ü¶ 4</code> we have
that <code>u</code> has <i>value</i> <code>r‚ÇÇ</code> whereas <code>*u</code> has <i>value</i> <code>4</code>. That is, <code>u</code> is a reference value at location <code>r‚ÇÅ</code>
having contents <code>r‚ÇÇ</code>, which when dereferenced refer to the value contained in location <code>r‚ÇÇ</code>
which is 4.
</p>

<p>
The reference associated with variable <code>x</code> in a C environment is written <code>&amp;x</code>.
E.g., in environment <code>x ‚Ü¶ r</code> and memory state <code>r ‚Ü¶ 4</code>, the value of <code>x</code> is the integer 4
whereas the value of <code>&amp;x</code> is the reference <code>r</code>. Moreover, the value of <code>*&amp;x</code> is the integer 4.
</p>

<pre class="example">
&amp;_ : ‚àÄ{T} ‚Üí  Variable T ‚Üí Reference T   -- ‚Äúaddress of‚Äù
*_ : ‚àÄ{T} ‚Üí Reference T ‚Üí T             -- ‚Äúvalue of‚Äù

-- Using ‚Äòvalue equality‚Äô:
Inverses:  ‚àÄ a : Var T.  *&amp;a   ‚âà a
Inverses:  ‚àÄ r : Ref T.  &amp;(*r) ‚âà r
</pre>

<details>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">understanding_references</span>()
{
  <span style="color: #b58900; font-style: italic;">int</span>  <span style="color: #268bd2;">a</span> = 4;    <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">integer a refers to 4</span>
  <span style="color: #b58900; font-style: italic;">int</span>* <span style="color: #268bd2;">x</span> = &amp;a;   <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">integer reference x refers to the location of a</span>

  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Facts thus far</span>
  <span style="color: #96A7A9; font-style: italic;">//</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ assert a_is_a_number</span><span style="color: #96A7A9; font-style: italic;">: a == 4;</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ assert x_points_to_a</span><span style="color: #96A7A9; font-style: italic;">: *x == a == 4;</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ assert x_is_a_location</span><span style="color: #96A7A9; font-style: italic;">: x == &amp;a;</span>

  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">The inverse law: a == *(&amp;a).</span>
  <span style="color: #96A7A9; font-style: italic;">//</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ assert x_points_to_a</span><span style="color: #96A7A9; font-style: italic;">: *x == a == 4;</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ assert x_is_a_location</span><span style="color: #96A7A9; font-style: italic;">: x == &amp;a;</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ assert equals_for_equals</span><span style="color: #96A7A9; font-style: italic;">: *(&amp;a) == *x == a;</span>

  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">The inverse law: &amp;(*x) == x</span>
  <span style="color: #96A7A9; font-style: italic;">//</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ assert x_points_to_a</span><span style="color: #96A7A9; font-style: italic;">: *x == a == 4;</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ assert x_is_a_location</span><span style="color: #96A7A9; font-style: italic;">: x == &amp;a;</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ assert equals_for_equals</span><span style="color: #96A7A9; font-style: italic;">: &amp;(*x) == &amp;a == x;</span>

}
</pre>
</div>
</details>

<p>
If <code>t</code> is an expression of type <code>T*</code> then the C language has the assignment
construct <code>*t = u</code>: The reference of <code>t</code> is now associated with the value
of <code>u</code>. The notation alludes to this executional behaviour:
The contents of <code>t</code>, i.e., <code>*t</code>, now refer to the value of <code>u</code>.
</p>

<p>
For example, <code>*&amp;x = u</code> has the same behaviour as the assignment <code>x = u</code>.
</p>

<details>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">#include</span><span style="color: #2aa198;">&lt;stdio.h&gt;</span> <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">for IO</span>

<span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">x and y themselves cannot be assigned to: They're constant.</span>
<span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">I.e., assignments &#8220;x = t&#8221; are forbidden, but &#8220;*x = t&#8221; are permitted.</span>
<span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">This makes the compiler complain if we accidently made that assignment instead.</span>
<span style="color: #96A7A9; font-style: italic;">//</span>
<span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">However, &#8220;const int* x&#8221; works in the opposite: x=t okay, but not *x=t.</span>
<span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Declaration &#8220;const int* const x&#8221; prevents both types of assignments.</span>
<span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">swap</span>(<span style="color: #b58900; font-style: italic;">int</span>* <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">x</span>, <span style="color: #b58900; font-style: italic;">int</span>* <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #268bd2;">y</span>)
{
  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">z</span>;
  z  = *x; <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">z gets the value referenced to by x</span>
  *x = *y; <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">the location x references now gets the value referenced by y</span>
  *y =  z; <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">the location y references now gets the value z</span>
}

<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">main</span>()
{
  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">x</span> = 5, <span style="color: #268bd2;">y</span> = 10;
  swap(&amp;x, &amp;y);         <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Note that the function is applied to the references.</span>
  printf(<span style="color: #2aa198;">"x = %d, y = %d"</span>, x , y);
  <span style="color: #859900; font-weight: bold;">return</span> 0;
}
</pre>
</div>
</details>
</div>

<div id="outline-container-orgd3fd6de" class="outline-4">
<h4 id="orgd3fd6de">Dangling References: Segmentation Faults</h4>
<div class="outline-text-4" id="text-orgd3fd6de">
<p>
In C, we may look for references that do not exist:
C removes from memory the reference associated with a variable
when that variable is removed from the environment.
</p>

<details>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">#include</span><span style="color: #2aa198;">&lt;stdio.h&gt;</span> <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">for IO</span>

<span style="color: #b58900; font-style: italic;">int</span>* <span style="color: #b58900;">f</span>(<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">p</span>)
{
  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">n</span> = p;
  <span style="color: #859900; font-weight: bold;">return</span> &amp;n;

  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">n only exists locally,</span>
  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">whence its reference is removed when it no longer exists.</span>
}

<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">main</span>()
{
  <span style="color: #b58900; font-style: italic;">int</span>* <span style="color: #268bd2;">u</span> = f(5);
  <span style="color: #b58900; font-style: italic;">int</span>* <span style="color: #268bd2;">v</span> = f(10);
  printf(<span style="color: #2aa198;">"u = %d, v = %d"</span>, *u , *v); <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Segmentation fault!</span>
  <span style="color: #859900; font-weight: bold;">return</span> 0;
}
</pre>
</div>
</details>

<p>
The compiler gives us
<code>warning: function returns address of local variable [-Wreturn-local-addr].</code>
We may thus turn on that warning &#x2013;and all warnings really!&#x2013; so that it becomes
an error at compile time.
</p>

<p>
Since we used a reference that is not declared in memory, C does not produce
a compile error but the runtime result is unpredictable. Execute the above
snippet to see different kinds of segmentation fault codes.
</p>
</div>
</div>
<div id="outline-container-orgd1331d2" class="outline-4">
<h4 id="orgd1331d2">Pointers in ACSL</h4>
<div class="outline-text-4" id="text-orgd1331d2">
<p>
The <code>\old</code> function is a built-in logical operation of ACSL.
It can only be used in the post-condition and it denotes the value <i>before</i> execution
of the method body. If we want to access the value at a particular memory state,
we simply refer to a label at that time frame using the <code>\at</code> construct &#x2013;see below.
</p>

<div class="org-src-container">
<pre class="src src-c" id="org2b50bcf"><span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ requires \valid(a);</span>
<span style="color: #96A7A9; font-style: italic;">  @ ensures *a == \old(*a);</span>
<span style="color: #96A7A9; font-style: italic;">  @ ensures \at(*a, Post) == \at(*a, Pre); // Alternative way to say the same thing.</span>
<span style="color: #96A7A9; font-style: italic;">  */</span>
<span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">at_example</span>(<span style="color: #b58900; font-style: italic;">int</span> *<span style="color: #268bd2;">a</span>)
{
  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">tmp</span> = *a;
  <span style="color: #6c71c4; font-weight: bold;">AfterLine1</span>:
  *a = 23;
  <span style="color: #6c71c4; font-weight: bold;">AfterLine2</span>:
  *a = 42;
  <span style="color: #6c71c4; font-weight: bold;">AfterLine3</span>:
  *a = tmp;

  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">We are now in the memory state after the fourth line.</span>
  <span style="color: #96A7A9; font-style: italic;">//</span>
  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Here are some true facts about the memory states:</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert *a == \at(*a, Pre);     // Current value of *a is same as before method.</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert \at(*a, Here) == \at(*a, Pre);     // More explicitly.</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert 42 == \at(*a, AfterLine3);</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert 23 == \at(*a, AfterLine2);</span>
}
</pre>
</div>

<p>
Besides user-defined labels, <code>\at</code> can also be used with the built-in labels:
</p>
<ul class="org-ul">
<li><code>Pre</code> : Value <i>before</i> function call.</li>
<li><code>Post</code>: Value <i>after</i> function call. &#x2013;Can only be used in the post-condition.</li>
<li><code>Here</code>: Value at the current program point. &#x2013;This' the default for stand-alone variables.</li>
</ul>

<p>
Whereas <code>\old</code> can only be used in the post-condition, <code>\at</code> can be used anywhere.
</p>

<p>
Notice that we used the built-in <code>\valid</code> to ensure that access to pointers is safe
&#x2013;i.e., pointing to a real memory location&#x2013; thereby avoiding runtime errors.
We may also write <code>\valid(p + (l .. u))</code> to express the validity of pointers
<code>p + i</code> for <i>l ‚â§ i ‚â§ u</i> &#x2013;this will be helpful when working with arrays.
Moreover, when working with constant, non-mutable, pointers, or if we wish to
be more accurate, we may use <code>\valid_read(p)</code> to express that the pointer <code>p</code> is valid for
read-access only &#x2013;no writing permitted.
</p>
</div>
</div>
</div>


<div id="outline-container-orgd951e6f" class="outline-3">
<h3 id="orgd951e6f">Side-effects: <code>assigns</code></h3>
<div class="outline-text-3" id="text-orgd951e6f">
<p>
Since methods may alter state, thereby producing side-effects, it becomes important
to indicate which global and local variables a method assigns to
&#x2013;that way its effects are explicit. We use the <code>assigns</code> clause to declare this.
Unless stated otherwise, WP assumes a method can modify anything in memory;
as such, the use of <code>assigns</code> becomes almost always necessary.
When a method has no side-effects, thereby not assigning to anything, we may
declare <code>assigns \nothing</code>.
</p>

<div class="org-src-container">
<pre class="src src-c" id="orgfdeaa95"><span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ requires \valid(a) &amp;&amp; \valid(b);</span>
<span style="color: #96A7A9; font-style: italic;">  // @ assigns *a, *b;</span>
<span style="color: #96A7A9; font-style: italic;">  @ ensures *a == \old(*b);</span>
<span style="color: #96A7A9; font-style: italic;">  @ ensures *b == \old(*a);</span>
<span style="color: #96A7A9; font-style: italic;">  */</span>
<span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">swap</span>(<span style="color: #b58900; font-style: italic;">int</span> *<span style="color: #268bd2;">a</span>, <span style="color: #b58900; font-style: italic;">int</span> *<span style="color: #268bd2;">b</span>)
{
  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">tmp</span> = *a;
  *a = *b;
  *b = tmp;
}
</pre>
</div>

<p>
Notice that the following block fails to prove all goals
&#x2013;comment out the <code>assigns</code> clause <i>below</i> and re-check &#x2026; still no luck!
This can be fixed by un-commenting the <code>assigns</code> clause <i>above</i>.
</p>

<div class="org-src-container">
<pre class="src src-c" id="orgc3600e9"><span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">h</span> = 12; <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">new global variable!</span>

<span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assigns \nothing;  // In particular, this method does not alter &#8220;h&#8221;.</span>
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">main</span>()
{
  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">a</span> = 1; <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">b</span> = 2;

  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert h == 12;</span>
  swap(&amp;a, &amp;b);
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert h == 12;</span>
  <span style="color: #859900; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
Finally it is to be noted that <code>assigns</code> do not occur within a <code>behavior</code>
&#x2013;it occurs before by declaring <i>all</i> variables that may be altered, then
each <code>behavior</code> would include a clause for the unmodified variables by indicating
their new value is equal to their <code>\old</code> one.
</p>
</div>
</div>

<div id="outline-container-orgc2c9f5a" class="outline-3">
<h3 id="orgc2c9f5a">Pointer Aliasing: <code>separated</code></h3>
<div class="outline-text-3" id="text-orgc2c9f5a">
<p>
The raison d'√™tre of pointers is to be able to have aliases for memory locations.
When the pointers refer to simple data, we may act <i>functionally</i> in that we copy
data to newly allocated memory locations. However, sometimes &#x2013;such as when we program
with linked lists&#x2013; copying large amounts of data is unreasonable and we may simply
want to alter given pointers directly. When the given pointers are <i>identical</i> then an
alteration to one of them is actually an alteration to the rest!
</p>

<p>
When we program with lists, we shall see that if we catenate two lists by altering
the first to eventually point to the second then it all works.
However, if we catenate a list with itself then the resulting alteration
is not the catenation of the list with itself but instead is an
infinite cycle of the first list! &#x2013;We'll see this later on.
</p>

<p>
Here is a simpler example,
</p>
<div class="org-src-container">
<pre class="src src-c" id="orgfb4ee85"><span style="color: #268bd2; font-weight: bold;">#include</span><span style="color: #2aa198;">&lt;limits.h&gt;</span>

<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ requires \valid(fst) &amp;&amp; \valid_read(snd);</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ requires no_flow</span><span style="color: #96A7A9; font-style: italic;">: INT_MIN &lt;= *fst + *snd &lt;= INT_MAX;</span>
<span style="color: #96A7A9; font-style: italic;">  // @ requires \separated(fst, snd);</span>
<span style="color: #96A7A9; font-style: italic;">  @ assigns *fst;</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ ensures uhOh</span><span style="color: #96A7A9; font-style: italic;">: *fst == \old(*fst) + *snd;</span>
<span style="color: #96A7A9; font-style: italic;">  */</span>
<span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">increment_first_by_second</span>(<span style="color: #b58900; font-style: italic;">int</span> *<span style="color: #268bd2;">fst</span>, <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #859900; font-weight: bold;">const</span> *<span style="color: #268bd2;">snd</span>)
{
  *fst += *snd;
}
</pre>
</div>

<p>
Notice since we're only assigning to <code>*fst</code>, we need not explicitly state
<code>ensures *snd == \old(*snd)</code>. However, in the event that <code>fst</code> and <code>snd</code> both point
to the same memory location, then we actually are assigning to both!
As such the final <code>ensures</code> is not necessarily true either!
</p>

<p>
We need to uncomment the <code>separated</code> declaration: The memory locations are distinct.
</p>

<p>
Notice that in the final call below, since the pre-condition to
<code>increment_first_by_second</code> fails, we have breached its contract and therefore
no longer guarenteed the behaviour it <code>ensures</code>.
Since the contract does not tells what happens when we breach it, anything is possible
and so anything is ‚Äútrue‚Äù!
</p>
<div class="org-src-container">
<pre class="src src-c" id="org527c336"><span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">main</span>()
{
  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">life</span> = 42, <span style="color: #268bd2;">universe</span> = 12;

  <span style="color: #b58900; font-style: italic;">int</span> *<span style="color: #268bd2;">this</span> = &amp;life;
  <span style="color: #b58900; font-style: italic;">int</span> *<span style="color: #268bd2;">new</span>  = &amp;universe;

  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert *this == 42  &amp;&amp; *new == 12;</span>
  increment_first_by_second(this, new);
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert *this == 42 + 12  &amp;&amp; *new == 12;   // Yay!</span>

  <span style="color: #b58900; font-style: italic;">int</span> *<span style="color: #268bd2;">that</span> = &amp;life;  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">uh-oh!</span>

  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert *this == 54  &amp;&amp; *that == 54;</span>
  increment_first_by_second(this, that);
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert *this == 54 + 54  &amp;&amp; *that == 54;   // Nope...?</span>
  <span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assert 1 == 0;                             // Notice everything is now &#8220;true&#8221;!</span>

  <span style="color: #859900; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
We may invoke <code>\separated(p‚ÇÅ, ‚Ä¶, p‚Çô)</code> to express the pointers <code>p·µ¢</code> should refer to distinct
memory locations and therefore are non-overlapping.
</p>
</div>
</div>

<div id="outline-container-org3ec5b4c" class="outline-3">
<h3 id="org3ec5b4c">Functional Composition</h3>
<div class="outline-text-3" id="text-org3ec5b4c">
<p>
As a matter of abstraction, or separation of concerns, a program may be split up
into an interface of declarations &#x2013;a ‚Äòheader‚Äô file&#x2013; and an implementation file.
Frama-C permits this approach by allowing us to use a specification of a declared
method, which it assumes to be correct, and so we need to verify its precondition
is established whenever we call it. In some sense, for proof purposes, this allows
us to ‚Äòpostulate‚Äô a correct method and use it elsewhere &#x2013;this idea is very helpful
when we want to use an external libary's methods but do not &#x2013;or cannot&#x2013; want to prove them.
</p>

<details>
<p>

</p>

<div class="org-src-container">
<pre class="src src-c" id="orgdbff233"><span style="color: #268bd2; font-weight: bold;">#include</span><span style="color: #2aa198;">&lt;limits.h&gt;</span>

<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ requires val &gt; INT_MIN;</span>
<span style="color: #96A7A9; font-style: italic;">  @ assigns \nothing;</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ ensures always_non_negative</span><span style="color: #96A7A9; font-style: italic;">: \result &gt;= 0;</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ ensures non_negative</span><span style="color: #96A7A9; font-style: italic;">: 0 &lt;= val ==&gt; \result == val;</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ ensures negative</span><span style="color: #96A7A9; font-style: italic;">: val &lt; 0  ==&gt; \result == -val;</span>
<span style="color: #96A7A9; font-style: italic;">  @</span><span style="color: #96A7A9; font-style: italic;"> */</span>
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">abs</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">val</span>);

<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ assigns \nothing;</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ ensures UpperBound</span><span style="color: #96A7A9; font-style: italic;">: a &lt;= \result  &amp;&amp;  b &lt;= \result;</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ ensures Selection1</span><span style="color: #96A7A9; font-style: italic;">: a &lt;= b  ==&gt;  \result == b;</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ ensures Selection2</span><span style="color: #96A7A9; font-style: italic;">: b &lt;= a  ==&gt;  \result == a;</span>
<span style="color: #96A7A9; font-style: italic;">  @</span><span style="color: #96A7A9; font-style: italic;">*/</span>
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">max</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">b</span>);

<span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Uncomment this to observe proof obligations failing.</span>
<span style="color: #96A7A9; font-style: italic;">//</span>
<span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">int max(int a, int b){ return 5; }</span>

<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #b58900;">@ requires inherited_from_abs</span><span style="color: #96A7A9; font-style: italic;">: a &gt; INT_MIN  &amp;&amp; b &gt; INT_MIN;</span>

<span style="color: #96A7A9; font-style: italic;">  @ assigns \nothing;</span>

<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ ensures always_non_negative: inherited_from_abs</span><span style="color: #96A7A9; font-style: italic;">: \result &gt;= 0;</span>

<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ ensures upper_bound: inherited_from_max</span><span style="color: #96A7A9; font-style: italic;">:</span>
<span style="color: #96A7A9; font-style: italic;">         \result &gt;= a &amp;&amp; \result &gt;= -a    // &#8776; result &#8805; |a|</span>
<span style="color: #96A7A9; font-style: italic;">      &amp;&amp; \result &gt;= b &amp;&amp; \result &gt;= -b;   // &#8776; result &#8805; |b|</span>

<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ ensures selection: inherited_from_max</span><span style="color: #96A7A9; font-style: italic;">:</span>
<span style="color: #96A7A9; font-style: italic;">          \result == a || \result == -a</span>
<span style="color: #96A7A9; font-style: italic;">       || \result == b || \result == -b;</span>
<span style="color: #96A7A9; font-style: italic;">*/</span>
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">abs_max</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">a</span>, <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">b</span>)
{
  <span style="color: #859900; font-weight: bold;">return</span> max(abs(a), abs(b));
}
</pre>
</div>

<p>
If we press <code>F8</code>, the frama-c gui shows green bullets for the declarations'
specifications. They have no implementation and so are assumed to be true.
Then the <code>abs_max</code> operation ‚Äòinherits‚Äô the preconditions and postconditions of
the methods it calls along the variables it uses.
</p>
</details>
</div>
</div>
</div>
<div id="outline-container-org341dd03" class="outline-2">
<h2 id="org341dd03">Records</h2>
<div class="outline-text-2" id="text-org341dd03">
<p>
Thus far we have only considered built-in types, we now turn to considering
user-defined types that are more complex and are composites of simpler types
by using the <i>record</i> construct.
</p>

<ul class="org-ul">
<li>Record ‚âà Tuple with named fields</li>
</ul>

<p>
A tuple <code>x = (x‚ÇÄ, x‚ÇÅ, ‚Ä¶, x‚Çô)</code> is a function over the domain <code>0..n</code>, but in programming
the domain is usually of <i>named fields, labels,</i> and then it is called a <i>record</i>.
E.g., <code>{name = "Jasim", age = 27, language = "ar"}</code> is a record.
In the case that the labels <i>are</i> numbers, we obtain the notion of an <i>array</i>.
</p>

<p>
In other languages, this may be known as a <code>class</code>.
In Haskell this is the <code>data</code> keyword with ‚Äòrecord syntax‚Äô,
and in Agda we may go on to use the <code>record</code> keyword.
</p>

<p>
C records are known as <i>structures</i> and they are just a list of
labels with their types. In using <code>struct</code> types, the <code>struct</code>
keyword must precede the type name in all declarations.
</p>
<div class="org-src-container">
<pre class="src src-c" id="orgf1a5324"><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900; font-style: italic;">Pair</span>
{
  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">fst</span>;
  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">snd</span>;
};

<span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Note that &#8220;struct&#8221; always precedes the type name &#8220;Pair&#8221;.</span>

<span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Structs are passed in by value: They are copied locally.</span>
<span style="color: #96A7A9; font-style: italic;">//</span>
<span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #96A7A9; font-style: italic;">@ assigns \nothing;</span>
<span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">doesNothing</span>(<span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900; font-style: italic;">Pair</span> <span style="color: #268bd2;">p</span>)
{
  p.fst = 666;
}

<span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">As usual, we use pointers to pass values by reference.</span>
<span style="color: #96A7A9; font-style: italic;">//</span>
<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ requires \valid(p);</span>
<span style="color: #96A7A9; font-style: italic;">  @ assigns (*p).fst;</span>
<span style="color: #96A7A9; font-style: italic;">*/</span>
<span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">woah</span>(<span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900; font-style: italic;">Pair</span>* <span style="color: #268bd2;">p</span>)
{
  (*p).fst = 313;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c" id="orga855aad"><span style="color: #268bd2; font-weight: bold;">#include</span><span style="color: #2aa198;">&lt;stdio.h&gt;</span> <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">for IO</span>

<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">main</span>()
{

  <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900; font-style: italic;">Pair</span> <span style="color: #268bd2;">p</span>; <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">no initalisation</span>

  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Composite type without a name.</span>
  <span style="color: #859900; font-weight: bold;">struct</span> {<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">one</span>; <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">two</span>;} <span style="color: #268bd2;">q</span>;

  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Initialisation with declaration.</span>
  <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900; font-style: italic;">Pair</span> <span style="color: #268bd2;">r</span> = {11, 13};

  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Note that in C, non-initialised variables have &#8220;arbitrary&#8221; values</span>
  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">which may change according to each new compilation!</span>

  printf(<span style="color: #2aa198;">"\n p = &#10216;fst: %d, snd: %d&#10217;"</span>, p.fst, p.snd);

  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Set only first field.</span>
  p.fst = 3;
  printf(<span style="color: #2aa198;">"\n p = &#10216;fst: %d, snd: %d&#10217;"</span>, p.fst, p.snd);

  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Zero-out all fields.</span>
  <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900; font-style: italic;">Pair</span> <span style="color: #268bd2;">s</span> = {};
  printf(<span style="color: #2aa198;">"\n s = &#10216;fst: %d, snd: %d&#10217;"</span>, s.fst, s.snd);

  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Invoke functions</span>

  doesNothing(s);
  printf(<span style="color: #2aa198;">"\n s = &#10216;fst: %d, snd: %d&#10217;"</span>, s.fst, s.snd);

  woah(&amp;s);
  printf(<span style="color: #2aa198;">"\n s = &#10216;fst: %d, snd: %d&#10217;"</span>, s.fst, s.snd);

  <span style="color: #859900; font-weight: bold;">return</span> 0;
}
</pre>
</div>
</div>

<div id="outline-container-org0c3edb1" class="outline-3">
<h3 id="org0c3edb1">Allocation of a Record</h3>
<div class="outline-text-3" id="text-org0c3edb1">
<ul class="org-ul">
<li>Recall that a variable declaration associates the variable with a reference to
the variable in memory &#x2013;i.e., it's address&#x2013;,
moreover this reference is associated a value for the variable.</li>

<li>Record variables declared without a value are given the special default value <code>null</code>.</li>

<li>In Java, a record variable's reference is not directly associated with a record in memory!
It is usually associated with <code>null</code> or another reference.</li>
</ul>

<p>
To associate a record with a variable, we need to create memory large enough to contain the record
contents. Some languages use the keyword <code>new</code> to accomplish this task: Create a new reference
and associated it with the record variable being defined.
</p>

<p>
For example, in Java,
</p>
<pre class="example">
class Pair
{
  int fst;
  int snd;
}

Pair p = new Pair();
</pre>
<p>
The resulting environment is <code>p ‚Ü¶ r</code> and the resulting memory state is
<code>r ‚Ü¶ r', r' ‚Ü¶ {fst = 0, snd = 0}</code>. Note that default values are used.
</p>

<ul class="org-ul">
<li>A reference that was added to memory by the construct <code>new</code> is called a <i>cell</i>.</li>
<li>The set of memory cells is called a <i>heap</i>.</li>
<li>The operation that adds a new cell to the memory state is called <i>allocation</i>.</li>
</ul>

<p>
Interestingly in C the creation of records does <i>not</i> allocate cells and so there
is no need for the <code>new</code> keyword. Indeed record variables cannot ever have the value <code>null</code>.
C directly associates a variable with a reference which has the record contents as its value.
That is, C has one less level of indirection than is found in Java.
E.g., <code>struct Pair p = {2, 3};</code> gives us environment <code>p ‚Ü¶ r</code> and memory state <code>r ‚Ü¶ {fst = 2, snd = 3}</code>,
whereas Java would have <code>p ‚Ü¶ r‚Ä≤</code> in the environment and <code>r‚Ä≤ ‚Ü¶ r</code> additionally in the memory state
That is to say, <i>records in Java correspond to references to records in C</i>
and so Java access notation <code>r.f</code> is rendered in C as <code>(*r).f</code>.
</p>

<p>
Remember that references are themselves first-class values and it is possible for a
reference to be associated to another reference.
</p>
</div>
</div>

<div id="outline-container-orgf0e6a55" class="outline-3">
<h3 id="orgf0e6a55">The Four Constructs of Records</h3>
<div class="outline-text-3" id="text-orgf0e6a55">
<p>
Records are usually handled using four constructs:
</p>
<ul class="org-ul">
<li>Defining a record type; e.g., using <code>class</code> or <code>struct</code>.</li>
<li>Allocating a cell; e.g., using <code>new</code> or <code>malloc</code>.</li>
<li>Accessing a field; e.g., <code>myRecord.myField</code>.</li>
<li>Assigning to a field; e.g., <code>myRecord.myField = myValue</code>.</li>
</ul>

<p>
Understanding records in a language is thus tantamount to understanding
these fundamental basics. E.g., in functional languages, assignment to a field
is essentially record copying or, more efficiently, reference redirection.
Incidentally, neither Haskell nor Agda make use of the <code>new</code> keyword:
Declarations <i>must be</i> accompanied by initialisation which indicate the need
for cell allocation &#x2013;consequently there is no need for a <code>null</code> value.
The use of <code>new</code> may be used for careful efficiency optimisations,
or memory management &#x2013;which is rarely brought to the forefront in functional languages.
</p>

<p>
The act of assigning to each field of a record
is so common that they are usually placed into a so-called <i>constructor</i> method.
</p>
</div>
</div>

<div id="outline-container-org12e0f6f" class="outline-3">
<h3 id="org12e0f6f">Sharing, Equality, &amp; Garbage</h3>
<div class="outline-text-3" id="text-org12e0f6f">
</div>
<div id="outline-container-orgcaf2c00" class="outline-4">
<h4 id="orgcaf2c00">Assignment</h4>
<div class="outline-text-4" id="text-orgcaf2c00">
<p>
Suppose <code>x</code> and <code>y</code> are variables of type <code>Pair</code>, with environment and memory state:
</p>
<pre class="example">
locations  =  x ‚Ü¶ r‚ÇÅ, y ‚Ü¶ r‚ÇÇ
values     =  r‚ÇÅ ‚Ü¶ r‚ÇÉ, r‚ÇÇ ‚Ü¶ r‚ÇÑ, r‚ÇÉ ‚Ü¶ {fst = 3, snd = 5}, r‚ÇÑ ‚Ü¶ {fst = 7, snd = 9}
</pre>
<p>
Then assignment <code>y ‚âî x</code> results in:
</p>
<pre class="example">
locations  =  x ‚Ü¶ r‚ÇÅ, y ‚Ü¶ r‚ÇÇ
values     =  r‚ÇÅ ‚Ü¶ r‚ÇÉ, r‚ÇÇ ‚Ü¶ r‚ÇÉ, r‚ÇÉ ‚Ü¶ {fst = 3, snd = 5}, r‚ÇÑ ‚Ü¶ {fst = 7, snd = 9}
                      -Change Here-
</pre>
<p>
That is, the value of <code>x</code> is computed which is the reference <code>r‚ÇÉ</code>
&#x2013;since <code>value (location x) ‚âà value r‚ÇÅ ‚âà r‚ÇÉ</code>&#x2013;
and we associate this value with the location of <code>y</code>, that is, reference <code>r‚ÇÇ</code>.
</p>

<p>
Notice that now no variable has the value of <code>r‚ÇÑ</code> and so it is considered <i>garbage</i>
in our state. Moreover, nothing can get to it since values are only associated with
locations, none of which have address <code>r‚ÇÑ</code>. Hence there is no <i>observable</i> affect to
their absence or presence. We want to recycle the physical memory
or else we would quickly run out of memory. A <i>garbage collector</i> is an automated
system that collects and recycles such cells. Older languages like C do not
have such a system and so memory must be managed by hand.
</p>

<p>
Anyhow, henceforth <code>x</code> and <code>y</code> <b>share</b> the values of the record thereby all alterations,
through either variable, are observable by the other.
</p>

<p>
Since <code>x</code> and <code>y</code> are reference values, the assignment makes <code>x == y</code> a true statement
since they <i>share</i> the same cell. This is known as <i>physical equality</i>.
</p>

<p>
Sometimes we wish for two variables to <i>share</i> a single integer, which may
not be possible with built-in types, but can be accomplished by using <i>wrapper record types</i>:
Records that have a lone single field. This idea of `boxing up' primitive types
allows us, for example, to define functions with arguments that are passed by reference
thereby modifying their arguments; such as the <code>swap</code> function that swaps the contents of its
arguments.
</p>
</div>
</div>

<div id="outline-container-org2ef1228" class="outline-4">
<h4 id="org2ef1228">Copy</h4>
<div class="outline-text-4" id="text-org2ef1228">
<p>
If we instead execute <code>y.fst ‚âî x.fst; y.snd ‚âî x.snd</code>
Then the resulting state is:
</p>
<pre class="example">
locations  =  x ‚Ü¶ r‚ÇÅ, y ‚Ü¶ r‚ÇÇ
values     =  r‚ÇÅ ‚Ü¶ r‚ÇÉ, r‚ÇÇ ‚Ü¶ r‚ÇÑ, r‚ÇÉ ‚Ü¶ {fst = 3, snd = 5}, r‚ÇÑ ‚Ü¶ {fst = 3, snd = 5}
                                                                    -Change Here-
</pre>

<p>
In this case, any alteration to <code>x</code>'s values are <i>not</i> observable by <code>y</code>.
</p>

<p>
Moreover, in this case, all fields are equal and so we have <code>x</code> and <code>y</code>
are <i>structurally equal</i>. This notion is sometimes called <code>equals method</code>
and the previous is <code>equals equals (==)</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-org7e726dd" class="outline-3">
<h3 id="org7e726dd">Arrays</h3>
<div class="outline-text-3" id="text-org7e726dd">
<p>
<i>Arrays</i> are essentially records whose labels are numeric <i>and</i> all labels have
the same type. The number of fields of an array is determined during allocation
of the array, and not during the declaration of its type, as is the case with records.
This trade-off makes arrays more desirable in certain contexts.
</p>

<p>
The fields are usually numbered <code>0</code> to <code>n-1</code>, where <code>n</code> is the number of fields.
</p>

<p>
Once an array is allocated, its size cannot be changed.
&#x2013;Stop &amp; think: Why not?
</p>

<ul class="org-ul">
<li>Arrays of type <code>T</code> are denoted by <code>T[]</code> in C/Java.
<ul class="org-ul">
<li>Matrices, or arrays of arrays, are denoted by <code>T[][]</code> with access
by <code>T[i][j]</code>.</li>
</ul></li>
</ul>

<p>
C arrays, like records, are not allocated.
Consequently, their size cannot be determined by allocation and so must be
  a part of their type.
</p>

<p>
C arrays of type <code>T</code> of length <code>n</code> are declared using the mixfix syntax: <code>T x[n];</code>
Each element of the array is arbitrary &#x2013;with no designated defaults&#x2013;
so it is best to initialise them. E.g., <code>int x[10] = {};</code> sets all elements of
the array to 0.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">#include</span><span style="color: #2aa198;">&lt;stdio.h&gt;</span> <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">for IO</span>

<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">makeFive</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">x</span>[], <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">length</span>)
{
  <span style="color: #859900; font-weight: bold;">for</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">i</span>=0; i != length; i++)
    x[i] = 5;
}

<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">main</span>()
{
  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">x</span>[3] = {};
  printf(<span style="color: #2aa198;">"\n x = [%d, %d, %d]"</span>, x[0], x[1], x[2]);

  makeFive(x, 3);
  printf(<span style="color: #2aa198;">"\n x = [%d, %d, %d]"</span>, x[0], x[1], x[2]);

  <span style="color: #859900; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
However, C arrays differ from C records in that array variables are actually
references that are associated in memory with an array. Consequently, array
arguments to methods are automatically pass by reference!
</p>

<p>
Moreover this means the assignment <code>t[k] = u</code> works in a rather general sense:
<code>t</code> suffices to be any expression whose <i>value</i> is a reference associated in memory
with an array.
</p>
</div>
</div>
</div>
<div id="outline-container-orgb4b669b" class="outline-2">
<h2 id="orgb4b669b">Arrays &#x2013; <code>\forall, \exists</code></h2>
<div class="outline-text-2" id="text-orgb4b669b">
<p>
Arrays are commonly handled using loops; let's look at some examples.
</p>

<div class="org-src-container">
<pre class="src src-c" id="orga62aabc"><span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ requires 0 &lt; N;</span>
<span style="color: #96A7A9; font-style: italic;">  @ requires \valid_read(array + (0 .. N - 1));  // N is the length of the array</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  @ assigns \nothing;</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ behavior found_element</span><span style="color: #96A7A9; font-style: italic;">:</span>
<span style="color: #96A7A9; font-style: italic;">  @    assumes \exists integer i; 0 &lt;= i &lt; N  &amp;&amp;  array[i] == element;</span>
<span style="color: #96A7A9; font-style: italic;">  @    ensures 0 &lt;= \result &lt; N;</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ behavior did_not_find_element</span><span style="color: #96A7A9; font-style: italic;">:</span>
<span style="color: #96A7A9; font-style: italic;">  @    assumes \forall integer i; 0 &lt;= i &lt; N  ==&gt; array[i] != element;</span>
<span style="color: #96A7A9; font-style: italic;">  @    ensures \result == N;</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  @ disjoint behaviors;</span>
<span style="color: #96A7A9; font-style: italic;">  @ complete behaviors;</span>
<span style="color: #96A7A9; font-style: italic;">  */</span>
<span style="color: #b58900; font-style: italic;">int</span> linear_search(<span style="color: #b58900; font-style: italic;">int</span>* <span style="color: #268bd2;">array</span>, <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">N</span>, <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">element</span>)
{
  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">n</span> = 0;

  <span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ loop assigns n;</span>
<span style="color: #96A7A9; font-style: italic;">    @ loop invariant 0 &lt;= n &lt;= N;</span>
<span style="color: #96A7A9; font-style: italic;">    </span><span style="color: #b58900;">@ loop invariant not_found_yet</span><span style="color: #96A7A9; font-style: italic;">: \forall integer i; 0 &lt;= i &lt; n  ==&gt;  array[i] != element;</span>
<span style="color: #96A7A9; font-style: italic;">    @ loop variant N - n;</span>
<span style="color: #96A7A9; font-style: italic;">    */</span>
  <span style="color: #859900; font-weight: bold;">while</span>( n != N  &amp;&amp; array[n] != element ) n++;
  <span style="color: #859900; font-weight: bold;">return</span> n &lt; N ? n : N;
}
</pre>
</div>

<p>
Some remarks are in order.
</p>

<ul class="org-ul">
<li><code>\valid_read(array + (0 .. N - 1))</code> ensures that the memory addresses
<code>array + 0, ..., array + N-1</code> can be read &#x2013;as discussed when introducing <code>\valid</code>.</li>

<li>The loop continues as long as we have not yet found the element.
<ul class="org-ul">
<li>As such, every index thus far differs from the element sought after.</li>
<li>That is, forall index <i>i</i> in the array bounds, we have <i>array[i] ‚â† element</i>.</li>
<li>This invariant is stated using the <code>forall</code> syntax.</li>
</ul></li>

<li>The variable naming <code>n, N</code> is intended to be suggestive:
When <i>n = N</i> then we have traversed the whole array.
<ul class="org-ul">
<li>We began at 0 and are working upward to <i>N</i>.</li>
<li>At each step, we traverse the array by one more item
thereby decreasing the amount of items remaining &#x2013;which is <i>N - n</i>.</li>
</ul></li>

<li>If it is <i>provable</i> that some index contains the desired element,
then in that case our program ensures the output result is a valid index.</li>

<li>The ACSL type <code>integer</code> is preferable to the C type <code>int</code> since it is not constrained by
any representation limitations and instead acts more like its pure mathematical counterpart ‚Ñ§.</li>
</ul>

<p>
It is important to note that the universal ‚Äò‚àÄ‚Äô uses <code>==&gt;</code> to delimit the
range from the body predicate, whereas the existential ‚Äò‚àÉ‚Äô uses <code>&amp;&amp;</code>
&#x2013;this observation is related to the ‚Äútrading laws‚Äù for quantifiers.
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>\forall type x; r(x) ==&gt; p(x)</code></td>
<td class="org-left">Every element <code>x</code> in range <code>r</code> satisfies <code>p</code></td>
</tr>

<tr>
<td class="org-left"><code>\exists type x; r(x) &amp;&amp; p(x)</code></td>
<td class="org-left">Some  element <code>x</code> in range <code>r</code> satisfies <code>p</code></td>
</tr>
</tbody>
</table>

<p>
Notice the striking difference between
the <code>\exists integer x; \false &amp;&amp; even x</code>
&#x2013;which is unprovable since false is never true!&#x2013;
and <code>\exists integer x; \false ==&gt; even x</code>
&#x2013;which can be satisfied by infinitely many <code>x</code>, since false implies anything.
</p>
<p>
Of course we could start at the end of the array and ‚Äúwork down‚Äù until
we find the element, or otherwise, say, return -1. Let's do so without using
a new local variable <code>n</code>.
</p>

<details>
<div class="org-src-container">
<pre class="src src-c" id="org3819c27"><span style="color: #268bd2; font-weight: bold;">#include</span> <span style="color: #2aa198;">"Prelude.c"</span>

<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ requires 0 &lt; N;</span>
<span style="color: #96A7A9; font-style: italic;">  // </span><span style="color: #b58900;">@ requires Exercise</span><span style="color: #96A7A9; font-style: italic;">: read access to a[0], ..., a[N-1];</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  // @ assigns FixMe;</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ behavior found_element</span><span style="color: #96A7A9; font-style: italic;">:</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@    assumes Exercise</span><span style="color: #96A7A9; font-style: italic;">: FixMe;  // &#8220;element &#8712; array&#8221;</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@    ensures Exercise</span><span style="color: #96A7A9; font-style: italic;">: FixMe;  // Output is valid index in array</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ behavior did_not_find_element</span><span style="color: #96A7A9; font-style: italic;">:</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@    assumes Exercise</span><span style="color: #96A7A9; font-style: italic;">: FixMe;     // &#8220;element &#8713; array&#8221;</span>
<span style="color: #96A7A9; font-style: italic;">  @    ensures \result == -1;</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  @ disjoint behaviors;</span>
<span style="color: #96A7A9; font-style: italic;">  @ complete behaviors;</span>
<span style="color: #96A7A9; font-style: italic;">  */</span>
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">linear_search_no_local</span>(<span style="color: #b58900; font-style: italic;">int</span>* <span style="color: #268bd2;">array</span>, <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">N</span>, <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">element</span>)
{
  <span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ loop assigns N;</span>
<span style="color: #96A7A9; font-style: italic;">    @ loop invariant 0 &lt;= N &lt;= \at(N, Pre);</span>
<span style="color: #96A7A9; font-style: italic;">    // </span><span style="color: #b58900;">@ loop invariant not_found_yet: Exercise</span><span style="color: #96A7A9; font-style: italic;">: FixMe;</span>
<span style="color: #96A7A9; font-style: italic;">    // </span><span style="color: #b58900;">@ loop variant Exercise: FixMe</span><span style="color: #96A7A9; font-style: italic;">: 666;</span>
<span style="color: #96A7A9; font-style: italic;">    */</span>
  <span style="color: #859900; font-weight: bold;">while</span>( 0 != N  &amp;&amp; array[N-1] != element ) N--;
  <span style="color: #859900; font-weight: bold;">return</span> N - 1;
}
</pre>
</div>
</details>
<details>
<div class="org-src-container">
<pre class="src src-c" id="org9c17823"><span style="color: #268bd2; font-weight: bold;">#include</span> <span style="color: #2aa198;">"Prelude.c"</span>

<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #b58900;">@ requires Exercise</span><span style="color: #96A7A9; font-style: italic;">: FixMe; // array[0], ..., array[N-1] are accessible</span>
<span style="color: #96A7A9; font-style: italic;">  @ requires element &lt; INT_MAX;</span>
<span style="color: #96A7A9; font-style: italic;">  @ assigns array[0 .. N-1];</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ ensures Exercise: all_array_equals_element</span><span style="color: #96A7A9; font-style: italic;">: FixMe;</span>
<span style="color: #96A7A9; font-style: italic;">  */</span>
<span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">make_constant</span>(<span style="color: #b58900; font-style: italic;">int</span>* <span style="color: #268bd2;">array</span>, <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">N</span>, <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">element</span>)
{
  <span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ loop assigns N, array[0 .. \at(N,Pre)-1];</span>
<span style="color: #96A7A9; font-style: italic;">    </span><span style="color: #b58900;">@ loop invariant range_on_N</span><span style="color: #96A7A9; font-style: italic;">: FixMe;</span>
<span style="color: #96A7A9; font-style: italic;">    </span><span style="color: #b58900;">@ loop invariant constant_so_far</span><span style="color: #96A7A9; font-style: italic;">: FixMe;</span>
<span style="color: #96A7A9; font-style: italic;">    @ loop variant N;</span>
<span style="color: #96A7A9; font-style: italic;">    */</span>
  <span style="color: #859900; font-weight: bold;">for</span> (; 0 != N; N--) array[N-1] = element;
}
</pre>
</div>
</details>
<br>

<p>
Notice that the invariants are getting way too long &#x2013;and worse: Repetitive!
We can abstract common formulae into more general and reusable shapes by
declaring them as ACSL logical functions &#x2013;keep reading!
</p>

<p>
On an unrelated note, sometimes we try to prove a program that we just
coded incorrectly, so if things are going nowhere then maybe try a few tests
to ensure you're on the right track.
</p>
</div>
</div>
<div id="outline-container-orge76afa1" class="outline-2">
<h2 id="orge76afa1">Recursion</h2>
<div class="outline-text-2" id="text-orge76afa1">
<p>
The definition of <code>wp</code> for function calls is correct provided the function body
itself only contains invocations to <i>previously</i> defined functions?
</p>

<p>
What about <i>recursive function definitions</i>:
Definitions invoking the function being defined or invoking functions that invoke
functions that eventually invoke the function currently being defined?
</p>

<p>
Since invocations are delegated to the state, which handles all defined names,
we may invoke whatever function provided its name is found.
Since C requires names to be declared before use, we may have mutually recursive
functions by ‚Äòprototyping‚Äô: Declaring the function signature, then at some point
providing the actual implementation.
</p>
<details>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">#include</span><span style="color: #2aa198;">&lt;stdio.h&gt;</span> <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">for IO</span>
<span style="color: #268bd2; font-weight: bold;">#include</span><span style="color: #2aa198;">&lt;stdbool.h&gt;</span>

<span style="color: #b58900; font-style: italic;">bool</span> <span style="color: #b58900;">odd</span>(<span style="color: #b58900; font-style: italic;">int</span>); <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">protoyping the odd function</span>

<span style="color: #b58900; font-style: italic;">bool</span> <span style="color: #b58900;">even</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">n</span>) <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">using odd here, even though it's not yet defined</span>
{
  <span style="color: #859900; font-weight: bold;">if</span> (n == 0) <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #6c71c4; font-weight: bold;">true</span>;
  <span style="color: #859900; font-weight: bold;">else</span>        <span style="color: #859900; font-weight: bold;">return</span> odd(n - 1);
}

<span style="color: #b58900; font-style: italic;">bool</span> <span style="color: #b58900;">odd</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">n</span>)
{
  <span style="color: #859900; font-weight: bold;">if</span> (n == 0) <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #6c71c4; font-weight: bold;">false</span>;
  <span style="color: #859900; font-weight: bold;">else</span>        <span style="color: #859900; font-weight: bold;">return</span> even(n - 1);
}

<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">main</span>()
{
  printf(<span style="color: #2aa198;">"\n 7 is even? ... %d"</span>, even(7));
  printf(<span style="color: #2aa198;">"\n 7 is odd? ... %d"</span>, odd(7));
  <span style="color: #859900; font-weight: bold;">return</span> 0;
}
</pre>
</div>
</details>

<p>
Anyhow, e.g., <code>void f(int x){ f(x); }</code> has the definition of <code>wp f(x)</code> using the value of <code>wp f(x)</code>
and so is circular. How can this be avoided?
</p>

<p>
Note that a <i>recursive definition</i> is <b>not</b> just a definition that uses the object which it
is defining. Otherwise, the previous <code>f</code> might as well have been the definition of
the factorial function that on input <code>x</code> simply invokes itself; then again it could
have been any function!
</p>

<details>
<p>
We generally think of recursive definitions as definitions by usual ‚Ñï-induction, however
this is not absolutely true.
E.g., the following function at <code>n</code> not only relies on
values on smaller inputs but also on values at larger inputs to compute the value at <code>n</code>!
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2; font-weight: bold;">#include</span><span style="color: #2aa198;">&lt;stdio.h&gt;</span> <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">for IO</span>

<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">iterations</span> = 0;
<span style="color: #268bd2; font-weight: bold;">#define</span> <span style="color: #b58900;">RETURN</span>(<span style="color: #268bd2;">i</span>, <span style="color: #268bd2;">n</span>) { printf(<span style="color: #2aa198;">"\n **Computed value for input %d is %d**"</span>, i, n); \
                       iterations++; <span style="color: #859900; font-weight: bold;">return</span> n; }

<span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Uses smaller as well as larger values just to compute current value!</span>
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">f</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">n</span>)
{
  printf(<span style="color: #2aa198;">"\n Computing value for: %d"</span>, n);

  <span style="color: #859900; font-weight: bold;">if</span> (n &lt;= 1)     RETURN(n, 1)
  <span style="color: #859900; font-weight: bold;">if</span> (n % 2 == 0) RETURN(n, 1 + f(n / 2))
  <span style="color: #859900; font-weight: bold;">else</span>            RETURN(n, 2 * f(n + 1))
}

<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">main</span>()
{
  f(12);
  printf(<span style="color: #2aa198;">"\n\n The function was invoked for a total of %d times!"</span>, iterations);
  <span style="color: #859900; font-weight: bold;">return</span> 0;
}
</pre>
</div>

<p>
Similarly the Ackermann function is a recursive function that has been proven
to be undefinable using only nested definitions by ‚Ñï-induction.
( However, since ‚Ñï√ó‚Ñï is well-ordered, it is a valid definition. )
</p>
</details>

<p>
We may try to remove recursive calls by replacing every recursive call with
the function body itself, which then has a new recursive call. We may continue
to expand forever by replacing recursive calls with the original function body.
The ‚Äúresult‚Äù will be an non-recursive program that is infinitely long.
</p>

<p>
Thus, recursive programs, like <code>while</code> loops, are a means of expressing infinite
programs and, like <code>while</code> loops, they introduce the possibility of non-termination.
</p>

<p>
As for <code>while</code> loops, we can approximate the infinitely long non-recursive program
by simply giving-up on the <code>n</code>-th expansion, not making any more recursive calls.
Essentially, we do <code>n</code> recursive calls then give-up if the program has not completed.
Hence, we again consider the limit.
</p>
</div>

<div id="outline-container-org3a0fedf" class="outline-3">
<h3 id="org3a0fedf">Recursive Definitions and Fixed Point Equations</h3>
<div class="outline-text-3" id="text-org3a0fedf">
<p>
A recursive function such as the factorial function can be seen as
an equation where the unknown variable is the function currently being defined.
For example, the factorial function is the <i>unique partial function</i> <code>f</code> satisfying
the equation
</p>
<div class="org-src-container">
<pre class="src src-haskell">f  <span style="color: #b58900;">&#8776;</span> (x <span style="color: #268bd2;">&#8614;</span> <span style="color: #859900; font-weight: bold;">if</span> x <span style="color: #268bd2;">&#8776;</span> 0 <span style="color: #859900; font-weight: bold;">then</span> 1 <span style="color: #859900; font-weight: bold;">else</span> x <span style="color: #268bd2;">*</span> f(x<span style="color: #268bd2;">-</span>1))
</pre>
</div>
<p>
This equation has the form <code>f ‚âà F(f)</code>, so it is a ‚Äúfixed point equation‚Äù.
</p>

<p>
Since recursive functions may not terminate, the functions they describe
are partial. It can be proven that any fixed point equation <i>always</i> has
at least one solution; i.e., it defines at least one partial function on the integers.
For example, the equation <code>f ‚âà (x ‚Ü¶ 1 + f(x))</code> corresponding to
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">loop</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">n</span>){ <span style="color: #859900; font-weight: bold;">return</span> 1 + loop(n); }
</pre>
</div>
<p>
Has one solution: The empty function, which is not defined on any input.
</p>

<p>
The set of possible solutions can be ordered by inclusion
of their graphs and so one of them is the smallest.
Incidentally, this least solution is also obtained by the aforementioned limit!
</p>

<p>
E.g., every function is a solution to the equation <code>f ‚âà (x ‚Ü¶ f x)</code>.
</p>
</div>
</div>

<div id="outline-container-org621d337" class="outline-3">
<h3 id="org621d337">Programming without Assignment &#x2013;the Functional Core</h3>
<div class="outline-text-3" id="text-org621d337">
<p>
Notice that the factorial function can be written without using assignments:
</p>
<details>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ axiomatic Factorial</span>
<span style="color: #96A7A9; font-style: italic;">  @ {</span>
<span style="color: #96A7A9; font-style: italic;">  @    logic integer factorial(integer n);</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@    axiom fact_zero</span><span style="color: #96A7A9; font-style: italic;">:  \forall integer n;    factorial(0) == 1;</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@    axiom fact_succ</span><span style="color: #96A7A9; font-style: italic;">:  \forall integer n; 0 &lt;= n</span>
<span style="color: #96A7A9; font-style: italic;">  @                 ==&gt;  factorial (n + 1) == n * factorial (n);</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@    axiom fact_monotone </span><span style="color: #96A7A9; font-style: italic;">: \forall integer m,n; 0 &lt;= m &lt;= n</span>
<span style="color: #96A7A9; font-style: italic;">  @          ==&gt; factorial(m) &lt;= factorial(n);</span>
<span style="color: #96A7A9; font-style: italic;">  @ }</span>
<span style="color: #96A7A9; font-style: italic;">  */</span>
</pre>
</div>
</details>
<div class="org-src-container">
<pre class="src src-c" id="orgc72b51b"><span style="color: #268bd2; font-weight: bold;">#include</span> <span style="color: #2aa198;">"Prelude.c"</span>

<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #b58900;">@ requires Exercise</span><span style="color: #96A7A9; font-style: italic;">: FixMe;</span>
<span style="color: #96A7A9; font-style: italic;">  @ assigns \nothing;</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@ ensures Exercise</span><span style="color: #96A7A9; font-style: italic;">: FixMe;</span>
<span style="color: #96A7A9; font-style: italic;">  */</span>
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">fact_imp</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">n</span>)
{
  <span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">r</span> = 1;

  <span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ loop assigns i, r;</span>
<span style="color: #96A7A9; font-style: italic;">    </span><span style="color: #b58900;">@ loop invariant range_on_i</span><span style="color: #96A7A9; font-style: italic;">: FixMe;</span>
<span style="color: #96A7A9; font-style: italic;">    </span><span style="color: #b58900;">@ loop invariant relationship_between_r_i_n</span><span style="color: #96A7A9; font-style: italic;">: FixMe;</span>
<span style="color: #96A7A9; font-style: italic;">    </span><span style="color: #b58900;">@ loop variant FixMe</span><span style="color: #96A7A9; font-style: italic;">: 666;</span>
<span style="color: #96A7A9; font-style: italic;">  */</span>
  <span style="color: #859900; font-weight: bold;">for</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">i</span> = 1; i &lt;= n; i++)
    r = r * i;

  <span style="color: #859900; font-weight: bold;">return</span> r;
}

<span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">&#8776;</span>

<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ requires 0 &lt;= n;</span>
<span style="color: #96A7A9; font-style: italic;">  @ requires factorial(n) &lt;= INT_MAX;</span>
<span style="color: #96A7A9; font-style: italic;">  @ assigns \nothing;</span>
<span style="color: #96A7A9; font-style: italic;">  @ ensures \result == factorial(n);</span>
<span style="color: #96A7A9; font-style: italic;">  */</span>
<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #b58900;">fact_functional</span>(<span style="color: #b58900; font-style: italic;">int</span> <span style="color: #268bd2;">n</span>)
{
  <span style="color: #859900; font-weight: bold;">if</span> (n == 0) <span style="color: #859900; font-weight: bold;">return</span> 1;
  <span style="color: #859900; font-weight: bold;">return</span> n * fact_functional(n - 1);
}
</pre>
</div>
<p>
( Notice that <i>¬¨(i ‚â§ n)[i ‚âî 1]  ‚â°  n = 0</i> when considering <i>n : ‚Ñï</i>. )
</p>

<p>
Hence if we remove assignments, then the memory state for computation is
always empty and so sequences and loops become useless. We are left with
only variable declarations, function calls, and the built-in operations.
This is the <i>functional core</i> of the language and it is surprisingly as powerful
as the imperative core. Why? Recall that a term, or statement, can be thought
of as a (partial) function of its free variables; now the functions obtained
this way using only the functional core are the same as those obtained by also
using the whole of the imperative core!
Note that omitting recursion falsifies this result.
</p>
</div>
</div>
</div>

<div id="outline-container-orgdec375b" class="outline-2">
<h2 id="orgdec375b">Hehner's Problem</h2>
<div class="outline-text-2" id="text-orgdec375b">
<p>
We have now covered enough material to tackle the problem posed
at the very beginning &#x2014;that of <code>whatDo</code>.
</p>

<details>
<div class="org-src-container">
<pre class="src src-c" id="orgc416110"><span style="color: #268bd2; font-weight: bold;">#include</span> <span style="color: #2aa198;">"Prelude.c"</span>

<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@  requires \valid(x) &amp;&amp; \valid(y);</span>
<span style="color: #96A7A9; font-style: italic;">     requires 0 &lt;= *x &lt; 31;</span>
<span style="color: #96A7A9; font-style: italic;">     requires Exercise: FixMe;</span>
<span style="color: #96A7A9; font-style: italic;">     assigns *x, *y;</span>
<span style="color: #96A7A9; font-style: italic;">     ensures Exercise: FixMe;</span>
<span style="color: #96A7A9; font-style: italic;"> */</span>
<span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">whatDo</span>(<span style="color: #b58900; font-style: italic;">int</span>* <span style="color: #268bd2;">x</span>, <span style="color: #b58900; font-style: italic;">int</span>* <span style="color: #268bd2;">y</span>)
{
  <span style="color: #859900; font-weight: bold;">if</span> (*x == 0)
    {
      *y = 1; *x = 3;
    }
  <span style="color: #859900; font-weight: bold;">else</span>
    {
      *x -= 1; *y = 7;
      whatDo(x, y);
      *y *= 2; *x = 5;
    }
}
</pre>
</div>
</details>

<p>
Running a few test inputs, it can be seen that this program
sets <code>y</code> to be the power of <code>x</code>. Further testing may reveal interesting
issues when <code>x</code> and <code>y</code> refer to the same memory location!
</p>

<details>
<pre class="example">
‚ü®x = 0, y = 0‚ü© ‚Ü¶ ‚ü®x = 3, y = 1‚ü©
‚ü®x = 1, y = 2‚ü© ‚Ü¶ ‚ü®x = 5, y = 2‚ü©
‚ü®x = 3, y = 4‚ü© ‚Ü¶ ‚ü®x = 5, y = 8‚ü©
‚ü®x = 5, y = 6‚ü© ‚Ü¶ ‚ü®x = 5, y = 32‚ü©
‚ü®x = 7, y = 8‚ü© ‚Ü¶ ‚ü®x = 5, y = 128‚ü©
‚ü®x = 0, y = 99‚ü© ‚Ü¶ ‚ü®x = 3, y = 1‚ü©

x == y  ‚áí  Segmentation Fault
</pre>
</details>

<p>
With this guidance in hand, we aim to axiomatise the power function:
</p>
<div class="org-src-container">
<pre class="src src-c" id="orga5ed504"><span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@ axiomatic Pow</span>
<span style="color: #96A7A9; font-style: italic;">  @ {</span>
<span style="color: #96A7A9; font-style: italic;">  @    logic integer pow(integer b, integer n);</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@    axiom pow_zero</span><span style="color: #96A7A9; font-style: italic;">:  \forall integer b;        pow(b, 0) == 1;</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@    axiom pow_one</span><span style="color: #96A7A9; font-style: italic;">:  \forall integer b;        pow(b, 1) == b;</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@    axiom pow_homomorphism</span><span style="color: #96A7A9; font-style: italic;">:  \forall integer b, m, n;</span>
<span style="color: #96A7A9; font-style: italic;">  @                 pow(b, m + n) == pow(b, m) * pow(b, n);</span>
<span style="color: #96A7A9; font-style: italic;">  @</span>
<span style="color: #96A7A9; font-style: italic;">  </span><span style="color: #b58900;">@    axiom pow_monotone </span><span style="color: #96A7A9; font-style: italic;">: \forall integer b,m,n; b &gt;= 0  &amp;&amp;  0 &lt;= m &lt;= n</span>
<span style="color: #96A7A9; font-style: italic;">  @          ==&gt; pow(b,m) &lt;= pow(b,n);</span>
<span style="color: #96A7A9; font-style: italic;">  @ }</span>
<span style="color: #96A7A9; font-style: italic;">  */</span>
</pre>
</div>

<p>
Notice that there are infinitely many solutions <code>f</code> to the equations
</p>
<ul class="org-ul">
<li><code>pow_zero</code>: <i>f(0) = 1</i></li>
<li><code>pow_homomorphism</code>: <i>f(m + n) = f(m) * f(n)</i></li>
</ul>

<p>
Which ones? Since every natural number is of the form <i>1 + 1 + ‚ãØ + 0</i>
the second requirement yields \\ <i>f(n) = f (1 + 1 + ‚ãØ + 0) = f 1 * f 1 * ‚ãØ f 1 * f 0;</i>
which by the first requirement simplifies to <i>f(n) = (f 1)‚Åø</i>.
Hence for any choice of number <i>f(1) : ‚Ñï</i>, we obtain a function <i>f</i>
that satisfies these definitions. If we want <i>f</i> to be the <i>n</i> product of a number
<i>b</i> then we need to insist <i>f 1 = b</i> &#x2013;which is just <code>pow_one</code>!
</p>

<p>
From the axioms, we obtain some useful lemmas.
</p>
<div class="org-src-container">
<pre class="src src-c" id="org287e742"><span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ lemma pow_succ</span><span style="color: #96A7A9; font-style: italic;">:  \forall integer b, n; n &gt;= 0  ==&gt;     pow(b, n + 1) == pow(b, n) * b;</span>
<span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ lemma powNonNeg </span><span style="color: #96A7A9; font-style: italic;">: \forall integer b,n; b &gt;= 0 ==&gt; n &gt;= 0 ==&gt; pow(b,n) &gt;= 0;</span>
<span style="color: #96A7A9; font-style: italic;">//</span><span style="color: #b58900;">@ lemma pow2bound </span><span style="color: #96A7A9; font-style: italic;">: \forall integer n; 0 &lt;= n &lt; 31 ==&gt; pow(2, n) &lt; INT_MAX;</span>
<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #b58900;">@ lemma powPredT </span><span style="color: #96A7A9; font-style: italic;">: \forall integer b,n,m;  b &gt;= 0  &amp;&amp;  n &gt; 0</span>
<span style="color: #96A7A9; font-style: italic;">                                &amp;&amp;  pow(b, n) &lt;= m  ==&gt;  b * pow(b, n-1) &lt;= m;</span><span style="color: #96A7A9; font-style: italic;"> */</span>
</pre>
</div>

<p>
With this setup, the reader should now be able to solve the <code>FixMe</code>'s in <code>whatDo</code>
&#x2013;which I've renamed to ‚Äúhehner‚Äù, after the fellow who showed it as an example
in his excellent specifications and correctness text, <a href="http://www.cs.toronto.edu/~hehner/aPToP/">A Practical Theory of Programming</a>.
</p>
<div class="org-src-container">
<pre class="src src-c" id="orgc381ca8"><span style="color: #268bd2; font-weight: bold;">#include</span> <span style="color: #2aa198;">"Prelude.c"</span>

<span style="color: #96A7A9; font-style: italic;">/*</span><span style="color: #96A7A9; font-style: italic;">@  requires \valid(x) &amp;&amp; \valid(y);</span>
<span style="color: #96A7A9; font-style: italic;">     requires 0 &lt;= *x &lt; 31;</span>
<span style="color: #96A7A9; font-style: italic;">     requires Exercise: FixMe;      // Assuming \false, gives us anything!</span>
<span style="color: #96A7A9; font-style: italic;">     assigns *x, *y;</span>
<span style="color: #96A7A9; font-style: italic;">     ensures Exercise: FixMe;</span>
<span style="color: #96A7A9; font-style: italic;"> */</span>
<span style="color: #b58900; font-style: italic;">void</span> <span style="color: #b58900;">hehner</span>(<span style="color: #b58900; font-style: italic;">int</span>* <span style="color: #268bd2;">x</span>, <span style="color: #b58900; font-style: italic;">int</span>* <span style="color: #268bd2;">y</span>)
{
  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">Introduce a local for reasoning, to avoid having to write \at(*x, Pre).</span>
  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">ghost const int X = *x;</span>

  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">assert given: 0 &lt;= X &lt; 31;</span>
  <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">assert taking_powers_with_monotonicity: 1 &lt;= pow(2,X) &lt;= INT_MAX;</span>
  <span style="color: #859900; font-weight: bold;">if</span> (*x == 0)
    {
      <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">assert condition: X == 0;</span>
      <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">assert taking_powers: pow(2,X) == 1;</span>
      *y = 1; *x = 3;
      <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">assert *y == pow(2,X);</span>
    }
  <span style="color: #859900; font-weight: bold;">else</span>
    {
      <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">assert condition: 0 &lt; X &lt; 31;</span>
      <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">assert pow_with_monotonicity: 1 &lt; pow(2, X) &lt;= INT_MAX;</span>
      <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">assert factoring: 2 * pow(2, X-1) &lt;= INT_MAX;</span>

      *x -= 1; *y = 7;
      hehner(x, y);

      <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">assert function_ensures: *y == pow(2, X - 1);</span>
      <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">assert pow(2, X) == 2 * pow(2, X - 1);</span>
      <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">assert     pow(2, X    ) &#8804; INT_MAX;</span>
      <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">assert 2 * pow(2, X - 1) &#8804; INT_MAX;</span>
      <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">assert y2_no_overflow: *y * 2 &#8804; INT_MAX;</span>

      *y *= 2; *x = 5;

      <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">assert our_goal: *y == pow(2, X);</span>
      <span style="color: #96A7A9; font-style: italic;">// </span><span style="color: #96A7A9; font-style: italic;">assert incidentally: *y &lt;= INT_MAX;</span>
    }
}
</pre>
</div>

<p>
I've left the <code>assert</code>'s since they may make the program proof more comprehensible
to the reader &#x2013;yet notice that I did not use <code>@</code> and so they are not visible,
nor necessary, to Frama-C.
</p>
</div>
</div>

<div id="outline-container-orgc39c4af" class="outline-2">
<h2 id="orgc39c4af">Advanced Data Structures</h2>
<div class="outline-text-2" id="text-orgc39c4af">
<p>
This is what I have so far, yet I look forward to including material
utilising linked lists as well as making more of the Curry-Howard Correspondence.
</p>

<p>
Anyhow, I hope you've enjoyed yourself and hopefully learned something neat! Byebye!
</p>
</div>
</div>

<div id="outline-container-org0e72004" class="outline-2">
<h2 id="org0e72004">The Underlying Elisp</h2>
<div class="outline-text-2" id="text-org0e72004">
<p>
The following utilities are loaded when this file is opened.
After the first time the file <code>InteractiveWayToC.el</code> is created and this section
may be deleted, or <code>COMMENT</code>-ed, as it is loaded in the <code>footer</code> section at the end of this file.
</p>

<ol class="org-ol">
<li>Make some changes, look at them with <code>f7</code>.
<ul class="org-ul">
<li>Or execute with <code>f6</code> if there is a <code>main</code> method.</li>
</ul></li>
<li>Check your progress with <code>f9</code>, within Emacs.</li>
<li>If confused, open the Frama-C gui with <code>f8</code>.</li>
</ol>

<p>
Note: There is a 10 second time limit on the proof search.
</p>

<p>
Every source block is in ‚Äòfocus‚Äô when the variables <code>NAME</code> and <code>NAMECode</code> refer to it.
</p>
<details>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">setq</span> Language <span style="color: #2aa198;">"c"</span> LanguageExtension <span style="color: #2aa198;">"c"</span>)
(<span style="color: #859900; font-weight: bold;">setq</span> NAMEEXT (<span style="color: #b58900;">buffer-name</span>) NAME (<span style="color: #b58900;">file-name-sans-extension</span> NAMEEXT))
(<span style="color: #859900; font-weight: bold;">setq</span> NAMECode (<span style="color: #b58900;">concat</span> NAME <span style="color: #2aa198;">"."</span> LanguageExtension))
</pre>
</div>
</details>

<p>
We explicitly change focus using <code>[not-]currently-working-with</code> methods.
</p>
<details>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">buffer-name-sans-extension</span> () <span style="color: #35a69c; font-style: italic;">""</span>
  (<span style="color: #b58900;">file-name-sans-extension</span> (<span style="color: #b58900;">buffer-name</span>))
)

(<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">currently-working-with</span> (<span style="color: #b58900; font-style: italic;">&amp;optional</span> name)
  <span style="color: #35a69c; font-style: italic;">"Provide the name (without extension) of the source block's resulting file.</span>
<span style="color: #35a69c; font-style: italic;">   The name is then tied to the &#8220;NAMECode&#8221; global variable utilised</span>
<span style="color: #35a69c; font-style: italic;">   by the &#8220;show-code&#8221; method, &lt;f7&gt;, and the &#8220;interpret&#8221; command's global variable &#8220;NAME&#8221;.</span>

<span style="color: #35a69c; font-style: italic;">   If no argument is provided, we use &#8220;&#10218;BufferName&#10219;.c&#8221; as default file name.</span>
<span style="color: #35a69c; font-style: italic;">  "</span>
  (<span style="color: #859900; font-weight: bold;">unless</span> name (<span style="color: #859900; font-weight: bold;">setq</span> name (buffer-name-sans-extension)))
  (<span style="color: #859900; font-weight: bold;">setq</span> NAME name)
  (<span style="color: #859900; font-weight: bold;">setq</span> NAMECode (<span style="color: #b58900;">concat</span> name <span style="color: #2aa198;">".c"</span>))
)

(<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">not-currently-working-with</span> (<span style="color: #b58900; font-style: italic;">&amp;optional</span> name)
  <span style="color: #35a69c; font-style: italic;">"When &#8220;:tangle fn&#8221; has &#8220;fn&#8221; being the empty string, the tangle does not transpire.</span>
<span style="color: #35a69c; font-style: italic;">   As such, it is as if we are not actually generating the source block.</span>

<span style="color: #35a69c; font-style: italic;">   This operation only returns the empty string and does not alter any existing state.</span>
<span style="color: #35a69c; font-style: italic;">   If we alter state, then earlier invocations to (currently-working-with) are rendered</span>
<span style="color: #35a69c; font-style: italic;">   useless!</span>
<span style="color: #35a69c; font-style: italic;">  "</span>

  <span style="color: #2aa198;">""</span>   <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Our return value.</span>
)
</pre>
</div>
</details>

<p>
Notice that the <code>InteractiveWayToC.el</code> methods &#x2013;&lt;F6&gt; to &lt;F9&gt;&#x2013; target the
source block(s) with (<code>currently-working-with name)</code> where <code>name</code> is the most
recent name. Note that the <code>name</code> component need not be unique: Blocks having
the same one write to the same file.
</p>

<p>
In a new line enter <code>&lt;s</code> then at the end press <code>TAB</code> to obtain a nice hello-world
template. Some code will be generated for you &#x2013;free of charge&#x2013;, edit it as you like.
</p>
<details>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">make-variable-buffer-local</span> '<span style="color: #268bd2;">org-structure-template-alist</span>)
(<span style="color: #859900; font-weight: bold;">setq</span> TEMPLATE
  (<span style="color: #b58900;">concat</span>
   <span style="color: #2aa198;">"#+NAME: ???? -- goal of this code block"</span>
   <span style="color: #2aa198;">"\n#+BEGIN_SRC "</span> Language <span style="color: #2aa198;">" :tangle (currently-working-with \"HelloWorld\") \n"</span>
   <span style="color: #2aa198;">"#include&lt;stdio.h&gt; // for IO"</span>
   <span style="color: #2aa198;">"\nint main() \n{\n  printf(\"--Hello, World!--\");\n  return 0; \n}"</span>
   <span style="color: #2aa198;">"\n#+END_SRC"</span>))
(<span style="color: #b58900;">add-to-list</span> '<span style="color: #268bd2;">org-structure-template-alist</span> `(<span style="color: #2aa198;">"s"</span> ,TEMPLATE))
</pre>
</div>
</details>

<p>
Then to see the code generated by this file press <code>M-x</code> then enter <code>show-code</code> then enter;
alternatively, press <code>C-x C-e</code> after the final parenthesis: (show-code).
</p>

<p>
My definition of <code>(show-code)</code> begins with closing the code buffer if it exists,
then continue by extracting the most recent code and displaying it below the current buffer.
The definition of <code>(interpret)</code> is nearly the same except we switch to an output buffer,
and create it if it doesn't exist.
Note that our interpretation command is essentially the following command line invocation:
<code>NAME=myfilename ; gcc $NAME.c -o $NAME.exe ; ./$NAME.exe</code>
</p>

<details>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">show-code</span> () <span style="color: #35a69c; font-style: italic;">"Show focused source blocks in a new buffer."</span>
  (<span style="color: #859900; font-weight: bold;">interactive</span>)
  (<span style="color: #859900; font-weight: bold;">ignore-errors</span> (<span style="color: #b58900;">kill-buffer</span> NAMECode))
  (<span style="color: #b58900;">save-buffer</span>)
  (<span style="color: #b58900;">org-babel-tangle</span>)
  (<span style="color: #b58900;">split-window-below</span>)
  (<span style="color: #b58900;">find-file</span> NAMECode)
  (<span style="color: #b58900;">other-window</span> 1))

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Since there are many generated files, let's mention the name</span>
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">of the program file currently being executed, or proven.</span>
<span style="color: #96A7A9; font-style: italic;">;;</span>
(<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">insert-focused-name</span> ()
   <span style="color: #35a69c; font-style: italic;">"Insert the name of the focused source blocks at the beginning of the buffer."</span>
  (<span style="color: #b58900;">beginning-of-buffer</span>)
  (<span style="color: #b58900;">insert</span> <span style="color: #2aa198;">"================\n&#10218; "</span> NAME <span style="color: #2aa198;">".c &#10219;\n================\n\n"</span>))

(<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">interpret</span> () <span style="color: #35a69c; font-style: italic;">"Execute focused source blocks in a new buffer."</span>
  (<span style="color: #859900; font-weight: bold;">interactive</span>)
  (<span style="color: #b58900;">save-buffer</span>)
  (<span style="color: #b58900;">org-babel-tangle</span>)
  (<span style="color: #b58900;">switch-to-buffer-other-window</span> <span style="color: #2aa198;">"*Shell Command Output*"</span>)
  (<span style="color: #b58900;">shell-command</span>
    (<span style="color: #b58900;">concat</span> <span style="color: #2aa198;">"cd "</span> <span style="color: #268bd2;">default-directory</span> <span style="color: #2aa198;">"; NAME="</span> NAME <span style="color: #2aa198;">" ; gcc $NAME.c -o $NAME.exe ; ./$NAME.exe"</span>))
  (insert-focused-name)
  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Go back to the literate buffer.</span>
  (<span style="color: #b58900;">other-window</span> 1))

(<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">frama-c</span> () <span style="color: #35a69c; font-style: italic;">""</span>
  (<span style="color: #859900; font-weight: bold;">interactive</span>)
  (<span style="color: #b58900;">save-buffer</span>)
  (<span style="color: #b58900;">org-babel-tangle</span>)
  (<span style="color: #b58900;">shell-command</span> (<span style="color: #b58900;">concat</span> <span style="color: #2aa198;">"frama-c-gui "</span> NAMECode <span style="color: #2aa198;">" -wp -rte &amp;"</span>)))

(<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">try</span> (this that) <span style="color: #35a69c; font-style: italic;">""</span>
  (<span style="color: #859900; font-weight: bold;">condition-case</span> nil (<span style="color: #b58900;">eval</span> this) (<span style="color: #b58900;">error</span> (<span style="color: #b58900;">eval</span> that))))
</pre>
</div>
</details>

<p>
The <code>frama-c-no-gui</code> command tries to find where an error happens by placing the cursor
near an unproven assertion. It does so by looking for the phrase <code>false</code> in the shell output
buffer after the <code>frama-c</code> program is invoked. If it cannot find it, you are placed at
the end of the buffer and, ideally but not necessarily, should see all goals have passed.
</p>

<details>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">frama-c-no-gui</span> () <span style="color: #35a69c; font-style: italic;">""</span>
  (<span style="color: #859900; font-weight: bold;">interactive</span>)
  (<span style="color: #b58900;">org-babel-tangle</span>)
  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Avoid generating proof goal statements --for now.</span>
  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">(shell-command (concat "frama-c " NAMECode " -wp -wp-msg-key=print-generated -rte"))</span>
  (<span style="color: #b58900;">shell-command</span> (<span style="color: #b58900;">concat</span> <span style="color: #2aa198;">"frama-c "</span> NAMECode <span style="color: #2aa198;">" -wp -wp-timeout 10 -rte"</span>))

  (<span style="color: #b58900;">switch-to-buffer-other-window</span> <span style="color: #2aa198;">"*Shell Command Output*"</span>)
  (insert-focused-name)
  (<span style="color: #b58900;">hl-line-mode</span>)

  (<span style="color: #859900; font-weight: bold;">setq</span> frama-c-state (<span style="color: #859900; font-weight: bold;">catch</span> '<span style="color: #6c71c4; font-weight: bold;">state</span>   <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Global variable indicating current state</span>
  (<span style="color: #859900; font-weight: bold;">dolist</span> (elem '(<span style="color: #2aa198;">"Exercise"</span> <span style="color: #2aa198;">"unknown"</span> <span style="color: #2aa198;">"user error"</span> <span style="color: #2aa198;">"false"</span> <span style="color: #2aa198;">"Timeout"</span> <span style="color: #2aa198;">"Proved goals"</span>))
    (<span style="color: #b58900;">beginning-of-buffer</span>)
    (try '(<span style="color: #859900; font-weight: bold;">and</span> (<span style="color: #b58900;">search-forward</span> elem) (<span style="color: #859900; font-weight: bold;">throw</span> '<span style="color: #6c71c4; font-weight: bold;">state</span> elem)) 'nil)
  )))

  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">global variable about status</span>
  (<span style="color: #859900; font-weight: bold;">setq</span> frama-c-status (<span style="color: #b58900;">format</span> <span style="color: #2aa198;">"Frama-C: %d&#65130; of proof complete!"</span> (frama-c-progress)))

  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Use the red colour of failure.</span>
  (<span style="color: #b58900;">set-face-background</span> '<span style="color: #556b72; background-color: #FDF6E3;">hl-line</span> <span style="color: #2aa198;">"pink"</span>)

  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Or did we succeed?</span>
  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">We might have halted a &#8220;false&#8221; *constant* even though all goals pass.</span>
  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#10216; This is not an issue when proofs are not being generated. &#10217;</span>
  (<span style="color: #859900; font-weight: bold;">if</span> (<span style="color: #b58900;">equal</span> frama-c-state <span style="color: #2aa198;">"Exercise"</span>)
        (<span style="color: #859900; font-weight: bold;">setq</span> frama-c-status (<span style="color: #b58900;">concat</span> frama-c-status <span style="color: #2aa198;">" &#10218;There are holes!&#10219;"</span>))
        (<span style="color: #859900; font-weight: bold;">when</span> (<span style="color: #859900; font-weight: bold;">or</span> (<span style="color: #b58900;">equal</span> frama-c-state <span style="color: #2aa198;">"Proved goals"</span>)
                  (<span style="color: #b58900;">eq</span> (frama-c-progress) 100))
              (<span style="color: #b58900;">set-face-background</span> '<span style="color: #556b72; background-color: #FDF6E3;">hl-line</span> <span style="color: #2aa198;">"pale green"</span>)
              (try '(<span style="color: #b58900;">search-forward</span> <span style="color: #2aa198;">"Proved goals"</span>) <span style="color: #268bd2;">t</span>)))
  (<span style="color: #b58900;">message</span> frama-c-status)
  (<span style="color: #b58900;">minimize-window</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Make current buffer roughly 3 lines in height.</span>
)
</pre>
</div>
</details>

<p>
Where the <code>frama-c-progress</code> command yields the percentage denoting the number of goals proven.
</p>
<details>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">frama-c-progress</span> () <span style="color: #35a69c; font-style: italic;">""</span>
  (<span style="color: #859900; font-weight: bold;">let</span> ( (here (<span style="color: #b58900;">point</span>)) )
  (<span style="color: #b58900;">beginning-of-buffer</span>)
  (try '(<span style="color: #b58900;">search-forward</span> <span style="color: #2aa198;">"Proved goals:"</span>) 0)
  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">(kill-line)</span>
    (<span style="color: #b58900;">copy-region-as-kill</span> (<span style="color: #b58900;">point</span>) (<span style="color: #b58900;">point-at-eol</span>))
    (<span style="color: #b58900;">goto-char</span> here)
    (<span style="color: #b58900;">*</span> 100 (<span style="color: #b58900;">string-to-number</span> (<span style="color: #b58900;">calc-eval</span> (<span style="color: #b58900;">current-kill</span> 0))))
  ))
</pre>
</div>
</details>

<p>
Finally,
</p>
<details>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">local-set-key</span> (<span style="color: #b58900;">kbd</span> <span style="color: #2aa198;">"&lt;f6&gt;"</span>) 'interpret)
(<span style="color: #b58900;">local-set-key</span> (<span style="color: #b58900;">kbd</span> <span style="color: #2aa198;">"&lt;f7&gt;"</span>) 'show-code)
(<span style="color: #b58900;">local-set-key</span> (<span style="color: #b58900;">kbd</span> <span style="color: #2aa198;">"&lt;f8&gt;"</span>) 'frama-c)
(<span style="color: #b58900;">local-set-key</span> (<span style="color: #b58900;">kbd</span> <span style="color: #2aa198;">"&lt;f9&gt;"</span>) 'frama-c-no-gui)
</pre>
</div>
</details>

<p>
It is to be noted: I only know enough Elisp to get by.
</p>

<p>
Again: Hope you had fun!
</p>
</div>
</div>
<div class="taglist"><a href="https://alhassy.github.io/tags.html">Tags</a>: <a href="https://alhassy.github.io/tag-program-proving.html">program-proving</a> <a href="https://alhassy.github.io/tag-c.html">c</a> <a href="https://alhassy.github.io/tag-emacs.html">emacs</a> <a href="https://alhassy.github.io/tag-frama-c.html">frama-c</a> </div><div id="archive">
<a href="https://alhassy.github.io/archive.html">Other posts</a>
</div>
</div>
<div id="postamble" class="status"><div id="archive">
  <a href="https://alhassy.github.io/archive.html">Other posts</a>
</div>
<center><a rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a><br /><span xmlns:dct="https://purl.org/dc/terms/" href="https://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">Life and Computing Science</span> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://alhassy.github.io/" property="cc:attributionName" rel="cc:attributionURL">Musa Al-hassy</a> is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.</center>

<div id="archive"><a href="archive.html">Other posts</a></div>
              <div id="disqus_thread"></div>
              <script type="text/javascript">
              /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
              var disqus_shortname = 'life-and-computing-science';
              /* * * DON'T EDIT BELOW THIS LINE * * */
              (function() {
                var dsq = document.createElement('script');
                dsq.type = 'text/javascript';
                dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                  })();
              </script>
              <noscript>Please enable JavaScript to view the
                  <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
              <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></div>
</body>
</html>
