<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://alhassy.github.io/rss.xml"
      title="RSS feed for https://alhassy.github.io/"/>
<title>Life & Computing Science</title>

<link rel="stylesheet" type="text/css" href="https://alhassy.github.io/org-special-block-extras/tooltipster/dist/css/tooltipster.bundle.min.css"/>

<link rel="stylesheet" type="text/css" href="https://alhassy.github.io/org-special-block-extras/tooltipster/dist/css/plugins/tooltipster/sideTip/themes/tooltipster-sideTip-punk.min.css" />

<script type="text/javascript" src="https://code.jquery.com/jquery-1.10.0.min.js"></script>

 <script type="text/javascript"            src="https://alhassy.github.io/org-special-block-extras/tooltipster/dist/js/tooltipster.bundle.min.js"></script>

  <script>
         $(document).ready(function() {
             $('.tooltip').tooltipster({
                 theme: 'tooltipster-punk',
                 contentAsHTML: true,
                 animation: 'grow',
                 delay: [100,500],
                 // trigger: 'click'
                 trigger: 'custom',
                 triggerOpen: {
                     mouseenter: true
                 },
                 triggerClose: {
                     originClick: true,
                     scroll: true
                 }
 });
         });
     </script>

<style>
   abbr {color: red;}

   .tooltip { border-bottom: 1px dotted #000;
              color:red;
              text-decoration: none;}
</style>
<meta name="author" content="Musa Al-hassy">
<meta name="referrer" content="no-referrer">
<link href="usual-org-front-matter.css" rel="stylesheet" type="text/css" />
<link href="org-notes-style.css" rel="stylesheet" type="text/css" />
<link href="floating-toc.css" rel="stylesheet" type="text/css" />
<link href="blog-banner.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="images/favicon.png">

<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
,*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>

</head>
<body>
<div id="preamble" class="status"><div class="header">
  <a href="https://alhassy.github.io/" class="logo">Life & Computing Science</a>
  <br>
    <a href="https://alhassy.github.io/AlBasmala">AlBasmala</a>
    <a href="https://alhassy.github.io/archive">Archive</a>
    <a href="https://alhassy.github.io/tags">Tags</a>
    <a href="https://alhassy.github.io/rss.xml">RSS</a>
    <a href="https://alhassy.github.io/about">About</a>
</div></div>
<div id="content">
<h1 class="title">Posts tagged "types":</h1>
<h1 class="post-title"><div class="title" style="margin: 0 0 0 0 !important;"><a href="https://alhassy.github.io/TypedLisp.html">Typed Lisp, A Primer</a></h1></div><div style="text-align: center;">21 Aug 2019</div><center> <img src="images/emacs-birthday-present.png" alt="Article image"
  width="350" height="350" align="top" /> </center><br><center><strong>Abstract</strong></center>
<nav id="table-of-contents">
<h2>Ξ</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#inconsistent-love"><a href="#inconsistent-love">“Loving Haskell &amp; Lisp is Inconsistent”</a></a></li>
<li><a href="#terse-types-tutorial"><a href="#terse-types-tutorial">Why Bother with Types? A Terse Tutorial on Type Systems</a></a>
<ul>
<li><a href="#type-checking"><a href="#type-checking">Obtaining &amp; Checking Types</a></a></li>
<li><a href="#lisp-is-eval"><a href="#lisp-is-eval">Statics &amp; Dynamics of Lisp</a></a></li>
<li><a href="#lisp-is-dynamic"><a href="#lisp-is-dynamic">Variable Scope</a></a></li>
<li><a href="#lisp-is-strong"><a href="#lisp-is-strong">Casts &amp; Coercions</a></a></li>
<li><a href="#type-annotations"><a href="#type-annotations">Type Annotations</a></a></li>
<li><a href="#typecase"><a href="#typecase">Type-directed Computations</a></a></li>
<li><a href="#type-specifiers"><a href="#type-specifiers">Type Specifiers: On the nature of types in Lisp</a></a></li>
<li><a href="#deftype"><a href="#deftype">Making New Types with <code>deftype</code></a></a></li>
<li><a href="#adts"><a href="#adts">Algebraic Data Types a la Haskell</a></a></li>
</ul>
</li>
<li><a href="#why-dynamic"><a href="#why-dynamic">In Defence of Being Dynamically Checked</a></a></li>
<li><a href="#lisp-funny-history"><a href="#lisp-funny-history">With its hierarchy of types, why isn't Lisp statically typed?</a></a></li>
<li><a href="#lisp-is-typed"><a href="#lisp-is-typed">Lisp Actually Admits Static Typing!</a></a></li>
<li><a href="#elisp-types"><a href="#elisp-types">ELisp's Type Hierarchy</a></a>
<ul>
<li><a href="#Number"><a href="#Number">Number</a></a></li>
<li><a href="#Character"><a href="#Character">Character</a></a></li>
<li><a href="#Symbol"><a href="#Symbol">Symbol</a></a></li>
<li><a href="#Sequence"><a href="#Sequence">Sequence</a></a></li>
<li><a href="#Function"><a href="#Function">Function</a></a></li>
<li><a href="#Macro"><a href="#Macro">Macro</a></a></li>
<li><a href="#Record"><a href="#Record">Record</a></a></li>
</ul>
</li>
<li><a href="#typing-via-macros"><a href="#typing-via-macros">Typing via Macros &amp; Advice</a></a></li>
<li><a href="#Closing"><a href="#Closing">Closing</a></a></li>
<li><a href="#references"><a href="#references">References</a></a></li>
</ul>
</div>
</nav>

<p>
Let's explore Lisp's fine-grained type hierarchy!
</p>

<p>
We begin with a shallow comparison to Haskell, a rapid tour of type theory,
try in vain to defend dynamic approaches, give a somewhat humorous account of history,
note that you've been bamboozled &#x2014;type's have always been there&#x2014;,
then go into technical details of some Lisp types, and finally conclude by showing
how <i>macros permit typing</i>.
</p>

<p>
Goals for this article:
</p>

<ol class="org-ol">
<li>Multiple examples of type constructions in Lisp.</li>
<li>Comparing Lisp type systems with modern languages, such as Haskell.</li>
<li>Show how algebraic <a href="#org47d3d0a">polymorphic</a> types like <code>Pair</code> and <code>Maybe</code> can be defined in Lisp.
Including heterogeneously typed lists!</li>
<li>Convey a passion for an elegant language.</li>
<li>Augment Lisp with functional Haskell-like type declarations ;-)</li>
</ol>

<p>
Unless suggested otherwise, the phrase “Lisp” refers to
<a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#index-cl_002ddeftype-14">Common Lisp as supported by Emacs Lisp</a>. As such, the resulting discussion
is applicable to a number of Lisp dialects
&#x2014;I'm ignoring editing types such as buffers and keymaps, for now.
</p>

<small> <center>
<p>
( Original print by Baneen Al-hassy as a birthday present to me. )
</p>
</center> </small>
<style>

.figure-number {
    display: none;
}

.table-number {
    display: none;
}

/* Using source blocks “math” as aliaas for haskell */
pre.src-math:before { content: 'Mathematical! Algebraic! Axiomatic!'; }
/* Execute this for alias: (add-to-list 'org-src-lang-modes '("math" . haskell)) */

</style>

<div id="outline-container-orgb60ba22" class="outline-2">
<h2 id="inconsistent-love"><a href="#inconsistent-love">“Loving Haskell &amp; Lisp is Inconsistent”</a></h2>
<div class="outline-text-2" id="text-inconsistent-love">
<p>
I have convinced a number of my peers to use Emacs/Spacemacs/Doom-emacs,
but my efforts to get them to even consider trying Lisp have been met with
staunch rejection. These peers are familiar with Haskell, and almost all know Agda,
so you'd think they'd be willing to try Lisp &#x2014;it's there, part of their editor&#x2014;
but the superficial chasm in terms of syntax and types is more than enough apparently.
In this article, I aim to explore the type system of (Emacs) Lisp and occasionally
make comparisons to Haskell. Perhaps in the end some of my Haskell peers would be
willing to try it out.
</p>


<figure>
<img src="https://imgs.xkcd.com/comics/lisp_cycles.png" alt="lisp_cycles.png">

<figcaption><span class="figure-number">Figure 1: </span>xkcd - Lisp is a language of timeless elegance</figcaption>
</figure>

<ul class="org-ul">
<li><p>
↯ I almost never use Haskell for any day-to-day dealings.
</p>

<p>
✓ The ideas expressed by its community are why I try
       to keep updated on the language.
</p></li>

<li><p>
↯ No one around me knows anything about Lisp,
but they dislike it due to the parens.
</p>

<p>
✓ I love it and use it for Emacs configuration and recently
       to prototype my PhD research.
</p></li>
<li>⇅ I love that I can express a complicated procedure compactly in both
by using zips, unzips, filters, and maps <code>(งಠ_ಠ)ง</code>
<ul class="org-ul">
<li><p>
Lately, in Lisp, I'll write a nested loop (gasp!)
then, for fun, try to make it a one-liner!
Sometimes, I actually think the loop formulation is clearer
and I leave it as a loop &#x2014;Breaking news: Two Haskell readers just died.
</p>


<figure>
<img src="https://i.stack.imgur.com/jvSOG.png" alt="jvSOG.png">

<figcaption><span class="figure-number">Figure 2: </span>From the awesome “Land of Lisp” book</figcaption>
</figure></li>
</ul></li>
</ul>

<ul class="org-ul">
<li><p>
<b>What I like and why:</b>
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Haskell</td>
<td class="org-left">⇒</td>
<td class="org-left">Executable category theory; compact &amp; eloquent</td>
</tr>

<tr>
<td class="org-left">Lisp</td>
<td class="org-left">⇒</td>
<td class="org-left">Extensible language; malleable, uniform, beautiful</td>
</tr>
</tbody>
</table></li>

<li><p>
<b>Documentation?</b>
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Haskell</td>
<td class="org-left">⇒</td>
<td class="org-left">Hoogle; can search by type alone!</td>
</tr>

<tr>
<td class="org-left">Emacs Lisp</td>
<td class="org-left">⇒</td>
<td class="org-left">Self-documenting; <code>M-x apropos</code></td>
</tr>
</tbody>
</table></li>

<li><p>
<b>How has using the language affected me?</b>
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Haskell</td>
<td class="org-left">I almost always think in-terms compoistionality, functors, &amp; currying</td>
</tr>

<tr>
<td class="org-left">Lisp</td>
<td class="org-left">Documentation strings, units tests, and metaprogramming are second nature</td>
</tr>
</tbody>
</table></li>
</ul>

<p>
It may not be entirely accurate to say that
Lisp's type system is more expressive than Haskell's
as it's orthogonal in many respects; although it is closer to that of <a href="https://liquid.kosmikus.org/01-intro.html#/what-is-liquid-haskell">Liquid Haskell</a>.
</p>
</div>
</div>

<div id="outline-container-orgddd44ee" class="outline-2">
<h2 id="terse-types-tutorial"><a href="#terse-types-tutorial">Why Bother with Types? A Terse Tutorial on Type Systems</a></h2>
<div class="outline-text-2" id="text-terse-types-tutorial">
<p>
<i>Types allow us to treat objects according a similar structure
or interface.</i>
Unlike Haskell and other statically typed systems, in Lisp we have
that types can overlap.
As such, here's our working definition.
</p>
<div class="org-center">
<p>
A <b>type</b> is a collection of possible objects.
</p>

<p>
To say “\(e\) has type \(τ\)” one writes \(e : τ\), or in Lisp: <code>(typep e 'τ)</code>.
</p>
</div>

<p>
Haskellers and others may append to this definition the following,
which we will not bother with:
<i>Type membership is determined by inspecting
syntactic structure and so is decidable.</i>
</p>

<blockquote>
<p>
✓ Typing is one of the simplest forms of “assertion-comments”:
Documenting a property of your code in a way that the machine can verify.
</p>

<p>
If you're gonna comment on what kind of thing you're working with, why not have the
comment checked by the machine.
</p>
</blockquote>

<table>
<caption class="t-above"><span class="table-number">Table 1:</span> Lisp's type hierarchy is a “complemented lattice” ♥‿♥</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Common types</td>
<td class="org-left"><code>integer, number, string, keyword, array, cons, list, vector, macro, function, atom</code></td>
</tr>

<tr>
<td class="org-left">Top</td>
<td class="org-left"><code>t</code> has everything as an element</td>
</tr>

<tr>
<td class="org-left">Unit</td>
<td class="org-left"><code>null</code> has one element named <code>nil</code></td>
</tr>

<tr>
<td class="org-left">Bottom</td>
<td class="org-left"><code>nil</code> has no elements at all</td>
</tr>

<tr>
<td class="org-left">Union</td>
<td class="org-left"><code>(or τ₀ τ₁ … τₙ)</code>  has elements any element in any type <code>τᵢ</code></td>
</tr>

<tr>
<td class="org-left">Intersection</td>
<td class="org-left"><code>(and τ₀ τ₁ … τₙ)</code> has elements that are in all the types <code>τᵢ</code></td>
</tr>

<tr>
<td class="org-left">Complement</td>
<td class="org-left"><code>(not τ)</code> has elements that are <i>not</i> of type <code>τ</code></td>
</tr>

<tr>
<td class="org-left">Enumeration</td>
<td class="org-left"><code>(member x₀ … xₙ)</code> is the type consisting of only the elements <code>xᵢ</code></td>
</tr>

<tr>
<td class="org-left">Singleton</td>
<td class="org-left"><code>(eql x)</code> is the type with only the element <code>x</code></td>
</tr>

<tr>
<td class="org-left">Comprehension</td>
<td class="org-left"><code>(satisfies p)</code> is the type of values that satisfy predicate <code>p</code></td>
</tr>
</tbody>
</table>

<p>
Let's see some examples:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">The universal type &#8220;t&#8221;, has everything as its value.</span>
(<span style="color: #b58900;">typep</span> 'x '<span style="color: #268bd2;">t</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> 12 '<span style="color: #268bd2;">t</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">The empty type: nil</span>
(<span style="color: #b58900;">typep</span> 'x 'nil) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false; nil has no values.</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">The type &#8220;null&#8221; contains the one value &#8220;nil&#8221;.</span>
(<span style="color: #b58900;">typep</span> nil '<span style="color: #b58900;">null</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> () '<span style="color: #b58900;">null</span>)  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8220;(eql x)&#8221; is the singelton type consisting of only x.</span>
(<span style="color: #b58900;">typep</span> 3 '(<span style="color: #b58900;">eql</span> 3)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> 4 '(<span style="color: #b58900;">eql</span> 3)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8220;(member x&#8320; &#8230; x&#8345;)&#8221; denotes the enumerated type consisting of only the x&#7522;.</span>
(<span style="color: #b58900;">typep</span> 3 '(<span style="color: #b58900;">member</span> 3 x <span style="color: #2aa198;">"c"</span>))  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> 'x '(<span style="color: #b58900;">member</span> 3 x <span style="color: #2aa198;">"c"</span>)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> 'y '(<span style="color: #b58900;">member</span> 3 x <span style="color: #2aa198;">"c"</span>)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8220;(satisfies p)&#8221; is the type of values that satisfy predicate p.</span>
(<span style="color: #b58900;">typep</span> 12 '(satisfies (<span style="color: #859900; font-weight: bold;">lambda</span> (x) (<span style="color: #b58900;">oddp</span> x)))) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
(<span style="color: #b58900;">typep</span> 12 '(satisfies <span style="color: #b58900;">evenp</span>) )                <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Computation rule for comprehension types.</span>
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">(typep x '(satisfies p)) &#8776; (if (p x) t nil)</span>
</pre>
</div>

<p>
Here's a convenient one: <code>(booleanp x) ≈ (typep x '(member t nil))</code>.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">booleanp</span> 2)   <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
(<span style="color: #b58900;">booleanp</span> nil) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
</pre>
</div>

<p>
Strongly typed languages like Haskell allow only a number of the type formers listed
above. For example, Haskell does not allow unions but instead offers so-called sum
types. Moreover, unlike Haskell, Lisp is non-parametric:
We may pick a branch of computation according to the type of a value.
Such case analysis is available in languages such as C# &#x2014;c.f.,
<a href="https://blogs.msdn.microsoft.com/ericlippert/2010/09/16/is-is-as-or-is-as-is/">is is as or is as is</a>. Finally, it is important to realise that <code>cons</code> is a monomorphic
type
&#x2014;it just means an (arbitrary) element consisting of two parts called <code>car</code> and <code>cdr</code>&#x2014;
we show how to form a <a href="#org47d3d0a">polymorphic</a> product type below.
</p>

<p>
We may ask for <i>the</i> ‘primitive type’ of an object;
which is the simplest built-in type that it belongs to,
such as integer, string, cons, symbol, record, subr, and a few others.
As such, <i>Lisp objects come with an intrinsic primitive type</i>;
e.g., <code>'(1 "2" 'three)</code> is a list and can only be treated as a value of
another type if an explicit coercion is used.
In Lisp, rather than variables, it is values that are associated with a type.
One may optionally declare the types of variables, like in OCaml.
</p>
<div class="org-center">
<p>
<i>Lisp (primitive) types are inferred!</i>
</p>

<p>
“Values have types, not variables.” &#x2014;Paul Graham, ANSI Common Lisp
</p>
</div>

<p>
Let's review some important features of type systems and how they manifest themselves
in Lisp.
</p>
</div>

<div id="outline-container-org6fff291" class="outline-3">
<h3 id="type-checking"><a href="#type-checking">Obtaining &amp; Checking Types</a></h3>
<div class="outline-text-3" id="text-type-checking">
<p>
The typing relationship “:” is usually deterministic in its second argument for
static languages: <code>e : τ  ∧  e : τ′  ⇒  τ ≈ τ′</code>. However this is not the case with
Lisp's <code>typep</code>.
</p>

<table>
<caption class="t-above"><span class="table-number">Table 2:</span> Where are the types &amp; <i>when</i> are they checked?</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Style</th>
<th scope="col" class="org-left">Definition</th>
<th scope="col" class="org-left">Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Static</td>
<td class="org-left">Variables have a fixed type; compile time</td>
<td class="org-left">Haskell &amp; C#</td>
</tr>

<tr>
<td class="org-left">Dynamic</td>
<td class="org-left">Values have a fixed type; runtime</td>
<td class="org-left">Lisp &amp; Smalltalk</td>
</tr>
</tbody>
</table>

<p>
In some sense, dynamic languages make it easy to produce <a href="#org47d3d0a">polymorphic</a> functions.
Ironically, the previous sentences is only meaningful if you acknowledge the importance
of types and type variables.
</p>

<p>
In Lisp, types are inferred and needn't be declared.
However, the declaration serves as a nice documentation to further readers ;-)
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">setq</span> ellew 314)
(<span style="color: #b58900;">type-of</span> ellew) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; integer</span>

(<span style="color: #859900; font-weight: bold;">setq</span> ellew <span style="color: #2aa198;">"oh my"</span>)
(<span style="color: #b58900;">type-of</span> ellew) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; string</span>
</pre>
</div>
<ul class="org-ul">
<li>The <code>type-of</code> function returns the type of a given object.</li>
<li>Re variables: Static ⇒ only values can change; dynamic ⇒ both values and types change.</li>
</ul>

<p>
We may check the type of an item using <code>typep</code>, whose second argument
is a “type specifiers”
 &#x2014;an expressions whose value denotes a type; e.g., the <code>or</code> expression below
 forms a ‘union type’.
</p>

<p>
There's also <code>check-type</code>: It's like <code>typep</code> but instead of yielding true or
false, it stays quiet in the former and signals a type error in the latter.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">check-type</span> 12 integer)               <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil, i.e., no error</span>
(<span style="color: #859900; font-weight: bold;">check-type</span> 12   (<span style="color: #859900; font-weight: bold;">or</span> symbol integer)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">nil; i.e., no error</span>
(<span style="color: #859900; font-weight: bold;">check-type</span> <span style="color: #2aa198;">"12"</span> (<span style="color: #859900; font-weight: bold;">or</span> symbol integer)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Crash: Type error!</span>
</pre>
</div>

<p>
In summary:
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>(equal τ (type-of e))</code></td>
<td class="org-left"><code>≈</code></td>
<td class="org-left"><code>(typep e τ)</code></td>
</tr>

<tr>
<td class="org-left"><code>(check-type e τ)</code></td>
<td class="org-left"><code>≈</code></td>
<td class="org-left"><code>(unless (typep e 'τ) (error "⋯"))</code></td>
</tr>
</tbody>
</table>

<p>
( Note: (<code>unless x y) ≈ (when (not x) y)</code> .)
</p>
</div>
</div>
<div id="outline-container-org3063a33" class="outline-3">
<h3 id="lisp-is-eval"><a href="#lisp-is-eval">Statics &amp; Dynamics of Lisp</a></h3>
<div class="outline-text-3" id="text-lisp-is-eval">
<blockquote>
<p>
Types are the central organising principle of the theory of programming languages.
Language features are manifestations of type structure.
The syntax of a language is governed by the constructs that define its types, and
its semantics is determined by the interactions among those constructs.
</p>

<p>
&#x2014; Robert Harper, Practical Foundations for Programming Languages
</p>
</blockquote>

<p>
Besides atoms like numbers and strings,
the only way to form new terms in Lisp is using “modus ponens”,
or “function application”. Here's a first approximation:
</p>
<div class="org-src-container">
<pre class="src src-math">f : τ₁ → ⋯ → τₙ → τ   e₁ : τ₁  …  eₙ : τₙ
-----------------------------------------------------------------------------------------
           (f e₁ … eₙ) : τ
</pre>
</div>
<p>
One reads such a fraction as follows: If each part of the numerator &#x2014;the ‘hypothesises’&#x2014; is true, then so is the denominator &#x2014;the ‘conclusion’.
</p>

<p>
An <i>abstract syntax tree</i>, or ‘AST’, is a tree with operators for branches
and arguments for children. A tree is of kind τ if the topmost branching operator has τ as its resulting type. Here's an improved rule:
</p>
<div class="org-src-container">
<pre class="src src-math">f : τ₁ → ⋯ → τₙ → τ   e₁ : AST τ₁  …  eₙ : AST τₙ
-----------------------------------------------------------------------------------------
              (f e₁ … eₙ) : AST τ
</pre>
</div>

<p>
A Lisp top-level then may execute or interpret such a form to obtain a value:
When we write <code>e</code> at a top-level, it is essentially <code>(eval e)</code> that is invoked.
</p>
<div class="org-src-container">
<pre class="src src-math">   e : AST τ
-----------------------------------------------------------------------------------------
  (eval e) : τ
</pre>
</div>

<p>
However, we may also protect against evaluation.
</p>
<div class="org-src-container">
<pre class="src src-math">     e : AST τ
-----------------------------------------------------------------------------------------
  (quote e) : AST τ
</pre>
</div>

<p>
We have the following execution rules, where ‘⟿’ denotes “reduces to”.
</p>
<div class="org-src-container">
<pre class="src src-math">(eval a)         ⟿ a                        ;; for atom ‘a’
(eval (quote e))   ⟿ e
(eval (f e₁ … eₙ)) ⟿ (f (eval e₁) ⋯ (eval eₙ)) ;; Actually invoke ‘f’
</pre>
</div>

<div class="org-center">
<p>
<i>A conceptual model of Lisp is <code>eval</code>.</i>
</p>
</div>
</div>
</div>

<div id="outline-container-orgf1d8860" class="outline-3">
<h3 id="lisp-is-dynamic"><a href="#lisp-is-dynamic">Variable Scope</a></h3>
<div class="outline-text-3" id="text-lisp-is-dynamic">
<p>
There's also the matter of “scope”, or ‘life time’, of a variable.
</p>

<table>
<caption class="t-above"><span class="table-number">Table 3:</span> Local variables temporarily mask global names …</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Style</th>
<th scope="col" class="org-left">Definition</th>
<th scope="col" class="org-left">Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Lexical</td>
<td class="org-left">… only in visible code</td>
<td class="org-left">Nearly every language!</td>
</tr>

<tr>
<td class="org-left">Dynamic</td>
<td class="org-left">… every place imaginable</td>
<td class="org-left">Bash, Perl, &amp; allowable in some Lisps</td>
</tr>
</tbody>
</table>

<p>
That is, dynamic scope means a local variable not only acts as a global variable
for the rest of the scope but it does so even in the definitions of pre-defined methods
being invoked in the scope.
</p>
<div class="org-src-container">
<pre class="src src-elisp">(<span style="color: #859900; font-weight: bold;">setq</span> it <span style="color: #2aa198;">"bye"</span>)
(<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">go</span> () it)
(<span style="color: #859900; font-weight: bold;">let</span> ((it 3)) (<span style="color: #b58900;">go</span>)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 3; even though &#8220;it&#8221; does not occur textually!</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Temporarily enable lexical binding in Emacs Lisp</span>
(<span style="color: #859900; font-weight: bold;">setq</span> <span style="color: #268bd2;">lexical-binding</span> <span style="color: #268bd2;">t</span>)
(<span style="color: #859900; font-weight: bold;">let</span> ((it 3)) (<span style="color: #b58900;">go</span>)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; bye; as most languages would act</span>
</pre>
</div>

<div class="org-center">
<p>
<i>Dynamic scope lets bindings leak down into all constituents in its wake.</i>
</p>
</div>

<p>
That is fantastic when we want to do <a href="https://nullprogram.com/blog/2012/08/15/">unit tests</a> involving utilities with side-effects:
We simply locally re-define the side-effect component to, say, do nothing. (─‿‿─)
</p>
</div>
</div>

<div id="outline-container-org27b07c8" class="outline-3">
<h3 id="lisp-is-strong"><a href="#lisp-is-strong">Casts &amp; Coercions</a></h3>
<div class="outline-text-3" id="text-lisp-is-strong">
<table>
<caption class="t-above"><span class="table-number">Table 4:</span> The frequency of implicit type coercions</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Style</th>
<th scope="col" class="org-left">Definition</th>
<th scope="col" class="org-left">Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Strong</td>
<td class="org-left">Almost never</td>
<td class="org-left">Lisp &amp; Haskell</td>
</tr>

<tr>
<td class="org-left">Weak</td>
<td class="org-left">Try as best as possible</td>
<td class="org-left">JavaScript &amp; C</td>
</tr>
</tbody>
</table>

<p>
<i>Strong systems will not accidentally coerce terms.</i>
</p>

<p>
Lisp has a <a href="http://www.lispworks.com/documentation/lw51/CLHS/Body/f_coerce.htm#coerce">coerce</a> form; but coercion semantics is generally unsound
in any language and so should be used with tremendous caution.
( Though Haskell has some sensible coercions as well as unsafe one. )
</p>
<div class="org-src-container">
<pre class="src src-math">     e : α
----------------------------------------------------------------------------------------
(coerce e β) : β
</pre>
</div>
<p>
We have a magical way to turn elements of type α to elements of type β.
Some languages call this <i>type casting</i>.
</p>

<p>
Here's a cute example.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">coerce</span> '(76 105 115 112) '<span style="color: #b58900;">string</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; Lisp</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org37aac7e" class="outline-3">
<h3 id="type-annotations"><a href="#type-annotations">Type Annotations</a></h3>
<div class="outline-text-3" id="text-type-annotations">
<p>
We may perform type annotations using the form <code>the</code>; e.g.,
the Haskell expression <code>(1 :: Int) + 2</code> checks the type annotation,
and, if it passes, yields the value and the expression is computed.
Likewise, <code>(the type name)</code> yields <code>name</code> provided it has type <code>type</code>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">+</span> (<span style="color: #859900; font-weight: bold;">the</span> integer 1)
   (<span style="color: #859900; font-weight: bold;">the</span> integer 2)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 3</span>

(<span style="color: #b58900;">+</span> (<span style="color: #859900; font-weight: bold;">the</span> integer 1)
   (<span style="color: #859900; font-weight: bold;">the</span> integer <span style="color: #2aa198;">"2"</span>)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; Type error.</span>
</pre>
</div>

<p>
Computationally, using <code>or</code> as a control structure for lazy sequencing with left-unit <code>nil</code>:
</p>
<table>


<colgroup>
<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>(the τ e) ≈ (or (check-type e τ) e)</code></td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org2fd4b43" class="outline-3">
<h3 id="typecase"><a href="#typecase">Type-directed Computations</a></h3>
<div class="outline-text-3" id="text-typecase">
<p>
Sometimes a value can be one of several types.
This is specified using union types; nested unions are essentially flattened
&#x2014;which is a property of ‘or’, as we shall come to see.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">typep</span> 12 'integer)  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
(<span style="color: #b58900;">typep</span> 'a 'symbol)   <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>

(<span style="color: #859900; font-weight: bold;">setq</span> woah 12)
(<span style="color: #b58900;">typep</span> woah '(<span style="color: #859900; font-weight: bold;">or</span> integer symbol)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>

(<span style="color: #859900; font-weight: bold;">setq</span> woah 'nice)
(<span style="color: #b58900;">typep</span> woah '(<span style="color: #859900; font-weight: bold;">or</span> integer symbol)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
</pre>
</div>

<p>
When given a union type, we may want to <i>compute according to the type of a value.</i>
</p>
<ul class="org-ul">
<li>Case along the possible types using <code>typecase</code>.</li>
<li>This returns a <code>nil</code> when no case fits; use <code>etypecase</code> to have an error instead of <code>nil</code>.</li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">typecase</span> woah
  (integer  (+1 woah))
  (symbol  'cool)
  (<span style="color: #268bd2;">t</span>       <span style="color: #2aa198;">"yikes"</span>))
</pre>
</div>
</div>
</div>

<div id="outline-container-org0d9dc55" class="outline-3">
<h3 id="type-specifiers"><a href="#type-specifiers">Type Specifiers: On the nature of types in Lisp</a></h3>
<div class="outline-text-3" id="text-type-specifiers">
<blockquote>
<p>
Types are not objects in Common Lisp. There is no object that corresponds to the type
<code>integer</code>, for example. What we get from a function like <code>type-of</code>, and give as an argument
to a function like <code>typep</code>, is not a type, but a type specifier.
A type specifier is the name of a type. &#x2014;Paul Graham, ANSI Common Lisp
</p>
</blockquote>

<p>
Type specifiers are essentially transformed into predicates as follows.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">typep</span> x '&#964;)                &#8776; (&#964;p x)  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">E.g., &#964; &#8776; integer</span>
(<span style="color: #b58900;">typep</span> x '(<span style="color: #859900; font-weight: bold;">and</span> &#964;&#8321; &#8230; &#964;&#8345;))    &#8776; (<span style="color: #859900; font-weight: bold;">and</span> (<span style="color: #b58900;">typep</span> x &#964;&#8321;) &#8230; (<span style="color: #b58900;">typep</span> x &#964;&#8345;))
(<span style="color: #b58900;">typep</span> x '(<span style="color: #859900; font-weight: bold;">or</span> &#964;&#8321; &#8230; &#964;&#8345;))     &#8776; (<span style="color: #859900; font-weight: bold;">or</span> (<span style="color: #b58900;">typep</span> x &#964;&#8321;) &#8230; (<span style="color: #b58900;">typep</span> x &#964;&#8345;))
(<span style="color: #b58900;">typep</span> x '(<span style="color: #b58900;">not</span> &#964;))          &#8776; (<span style="color: #b58900;">not</span> (<span style="color: #b58900;">typep</span> x &#964;))
(<span style="color: #b58900;">typep</span> x '(<span style="color: #b58900;">member</span> e&#8321; &#8230; e&#8345;)) &#8776; (<span style="color: #859900; font-weight: bold;">or</span> (<span style="color: #b58900;">eql</span> x e&#8321;) &#8230; (<span style="color: #b58900;">eql</span> x e&#8345;))
(<span style="color: #b58900;">typep</span> x '(satisfies p))    &#8776; (p x)
</pre>
</div>

<p>
Type specifiers are thus essentially ‘characteristic functions’ from mathematics.
</p>
</div>
</div>

<div id="outline-container-org55b8f15" class="outline-3">
<h3 id="deftype"><a href="#deftype">Making New Types with <code>deftype</code></a></h3>
<div class="outline-text-3" id="text-deftype">
<p>
If we use a type specifier often, we may wish to abbreviate it using
the <a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#index-cl_002ddeftype-14">deftype</a> macro &#x2014;it is like <code>defmacro</code> but expands into a type specifier
instead of an expression.
</p>

<p>
We can define new types that will then work with <code>typecase</code> and friends
as follows:
</p>
<ol class="org-ol">
<li>Define a predicate <code>my-type-p</code>.</li>
<li>Test it out to ensure only the elements you want satisfy it.</li>
<li><p>
Register it using <a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#index-cl_002ddeftype-14">deftype</a>.
</p>

<p>
You could just do number 3 directly, but it's useful to have the
predicate form of a <a href="#org0c7dfd1">type descriptor</a>.
</p></li>
</ol>

<p>
<a href="https://lispcookbook.github.io/cl-cookbook/type.html">For example,</a> here's the three steps for a type of lists of numbers drawn from <code>(-∞..9]</code>.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Make the predicate</span>
(<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">small-number-seq-p</span> (thing)
  (<span style="color: #859900; font-weight: bold;">and</span> (<span style="color: #b58900;">sequencep</span> thing)
       (<span style="color: #b58900;">every</span> #'<span style="color: #b58900;">numberp</span> thing)
       (<span style="color: #b58900;">every</span> (<span style="color: #859900; font-weight: bold;">lambda</span> (x) (<span style="color: #b58900;">&lt;</span> x 10)) thing)))

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Test it</span>
(<span style="color: #859900; font-weight: bold;">setq</span> yes '(1 2  4))
(<span style="color: #859900; font-weight: bold;">setq</span> no  '(1 20 4))
(small-number-seq-p yes) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Register it</span>
(<span style="color: #859900; font-weight: bold;">deftype</span> small-number-seq ()
  '(satisfies small-number-seq-p))

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Use it</span>
(<span style="color: #b58900;">typep</span> yes 'small-number-seq) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> no 'small-number-seq)  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
</pre>
</div>

<p>
Arguments are processed the same as for <code>defmacro</code> except that optional
arguments without explicit defaults use <code>*</code> instead of <code>nil</code> as the default value.
<a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#index-cl_002ddeftype-14">From the deftype docs, here are some examples:</a>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">cl-deftype</span> <span style="color: #b58900; font-style: italic;">null</span> () '(satisfies <span style="color: #b58900;">null</span>))    <span style="color: #96A7A9; font-style: italic;">; </span><span style="color: #96A7A9; font-style: italic;">predefined</span>
(<span style="color: #859900; font-weight: bold;">cl-deftype</span> <span style="color: #b58900; font-style: italic;">list</span> () '(<span style="color: #859900; font-weight: bold;">or</span> <span style="color: #b58900;">null</span> <span style="color: #b58900;">cons</span>))      <span style="color: #96A7A9; font-style: italic;">; </span><span style="color: #96A7A9; font-style: italic;">predefined</span>

(<span style="color: #859900; font-weight: bold;">cl-deftype</span> <span style="color: #b58900; font-style: italic;">unsigned-byte</span> (<span style="color: #b58900; font-style: italic;">&amp;optional</span> bits)
  (<span style="color: #b58900;">list</span> 'integer 0 (<span style="color: #859900; font-weight: bold;">if</span> (<span style="color: #b58900;">eq</span> bits '<span style="color: #b58900;">*</span>) bits (<span style="color: #b58900;">1-</span> (<span style="color: #b58900;">lsh</span> 1 bits)))))

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Some equivalences</span>
(unsigned-byte 8)  &#8801;  (integer 0 255)
(unsigned-byte)    &#8801;  (integer 0 <span style="color: #b58900;">*</span>)
unsigned-byte      &#8801;  (integer 0 <span style="color: #b58900;">*</span>)
</pre>
</div>

<ul class="org-ul">
<li>Notice that type specifiers essentially live in their own namespace; e.g., <code>null</code> is the
predicate that checks if a list is empty yet <code>null</code> is the type specifying such lists.</li>
</ul>

<p>
Let's form a type of pairs directly &#x2014;which is not ideal!
This is a <a id="org47d3d0a">polymorphic</a> datatype: It takes two type arguments, called <code>a</code> and <code>b</code> below.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">deftype</span> pair (a b <span style="color: #b58900; font-style: italic;">&amp;optional</span> type)
  `(satisfies (<span style="color: #859900; font-weight: bold;">lambda</span> (x) (<span style="color: #859900; font-weight: bold;">and</span>
      (<span style="color: #b58900;">consp</span> x)
      (<span style="color: #b58900;">typep</span> (<span style="color: #b58900;">car</span> x) (<span style="color: #859900; font-weight: bold;">quote</span> ,a))
      (<span style="color: #b58900;">typep</span> (<span style="color: #b58900;">cdr</span> x) (<span style="color: #859900; font-weight: bold;">quote</span> ,b))))))

(<span style="color: #b58900;">typep</span> '(<span style="color: #2aa198;">"x"</span> . 2) '(pair <span style="color: #b58900;">string</span> integer)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> '(<span style="color: #2aa198;">"x"</span> . 2) '(pair symbol integer)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
(<span style="color: #b58900;">typep</span> nil '(pair integer integer))       <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
(<span style="color: #b58900;">typep</span> 23 '(pair integer integer))        <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>

(<span style="color: #859900; font-weight: bold;">setq</span> ss <span style="color: #2aa198;">"nice"</span> nn 114)
(<span style="color: #b58900;">typep</span> `(,ss . ,nn) '(pair <span style="color: #b58900;">string</span> integer)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> (<span style="color: #b58900;">cons</span> ss nn) '(pair <span style="color: #b58900;">string</span> integer)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">The following are false since ss and nn are quoted symbols!</span>
(<span style="color: #b58900;">typep</span> '(ss . nn)    '(pair <span style="color: #b58900;">string</span> integer)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
(<span style="color: #b58900;">typep</span> `(<span style="color: #b58900;">cons</span> ss nn) '(pair <span style="color: #b58900;">string</span> integer)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
</pre>
</div>

<p>
<b>Exercise:</b> Define the <a href="#org47d3d0a">polymorphic</a> <code>maybe</code> type
such that <code>(maybe τ)</code> has elements being either <code>nil</code> or a value of <code>τ</code>.
</p>
<p>
Let's define type <code>list-of</code> such that <code>(list-of τ)</code> is the type of lists
whose elements are all values of type <code>τ</code>.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Make the predicate</span>
(<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">list-of-p</span> (&#964; thing)
  (<span style="color: #859900; font-weight: bold;">and</span> (<span style="color: #b58900;">listp</span> thing) (<span style="color: #b58900;">every</span> (<span style="color: #859900; font-weight: bold;">lambda</span> (x) (<span style="color: #b58900;">typep</span> x &#964;)) thing)))

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Test it</span>
(list-of-p 'integer '(1 2   3)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(list-of-p 'integer '(1 two 3)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
(list-of-p '<span style="color: #b58900;">string</span> '())         <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(list-of-p '<span style="color: #b58900;">string</span> '(no))       <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Register it</span>
(<span style="color: #859900; font-weight: bold;">deftype</span> list-of (&#964;)
  `(satisfies (<span style="color: #859900; font-weight: bold;">lambda</span> (thing) (list-of-p (<span style="color: #859900; font-weight: bold;">quote</span> ,&#964;) thing))))

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Use it</span>

(<span style="color: #b58900;">typep</span> '(1 2  ) '<span style="color: #b58900;">list</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> '(1 two) '<span style="color: #b58900;">list</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>

(<span style="color: #b58900;">typep</span> '(1 2)   '(list-of integer)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> '(1 <span style="color: #2aa198;">"2"</span>) '(list-of <span style="color: #b58900;">string</span>))  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
(<span style="color: #b58900;">typep</span> '(1 <span style="color: #2aa198;">"2"</span>) '(list-of (<span style="color: #859900; font-weight: bold;">or</span> integer <span style="color: #b58900;">string</span>)))  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
</pre>
</div>

<p>
Notice that by the last example we can <b>control the degree of heterogeneity</b> in our lists!
So cool!
</p>

<p>
Here's some more exercises. The first should be nearly trivial, the second a bit more
work, and the last two have made me #sad.
</p>

<ol class="org-ol">
<li>Define a type <code>(rose τ)</code> whose elements are either τ values or rose trees of type τ.</li>

<li>Define a type <code>record</code> so that <code>(record τ₁ … τₙ)</code> denotes a record type whose iᵗʰ
component has type <code>τᵢ</code>.</li>

<li><p>
Define a type constructor <code>∃</code> such that, for example, <code>(∃ τ (pair integer τ)</code>
denotes the type of pairs where the first components are integers and the second
components all have the same type <code>τ</code>, but we do not know which one.
</p>

<p>
My idea was to let <code>τ</code> denote the type of the first occurrence of a value
at that location, then all subsequent checks now refer to this value of <code>τ</code>.
</p>

<p>
Sadly, I could not define this type :'(
</p>

<p>
Upon further reading, this may be doable using a <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Watching-Variables.html#Watching-Variables">variable watcher</a>.
</p></li>

<li><p>
Produce a record for monoids and keep-track of the monoid instances produced.
Define a the predicate <code>(monoid τ)</code> to check if any of the monoid instances
has <code>τ</code> as its carrier type. In this way we could simulate Haskell typeclasses.
</p></li>
</ol>

<p>
Let me know if you do cool things!
</p>
</div>
</div>
<div id="outline-container-org646dad0" class="outline-3">
<h3 id="adts"><a href="#adts">Algebraic Data Types a la Haskell</a></h3>
<div class="outline-text-3" id="text-adts">
<p>
Consider the Haskell expression type, example, and integer evaluator.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">data</span> <span style="color: #b58900; font-style: italic;">Expr</span> a <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Var</span> a <span style="color: #268bd2;">|</span> <span style="color: #b58900; font-style: italic;">Expr</span> a <span style="color: #b58900; font-style: italic;">:+:</span> <span style="color: #b58900; font-style: italic;">Expr</span> a <span style="color: #268bd2;">|</span> <span style="color: #b58900; font-style: italic;">Neg</span> (<span style="color: #b58900; font-style: italic;">Expr</span> a) <span style="color: #859900; font-weight: bold;">deriving</span> <span style="color: #b58900; font-style: italic;">Show</span>

<span style="color: #b58900;">ex</span> <span style="color: #268bd2;">::</span> <span style="color: #b58900; font-style: italic;">Expr</span> <span style="color: #b58900; font-style: italic;">Int</span>
<span style="color: #b58900;">ex</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Var</span> 5 <span style="color: #b58900; font-style: italic;">:+:</span> (<span style="color: #b58900; font-style: italic;">Var</span> 6 <span style="color: #b58900; font-style: italic;">:+:</span> <span style="color: #b58900; font-style: italic;">Neg</span> (<span style="color: #b58900; font-style: italic;">Var</span> 7))

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">::</span> <span style="color: #b58900; font-style: italic;">Expr</span> <span style="color: #b58900; font-style: italic;">Int</span> <span style="color: #268bd2;">-&gt;</span> <span style="color: #b58900; font-style: italic;">Int</span>
<span style="color: #b58900;">int</span> (<span style="color: #b58900; font-style: italic;">Var</span> n)    <span style="color: #268bd2;">=</span> n
<span style="color: #b58900;">int</span> (l <span style="color: #b58900; font-style: italic;">:+:</span> r)  <span style="color: #268bd2;">=</span> int l <span style="color: #268bd2;">+</span> int r
<span style="color: #b58900;">int</span> (<span style="color: #b58900; font-style: italic;">Neg</span> e)    <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">-</span> (int e)

<span style="color: #96A7A9; font-style: italic;">{- </span><span style="color: #96A7A9; font-style: italic;">int ex &#8658; 4 -}</span>
</pre>
</div>

<p>
If we view a constructor declaration <code>C a₁ … aₙ</code> with superfluous parenthesis
as <code>(C a₁ … aₙ)</code>, then a translation to Lisp immediately suggests itself:
</p>
<div class="org-center">
<p>
<i>Haskell constructors ≅ Lisp lists whose <code>car</code> are constructor names</i>
</p>
</div>

<p>
A nearly direct translation follows.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">exprp</span> (&#964; thing)
    (pcase thing
       (`(var ,n)    (typep n &#964;))
       (`(add ,l ,r) (and (exprp &#964; l) (exprp &#964; r)))
       (`(neg ,e)    (exprp &#964; e))))

(setq ex '(add (var 5) (add (var 6) (neg (var 7)))))
(exprp 'integer ex) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>

<span style="color: #96A7A9; font-style: italic;">; </span><span style="color: #96A7A9; font-style: italic;">This declarion &#8220;declare-type&#8221; is defined near the end of this article.</span>
(declare-type int : (expr-of integer) integer)
(<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">int</span> (thing)
    (pcase thing
       (`(var ,n)    n)
       (`(add ,l ,r) (+ (int l) (int r)))
       (`(neg ,e)    (- (int e)))))

(int ex) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 4</span>
</pre>
</div>

<p>
There are of-course much better ways to do this in Lisp; e.g.,
use <code>identity, +, -</code> in-place of the <code>var, add, neg</code> tags
to produce “syntax that carries its semantics”
or express the interpreter <code>int</code> as a one liner
by replacing the formal tags with their interpretations then
invoking Lisps <code>eval</code>. I doubt either of these are new ideas,
but the merit of the former seems neat &#x2014;at a first glance, at least.
</p>

<p>
Support for ADTs in Common Lisp along with seemingly less clunky pattern matching
can be found <a href="https://github.com/stylewarning/cl-algebraic-data-type">here</a> &#x2014;which I have only briefly looked at.
</p>

<p>
The Haskell presentation has type-checking baked into it, yet our
Lisp interpreter <code>int</code> does not! This seems terribly worrying, but
that <a href="#org7d207a3"><code>declare-type</code></a> declaration actually handles type checking for us!
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Register the type</span>
(<span style="color: #859900; font-weight: bold;">deftype</span> <span style="color: #b58900; font-style: italic;">expr-of</span> (&#964;)
  `(satisfies (<span style="color: #859900; font-weight: bold;">lambda</span> (thing) (exprp (quote ,&#964;) thing))))

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Try it out</span>
(typep '(1 2)   '(expr-of integer)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil</span>
(typep ex   '(expr-of integer))     <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">This invocation, for example, now yields a helpful error message.</span>
(int '(var 6 4))
<span style="color: #96A7A9; font-style: italic;">;;</span>
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; int: Type mismatch! Expected (expr-of integer) for argument 0 &#8800; Given cons (var 6 4).</span>
<span style="color: #96A7A9; font-style: italic;">;;</span>
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Which is reasonable since the &#8216;</span><span style="color: #6c71c4; font-weight: bold; font-style: italic;">var</span><span style="color: #96A7A9; font-style: italic;">&#8217; constructor only takes a single argument.</span>
</pre>
</div>
<p>
Notice that invalid cases yield a helpful (run-time) error message!
</p>
</div>
</div>
</div>

<div id="outline-container-orgefbcbac" class="outline-2">
<h2 id="why-dynamic"><a href="#why-dynamic">In Defence of Being Dynamically Checked</a></h2>
<div class="outline-text-2" id="text-why-dynamic">
<div class="org-center">
<p>
<i>Lisp gets a bad rap for being untyped; let's clarify this issue further!</i>
</p>
</div>

<p>
It is important to realise that nearly every language is typed &#x2014;albeit the checking
may happen at different stages&#x2014; and so, as <a href="http://www.cis.upenn.edu/~bcpierce/tapl/index.html">Benjamin Pierce</a> says:
<i>Terms like “dynamically typed” are arguably misnomers and should probably be replaced by “dynamically checked,” but the usage is standard.</i>
</p>

<p>
In particular, dynamically typed is <i>not</i> synonymous with untyped, though some people use
it that way since nearly <a href="https://www.williamjbowman.com/blog/2018/01/19/untyped-programs-don-t-exist/#related">every language is typed</a> &#x2014;possibly with a single anonymous
type.
</p>

<p>
Some people in the Haskell community, which I love, say things like
<i>“if it typechecks, ship it”</i> which is true more often than not, but it leads some
people to avoid producing unit tests. For example, the following type checks but
should be unit tested.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900;">mcbride</span> <span style="color: #268bd2;">::</span> [<span style="color: #b58900; font-style: italic;">Int</span>] <span style="color: #268bd2;">-&gt;</span> <span style="color: #b58900; font-style: italic;">Int</span>
<span style="color: #b58900;">mcbride</span> xs <span style="color: #268bd2;">=</span> <span style="color: #859900; font-weight: bold;">if</span> null xs <span style="color: #859900; font-weight: bold;">then</span> head xs <span style="color: #859900; font-weight: bold;">else</span> 666
</pre>
</div>

<p>
Regardless, I love static type checking and static analysis in general.
However, the shift to a dynamically checked setting has resulted in greater
interest in unit testing. For example, Haskell's solution to effectful computation
is delimited by types, as any Haskeller will proudly say (myself included);
but ask how are such computations unit tested and the room is
silent (myself included).
</p>

<p>
Interestingly some unit tests check the typing of inputs and output, which is
a mechanical process with no unknowns and so it should be possible to produce a syntax
for it using Lisp macros. This is one of the goals of this article and we'll return to
it later.
</p>

<p>
Even though I like Lisp, I'm not sure why dynamic typing is the way to go
&#x2014;c.f. <a href="https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/">Dynamic Languages are Static Languages</a> which mentions the unjust tyranny of
unityped systems.
Below are two reasons why people may dislike static types.
</p>

<p>
<b>First</b>: The de-facto typing rule do binary choice is usually:
</p>
<div class="org-src-container">
<pre class="src src-math">     T : 𝔹     E : α     B : α -----------------------------------------------------------------------------------------
     if T then E else B : α
</pre>
</div>

<p>
That means valid programs such as <code>if True then 1 else "two"</code> are rejected;
even though the resulting type will always be an integer there is no way to know
that statically &#x2014;the choice needs to be rewritten, evaluated at run time.
</p>

<p>
Indeed, in Haskell, we would write
<code>if True then Left 1 else Right "two"</code> which has type <code>Either Int String</code>,
and to use the resulting value means we need to pattern match or use
the eliminator <code>(|||</code>) &#x2014;from Haskell's <code>Control.Arrow</code>.
</p>

<p>
<b>Second:</b>
Some statically typed languages have super weak type systems and ruin the rep
for everyone else.
For example, <code>C</code> is great and we all love it of-course, but it's a shame that we can only
express the <a href="#org47d3d0a">polymorphic</a> identity function \(id : ∀{α}. α → α \;=\; λ x → x\),
by using the C-preprocessor &#x2014;or dismiss the types by casting pointers around.
</p>

<p>
Maybe this video is helpful, maybe not:
<a href="https://games.greggman.com/game/dynamic-typing-static-typing/">The Unreasonable Effectiveness of Dynamic Typing for Practical Programs</a>
</p>

<blockquote>
<p>
( For the algebraist: Dynamic typing is like working in a monoid whose
composition operation is partial and may abruptly crash; whereas static typing
is working in a category whose composition is proudly typed. )
</p>
</blockquote>

<p>
Overall I haven't presented a good defence for being dynamically checked, but you
should ignore my blunder and consider trying Lisp yourself to see how awesome it is.
</p>
</div>
</div>

<div id="outline-container-orgfa91f03" class="outline-2">
<h2 id="lisp-funny-history"><a href="#lisp-funny-history">With its hierarchy of types, why isn't Lisp statically typed?</a></h2>
<div class="outline-text-2" id="text-lisp-funny-history">
<div class="org-center">
<p>
<i>I haven't a clue. Here are two conjectures.</i>
</p>
</div>

<p>
<b>First</b>: Code that manipulates code is difficult to type.
</p>

<p>
Is the type of <code>'(+ x 2)</code> a numeric code expression?
Or just an arbitrary code expression? Am I allowed to “look inside”
to inspect its structure or is it a black box? What about the nature of
its constituents? If I'm allowed to look at them, can I ask if they're even defined?
</p>

<p>
What if <code>c</code> is a code element that introduces an identifier, say <code>it</code>.
What is type of <code>c</code>? What if it doesn't introduce and thus avoids accidentally
capturing identifiers? Are we allowed only one form or both? Which do we select
and why?
</p>

<p>
I may be completely wrong, but below I mention a <a href="#org37d3bcd">bunch of papers</a> that suggest
it's kind hard to type this stuff.
</p>

<p>
<b>Second</b>: The type theory just wasn't in place at the time Lisp was created.
</p>

<p>
Here's a probably wrong account of how it went down.
</p>

<dl class="org-dl">
<dt>1913ish</dt><dd>Bertrand Russel introduces a hierarchy of types to avoid barber trouble;
e.g., <code>Typeᵢ : Typeᵢ₊₁</code>.</dd>
<dt>1920s</dt><dd>A Polish guy &amp; British guy think that's dumb and collapse the hierarchy.</dd>
<dt>1940s</dt><dd>Alonzo Church says arrows are cool.</dd>
<dt>1958 </dt><dd><p>
With his awesome hairdo, John McCarthy gifts the world an elegant
piece of art: Lisp (•̀ᴗ•́)و
</p>
<ul class="org-ul">
<li>Lisp is currently the 2ⁿᵈ oldest high-level language still
in use after Fortran.</li>
<li>Maxwell's equations <a href="https://queue.acm.org/detail.cfm?id=1039523">get</a> <a href="http://www.michaelnielsen.org/ddi/lisp-as-the-maxwells-equations-of-software/">jealous</a>.</li>
</ul>

<p>
Lisp introduces a bunch of zany ideas to CS:
</p>
<ul class="org-ul">
<li>Introduced if-then-else “McCarthy's Conditional”; 1ˢᵗ class functions &amp; recursion</li>
<li>macros ≈ compiler plugins</li>
<li>symbols ≈ raw names which needn't have values</li>
<li>variables ≈ pointers</li>
<li>code ≈ data; statements ≈ expressions</li>
<li><code>read, eval, load, compile, print</code> are all functions!</li>
</ul></dd>

<dt>1959</dt><dd>My man JM thinks manual memory is lame &#x2014;invents garbage collection!
<ul class="org-ul">
<li>Later, 2001, he writes <a href="https://web.archive.org/web/20130814213421/http://www-formal.stanford.edu/jmc/robotandbaby/robotandbaby.html">The Robot &amp; The Baby</a>.</li>
</ul></dd>
<dt>1960s</dt><dd>Simula says OOPs!</dd>
<dt>1970s</dt><dd>Smalltalk popularises the phrase “oop”. ( B has a child named C. )</dd>
<dt>1970s</dt><dd>Simple λ-calculus is a fashion model for sets and functions.</dd>
<dt>1970s</dt><dd>Milner and friends demand
<i>variables are for types too, not just terms!</i></dd>
<dt>1970s</dt><dd>Per Martin-Löf tells us it's okay to depend on one another; <code>Π, Σ</code> types.</dd>
<dt>1982 </dt><dd>A Lisp <a href="https://en.wikipedia.org/wiki/Ummah">ummah</a> is formed: <a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node1.html">“Common Lisp the Language”</a> ♥‿♥
<ul class="org-ul">
<li>In order to be hip &amp; modern, it's got <a href="https://extravagaria.com/Files/LASC-Overview.pdf">class</a> with <a href="https://en.wikipedia.org/wiki/Common_Lisp_Object_System">CLOS</a>.</li>
<li>Other shenanigans: Scheme 1975, Elisp 1985, Racket 1995, Clojure 2007</li>
</ul></dd>
<dt>1984</dt><dd>A script of sorcerous schemes lords lisp over mere mortals</dd>
<dt>1990s</dt><dd>A committee makes a sexy <a href="https://en.wiktionary.org/wiki/a_camel_is_a_horse_designed_by_a_committee">camel</a> named Haskell; Professor X's school make their own camel.
<ul class="org-ul">
<li>Their kids get on steroids and fight to this day; Agda ↯↯↯ Coq.</li>
</ul></dd>
<dt>2000s</dt><dd><p>
X's camel .&lt;becomes .~(self .&lt;aware&gt;.)&gt;.
&#x2014;the other camel [does| the same].
</p>
<ul class="org-ul">
<li>In 2015, the cam ls married Lisp and <a href="https://luxlang.gitbooks.io/the-lux-programming-language/content/">Lux</a> was born.</li>
<li>In 2016, Haskell &amp; Lisp get involved with Prolog; <a href="https://shen-language.github.io/">Shen</a> is born.</li>
</ul>

<p>
2019: Coq is <a href="https://github.com/MetaCoq/metacoq">self-aware</a>; Agda is <a href="https://github.com/alhassy/gentle-intro-to-reflection">playing</a> <a href="https://alhassy.github.io/next-700-module-systems-proposal/prototype/PackageFormer.html">catch-up</a>.
</p></dd>
</dl>

<p>
A more informative historical account of Lisp &amp; its universal reverence can be read at:
<a href="https://twobithistory.org/2018/10/14/lisp.html">How Lisp Became God's Own Programming Language</a>.
</p>

<figure>
<img src="https://imgs.xkcd.com/comics/lisp.jpg" alt="lisp.jpg">

<figcaption><span class="figure-number">Figure 3: </span>xkcd</figcaption>
</figure>
</div>
</div>

<div id="outline-container-orgf50385b" class="outline-2">
<h2 id="lisp-is-typed"><a href="#lisp-is-typed">Lisp Actually Admits Static Typing!</a></h2>
<div class="outline-text-2" id="text-lisp-is-typed">
<p>
Besides Common Lisp, “Typed Lisps” include <a href="https://github.com/clojure/core.typed">an optional type system for Clojure</a>
&#x2014;see also <a href="https://circleci.com/blog/why-were-no-longer-using-core-typed/">Why we're no longer using Core.typed</a>&#x2014;
<a href="https://docs.racket-lang.org/ts-guide/">Typed Racket</a>, and, more recently, <a href="https://github.com/LuxLang/lux">Lux</a> ≈ Haskell + ML + Lisp
and  <a href="https://shen-language.github.io/">Shen</a> ≈ Haskell + Prolog + Lisp.
</p>

<p>
<a href="https://news.ycombinator.com/item?id=8593261">For example,</a> Common Lisp admits strong static typing, in <a href="http://www.lispforum.com/viewtopic.php?f=2&amp;t=191">SBCL</a>, as follows.
</p>
<div class="org-src-container">
<pre class="src src-common-lisp">  <span style="color: #96A7A9; font-style: italic;">; Type declaration then definition.</span>
  (<span style="color: #859900; font-weight: bold;">declaim</span> (ftype (function (fixnum)) num-id))
  (<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">num-id</span> (n) n)

  (<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">string-id</span> (s) (<span style="color: #859900; font-weight: bold;">declare</span> (string s)) (num-id s))
  <span style="color: #96A7A9; font-style: italic;">; in: DEFUN STRING-ID</span>
  <span style="color: #96A7A9; font-style: italic;">;     (NUM-ID S)</span>
  <span style="color: #96A7A9; font-style: italic;">;</span>
  <span style="color: #96A7A9; font-style: italic;">; caught WARNING:</span>
  <span style="color: #96A7A9; font-style: italic;">;   Derived type of S is</span>
  <span style="color: #96A7A9; font-style: italic;">;     (VALUES STRING &amp;OPTIONAL),</span>
  <span style="color: #96A7A9; font-style: italic;">;   conflicting with its asserted type</span>
  <span style="color: #96A7A9; font-style: italic;">;     FIXNUM.</span>
</pre>
</div>

<p>
Such annotations mostly serve as compiler optimisation annotations and,
unfortunately, Emacs Lisp <a href="https://www.gnu.org/software/emacs/manual/html_node/cl/Declarations.html">silently ignores Common Lisp declarations such as ftype</a>
&#x2014;which provides <a href="http://www.lispworks.com/documentation/lw51/CLHS/Body/d_ftype.htm#ftype">function type</a> declarations.
However,
Emacs Lisp does provide a method of <a href="http://www.p-cos.net/documents/filtered-dispatch.pdf">dispatch</a> filtered by <a href="http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html">classes</a> rather than by
simple types. Interestingly, Lisp methods are more like Haskell typeclass constituents
or C# extensible methods
rather than like Java object methods &#x2014;in that, <i>Lisp methods specialise on classes</i>
whereas Java's approach is <i>classes have methods</i>.
</p>

<p>
Here's an example.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">defmethod</span> <span style="color: #b58900;">doit</span> ((n integer)) <span style="color: #35a69c; font-style: italic;">"I'm an integer!"</span>)
(<span style="color: #859900; font-weight: bold;">defmethod</span> <span style="color: #b58900;">doit</span> ((s <span style="color: #b58900;">string</span>)) <span style="color: #35a69c; font-style: italic;">"I'm a string!"</span>)
(<span style="color: #859900; font-weight: bold;">defmethod</span> <span style="color: #b58900;">doit</span> ((type (<span style="color: #b58900;">eql</span> <span style="color: #d33682; font-style: italic;">:hero</span>)) thing) <span style="color: #35a69c; font-style: italic;">"I'm a superhero!"</span>)

(doit 2)             <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; I'm an integer!</span>
(doit <span style="color: #2aa198;">"2"</span>)           <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; I'm a string!</span>
(doit 'x)            <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; Error: No applicable method</span>
(doit <span style="color: #d33682; font-style: italic;">:hero</span> 'bobert) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; I'm a superhero!</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">C-h o cl-defmethod &#8658; see extensible list of specialisers Elisp supports.</span>
</pre>
</div>

<p>
We can of-course make our own classes:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">defclass</span> <span style="color: #b58900; font-style: italic;">person</span>  () ((name)))
(<span style="color: #859900; font-weight: bold;">defmethod</span> <span style="color: #b58900;">speak</span> ((x person)) (<span style="color: #b58900;">format</span> <span style="color: #2aa198;">"My name is %s."</span> (<span style="color: #b58900;">slot-value</span> x 'name)))
(<span style="color: #859900; font-weight: bold;">setq</span> p (<span style="color: #b58900;">make-instance</span> 'person))
(<span style="color: #859900; font-weight: bold;">setf</span> (<span style="color: #b58900;">slot-value</span> p 'name) <span style="color: #2aa198;">"bobert"</span>)
(speak p) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; My name is bobert.</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Inherits from &#8216;</span><span style="color: #6c71c4; font-weight: bold; font-style: italic;">person</span><span style="color: #96A7A9; font-style: italic;">&#8217; and has accessor &amp; constructor methods for a new slot</span>
(<span style="color: #859900; font-weight: bold;">defclass</span> <span style="color: #b58900; font-style: italic;">teacher</span> (person) ((topic <span style="color: #d33682; font-style: italic;">:accessor</span> teacher-topic <span style="color: #d33682; font-style: italic;">:initarg</span> <span style="color: #d33682; font-style: italic;">:studying</span>)))

(<span style="color: #859900; font-weight: bold;">defmethod</span> <span style="color: #b58900;">speak</span> ((x teacher))
  (<span style="color: #b58900;">format</span> <span style="color: #2aa198;">"My name is %s,and I study %s."</span> (<span style="color: #b58900;">slot-value</span> x 'name) (teacher-topic x)))

(<span style="color: #859900; font-weight: bold;">setq</span> ins (<span style="color: #b58900;">make-instance</span> 'teacher <span style="color: #d33682; font-style: italic;">:studying</span> <span style="color: #2aa198;">"mathematics"</span>))
(<span style="color: #859900; font-weight: bold;">setf</span> (<span style="color: #b58900;">slot-value</span> ins 'name) <span style="color: #2aa198;">"Robert"</span>)
(speak ins) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; My name is Robert, and I study mathematics.</span>
</pre>
</div>

<p>
Later in this article, we'll make something like the <code>declaim</code> above
but have it be effectful at run-time. <i>Typing as Macros!</i>
</p>

<blockquote>
<p>
(
If you happen to be interested in looking under the hood to see what compiler generated
code looks like use <code>disassemble</code>. For example, declare <code>(defun go (x) (+ 1 x) 'bye)</code>
then invoke <code>(disassemble 'go)</code> to see something like
<code>varref x⨾ add1⨾ discard ⨾ constant bye⨾ return</code>.
)
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgd79ea63" class="outline-2">
<h2 id="elisp-types"><a href="#elisp-types">ELisp's Type Hierarchy</a></h2>
<div class="outline-text-2" id="text-elisp-types">
<p>
⇨ Each primitive type has a corresponding Lisp function that checks whether an object is a
  member of that type. Usually, these are the type name appended with <code>-p</code>, for multi-word
  names, and <code>p</code> for single word names. E.g., <code>string</code> type has the predicate <code>stringp</code>.
</p>

<dl class="org-dl">
<dt><a id="org0c7dfd1">Type Descriptor</a></dt><dd><p>
Objects holding information about types.
</p>

<p>
This is a <code>record</code>; the <code>type-of</code> function returns the first slot of records.
</p></dd>
</dl>

<p>
This section is based <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Lisp-Data-Types.html#Lisp-Data-Types">GNU Emacs Lisp Reference Manual</a>, §2.3 “Programming Types”.
</p>
</div>

<div id="outline-container-orgfd1ef15" class="outline-3">
<h3 id="Number"><a href="#Number">Number</a></h3>
<div class="outline-text-3" id="text-Number">
<p>
<i>Numbers, including fractional and non-fractional types.</i>
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>integer</code></td>
<td class="org-left"><code>float</code></td>
<td class="org-left"><code>number</code></td>
<td class="org-left"><code>natnum</code></td>
<td class="org-left"><code>zero</code></td>
<td class="org-left"><code>plus</code></td>
<td class="org-left"><code>minus</code></td>
<td class="org-left"><code>odd</code></td>
<td class="org-left"><code>even</code></td>
</tr>
</tbody>
</table>

<p>
The relationships between these types are as follows:
</p>
<table>


<colgroup>
<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>(numberp x) ≈ (or (integerp x) (floatp x))</code></td>
</tr>

<tr>
<td class="org-left"><code>(natnump x) ≈ (and (integerp x) (≤ 0 x))</code></td>
</tr>

<tr>
<td class="org-left"><code>(zerop   x) ≈ (equal 0 x)</code></td>
</tr>

<tr>
<td class="org-left"><code>(plusp   x) ≈ (&lt; 0 x)</code></td>
</tr>

<tr>
<td class="org-left"><code>(minusp  x) ≈ (&gt; 0 x)</code></td>
</tr>

<tr>
<td class="org-left"><code>(evenp    x) ≈ (zerop (mod x 2))</code></td>
</tr>

<tr>
<td class="org-left"><code>(oddp     x) ≈ (not (oddp x))</code></td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li><p>
<b>Integer</b>: Numbers without fractional parts.
</p>

<p>
There is no overflow checking.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">expt</span> 2 60) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 1,152,921,504,606,846,976</span>
(<span style="color: #b58900;">expt</span> 2 61) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; -2,305,843,009,213,693,952</span>
(<span style="color: #b58900;">expt</span> 2 62) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 0</span>
</pre>
</div>

<p>
Numbers are written with an optional sign ‘+’ or ‘-’ at the beginning and
  an optional period at the end.
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>-1 ≈ -1.</code></td>
<td class="org-left"><code>1 ≈ +1 ≈ 1.</code></td>
</tr>
</tbody>
</table>

<p>
They may also take <i>inclusive</i> (and exclusive) ranges:
The type list <code>(integer LOW HIGH)</code> represents all integers between
 <code>LOW</code> and <code>HIGH</code>, inclusive.  Either bound may be a list of a single
 integer to specify an exclusive limit, or a <code>*</code> to specify no
 limit.  The type <code>(integer * *)</code> is thus equivalent to <code>integer</code>.
 Likewise, lists beginning with <code>float</code>, <code>real</code>, or <code>number</code>
 represent numbers of that type falling in a particular range.
 ( <a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#Predicates">The Emacs Common Lisp Documentation</a> )
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">    (<span style="color: #b58900;">typep</span> 4 '(integer 1 5)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true since 1 &#8804; 4 &#8804; 5.</span>
    (<span style="color: #b58900;">typep</span> 4 '(integer 1 3)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil  since 1 &#8804; 4 &#8816; 3.</span>

    (<span style="color: #b58900;">typep</span> 12 'integer) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
    (<span style="color: #b58900;">typep</span> 12 'number) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>

    (<span style="color: #b58900;">typep</span> 23 'odd)  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>

    (<span style="color: #b58900;">typep</span> 12 '(integer <span style="color: #b58900;">*</span> 14)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t, since 12 &#8804; 14, but no lower bound.</span>
    (<span style="color: #b58900;">typep</span> 12 '(integer 0 <span style="color: #b58900;">*</span>)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t; the &#8216;*&#8217; denotes a wild-card; anything.</span>

   (<span style="color: #b58900;">typep</span> -1 '(<span style="color: #b58900;">not</span> (integer 0 <span style="color: #b58900;">*</span>))) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
   (<span style="color: #b58900;">typep</span>  1 '(<span style="color: #b58900;">not</span> (integer 0 <span style="color: #b58900;">*</span>))) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil</span>

   (<span style="color: #b58900;">typep</span> 1 '(integer  1 2))   <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t, including lower bound</span>
   (<span style="color: #b58900;">typep</span> 1 '(integer (1) 2))  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil, excluding lower bound</span>

   (<span style="color: #b58900;">typep</span> 1.23 '(<span style="color: #b58900;">float</span> 1.20 1.24)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>

   <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Here's a slighly organised demonstration:</span>

   (<span style="color: #b58900;">typep</span> 1.23 'number) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
   (<span style="color: #b58900;">typep</span> 123  'number) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
   (<span style="color: #b58900;">typep</span> 1.23 'real) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
   (<span style="color: #b58900;">typep</span> 123  'real) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>

   (<span style="color: #b58900;">typep</span> 1.23 'integer) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil</span>
   (<span style="color: #b58900;">typep</span> 123  'integer) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
   (<span style="color: #b58900;">typep</span> 1.23 'fixnum) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil</span>
   (<span style="color: #b58900;">typep</span> 123  'fixnum) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>

   (<span style="color: #b58900;">typep</span> 1.23 '<span style="color: #b58900;">float</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
   (<span style="color: #b58900;">typep</span> 123 '<span style="color: #b58900;">float</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil</span>
   (<span style="color: #b58900;">typep</span> 123.0 '<span style="color: #b58900;">float</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
</pre>
</div></li>

<li><b>Floating-Point</b>: Numbers with fractional parts; expressible using scientific notation.
For example, <code>15.0e+2 ≈ 1500.0</code> and <code>-1.0e+INF</code> for negative infinity.</li>

<li><b>Aliases:</b>
The type symbol <code>real</code> is a synonym for <code>number</code>, <code>fixnum</code> is a
 synonym for <code>integer</code>, and <code>wholenum</code> is a synonym for <code>natnum</code>.</li>

<li><p>
The smallest and largest values <i>representable</i> in a Lisp integer are in the
constants <code>most-negative-fixnum</code> and <code>most-postive-fixnum</code>
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Relationship with infinities</span>
(<span style="color: #b58900;">&lt;</span> -1e+INF <span style="color: #268bd2;">most-negative-fixnum</span> <span style="color: #268bd2;">most-positive-fixnum</span> 1e+INF) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org36322b9" class="outline-3">
<h3 id="Character"><a href="#Character">Character</a></h3>
<div class="outline-text-3" id="text-Character">
<p>
<i>Representation of letters, numbers, and control characters.</i>
</p>

<p>
A character is just a small integers, up to 22 bits;
e.g., character <code>A</code> is represented as the integer 65.
</p>

<p>
One writes the character ‘A’ as <code>?A</code>, which is identical to 65.
Punctuations <code>()[]\;"|'`#</code> must be &#x00ad;escaped; e.g.,
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>?\( ≈ 40</code></td>
<td class="org-left"><code>?\\ ≈ 92</code></td>
</tr>
</tbody>
</table>
<p>
Whereas <code>?. ≈ 46</code>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">characterp</span> ?f) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
(<span style="color: #b58900;">characterp</span> <span style="color: #268bd2;">t</span>)  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil</span>
</pre>
</div>

<p>
Emacs specfic characters control-g <code>C-g</code>, backspace <code>C-h</code>, tab <code>C-i</code>, newline <code>C-j</code>, space,
return, del, and escape are expressed by ?\a, ?\b, ?\t, ?\n, ?\s, ?\r, ?\d, ?\e.
</p>

<p>
Generally, control characters can be expressed as <code>?\^𝓍 ≈ ?\C-𝓍</code>,
and meta characters by <code>?\M-𝓍</code>; e.g., <code>C-M-b</code> is expressed
<code>?\M-\C-b ≈ ?\C-\M-b</code>.
</p>

<p>
Finally, <code>?\S-𝓍</code> denotes shifted-𝓍 characters.
There are also <code>?\H-𝓍, ?\A-𝓍, ?\s-𝓍</code> to denote Hyper- Alt- or Super-modified keys;
note that lower case ‘s’ is for super whereas capital is for shift,
and lower case with no dash is a space character.
</p>
</div>
</div>

<div id="outline-container-org555757f" class="outline-3">
<h3 id="Symbol"><a href="#Symbol">Symbol</a></h3>
<div class="outline-text-3" id="text-Symbol">
<p>
<i>A multi-use object that refers to functions and variables, and more.</i>
</p>

<p>
A symbol is an object with a name; different objects have different names.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">typep</span> 'yes 'symbol) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">symbolp</span> 'yes)       <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>

(<span style="color: #b58900;">typep</span> 12   'symbol) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
(<span style="color: #b58900;">symbolp</span> 12)         <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
</pre>
</div>

<table>


<colgroup>
<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>symbol</code> ≈ Is it a symbol?</td>
</tr>

<tr>
<td class="org-left"><code>bound</code>  ≈ Does it refer to anything?</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">typep</span> 'xyz 'bound) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil</span>

(<span style="color: #859900; font-weight: bold;">setq</span> xyz 123)
(<span style="color: #b58900;">typep</span> 'xyz 'bound) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
</pre>
</div>
<p>
See this short <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Void-Variables.html#Void-Variables">docs</a> page for more info on when a variable is void.
</p>

<p>
<span class="underline">Names have a tremendously flexible syntax.</span>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">setq</span> +*/-_~!<span style="color: #b58900;">@$%^&amp;</span>:&lt;&gt;{}? 23)
(<span style="color: #859900; font-weight: bold;">setq</span> \+1            23) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Note +1 &#8776; 1, a number.</span>
(<span style="color: #859900; font-weight: bold;">setq</span> \12            23)
(<span style="color: #859900; font-weight: bold;">setq</span> this\ is\ woah 23) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Escaping each space!</span>
(<span style="color: #b58900;">+</span> this\ is\ woah 1)     <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 24</span>
</pre>
</div>

<p>
If the symbbol name starts with a colon ‘:’, it's called a keyword symbol
     and automatically acts as a constant.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">typep</span> <span style="color: #d33682; font-style: italic;">:hello</span> 'keyword) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
</pre>
</div>

<p>
Symbols generally act as names for variables and functions, however there are
some names that have <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Variables-with-Restricted-Values.html#Variables-with-Restricted-Values">fixed values</a> and any attempt to reset their values signals an error.
Most notably, these include <code>t</code> for true or the top-most type,
<code>nil</code> for false or the bottom-most type, and keywords.
These three evaluate to themselves.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #268bd2;">t</span>      <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
nil    <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil</span>
<span style="color: #d33682; font-style: italic;">:hello</span> <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; :hello</span>

(<span style="color: #859900; font-weight: bold;">setq</span> <span style="color: #268bd2;">t</span>   12) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; Error: Attempt to set a constant symbol</span>
(<span style="color: #859900; font-weight: bold;">setq</span> nil 12) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; Error: Attempt to set a constant symbol</span>
(<span style="color: #859900; font-weight: bold;">setq</span> <span style="color: #d33682; font-style: italic;">:x</span>  12) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; Error: Attempt to set a constant symbol</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">:x &#8800; 'x</span>
(<span style="color: #b58900;">set</span> 'x 12) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 12</span>
x           <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 12</span>

<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">They're self-evaluating</span>
(<span style="color: #b58900;">equal</span> <span style="color: #268bd2;">t</span>   '<span style="color: #268bd2;">t</span>)   <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
(<span style="color: #b58900;">equal</span> nil 'nil) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
(<span style="color: #b58900;">equal</span> <span style="color: #d33682; font-style: italic;">:x</span>  '<span style="color: #d33682; font-style: italic;">:x</span>)  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>

(<span style="color: #b58900;">equal</span> <span style="color: #d33682; font-style: italic;">:x</span> 'x)  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; nil</span>
</pre>
</div>

<p>
In particular, <code>:x ≠ 'x</code>!
</p>
</div>
</div>

<div id="outline-container-org0365cda" class="outline-3">
<h3 id="Sequence"><a href="#Sequence">Sequence</a></h3>
<div class="outline-text-3" id="text-Sequence">
<p>
<i>The interface for ordered collections</i>; e.g.,
the <code>(elt sequence index)</code> function can be applied to any sequence
to extract an element at the given index.
</p>

<div class="org-center">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>sequence</code></td>
<td class="org-left"><code>seq</code></td>
</tr>
</tbody>
</table>
</div>

<p>
The latter is an extensible variant of the former
&#x2014;for when we declare our own sequential data types.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">typep</span> '(1 2 3) 'sequence) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
</pre>
</div>

<p>
There are two immediate subtypes: <code>array</code> and <code>cons</code>, the latter has <code>list</code>
as a subtype.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">typep</span>  [1 2 3] 'array)       <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
(<span style="color: #b58900;">typep</span> '(1 2 3) '<span style="color: #b58900;">cons</span>)        <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
(<span style="color: #b58900;">typep</span> '(1 <span style="color: #2aa198;">"2"</span> 'three) '<span style="color: #b58900;">list</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
</pre>
</div>

<dl class="org-dl">
<dt>Array</dt><dd><p>
Arrays include strings and vectors.
</p>
<dl class="org-dl">
<dt>Vector</dt><dd>One-dimensional arrays.</dd>
<dt>Char-Table</dt><dd>One-dimensional sparse arrays indexed by characters.</dd>
<dt>Bool-Vector</dt><dd>One-dimensional arrays of <code>t</code> or <code>nil</code>.</dd>
<dt>Hash Table</dt><dd>Super-fast lookup tables.</dd>
</dl>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">typep</span> <span style="color: #2aa198;">"hi"</span> '<span style="color: #b58900;">string</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> 'hi  '<span style="color: #b58900;">string</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
</pre>
</div></dd>

<dt>Cons cell type</dt><dd><p>
Cons cells and lists, which are chains of cons cells.
</p>

<p>
These are objects consisting of two Lisp objects, called <code>car</code> and <code>cdr</code>.
That is they are pairs of Lisp objects.
</p>

<div class="org-src-container">
<pre class="src src-math">      '(x₀ x₁ x₂)
    ≈ '(x₀ . (x₁ . (x₂ . nil)))
    ≠ '(x₀ x₁ . x₂)
    ≈ '(x₀ . (x₁ . x₂))
</pre>
</div>

<p>
Notice that when there is no ‘.’, then a list
is just a nested cons chain ending in ‘nil’.
Note that <code>'(x₀ . x₁ . x₂)</code> is meaningless.
</p>

<p>
Cons cells are central to Lisp and so objects which are not a cons
cell are called <i>atoms</i>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">An atom is not a cons.</span>
(<span style="color: #b58900;">typep</span> 123 '<span style="color: #b58900;">atom</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
(<span style="color: #b58900;">typep</span> 'ni '<span style="color: #b58900;">atom</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
</pre>
</div>

<p>
Computationally:
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><code>(atom x)</code></td>
</tr>

<tr>
<td class="org-left">≈</td>
<td class="org-left"><code>(typep x 'atom)</code></td>
</tr>

<tr>
<td class="org-left">≈</td>
<td class="org-left"><code>(not (consp x))</code></td>
</tr>

<tr>
<td class="org-left">≈</td>
<td class="org-left"><code>(not (typep x 'cons))</code></td>
</tr>

<tr>
<td class="org-left">≈</td>
<td class="org-left"><code>(typep x '(not cons))</code></td>
</tr>
</tbody>
</table>

<p>
Interestingly, one writes <code>atom</code>, not <code>atomp</code>.
</p></dd>
</dl>
</div>
</div>

<div id="outline-container-org4fb3d81" class="outline-3">
<h3 id="Function"><a href="#Function">Function</a></h3>
<div class="outline-text-3" id="text-Function">
<p>
<i>Piece of executable code.</i>
</p>

<p>
A non-compiled function in Lisp is a lambda expression: A list whose
first element is the symbol <code>lambda</code>.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">consp</span>     (<span style="color: #859900; font-weight: bold;">lambda</span> (x) x))        <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">functionp</span> (<span style="color: #859900; font-weight: bold;">lambda</span> (x) x))        <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>

(<span style="color: #b58900;">functionp</span> (<span style="color: #859900; font-weight: bold;">lambda</span> is <span style="color: #b58900;">the</span> <span style="color: #b58900;">first</span>)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> (<span style="color: #859900; font-weight: bold;">lambda</span> stuff) '<span style="color: #b58900;">function</span>)  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
</pre>
</div>

<p>
It may help to know that a <code>defun</code> just produces an alias for a function:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">  (<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">name</span> (args) <span style="color: #35a69c; font-style: italic;">"docs"</span> body)
&#8776; (<span style="color: #859900; font-weight: bold;">defalias</span> (<span style="color: #859900; font-weight: bold;">quote</span> name) (<span style="color: #859900; font-weight: bold;">function</span> (<span style="color: #859900; font-weight: bold;">lambda</span> (args) docs body)))
</pre>
</div>

<p>
Here's some more examples.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">typep</span> #'<span style="color: #b58900;">+</span>   '<span style="color: #b58900;">function</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">typep</span> 'nice '<span style="color: #b58900;">function</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>

(<span style="color: #859900; font-weight: bold;">defun</span> <span style="color: #b58900;">it</span> (x) (<span style="color: #b58900;">format</span> <span style="color: #2aa198;">"%s"</span> (+1 x)))
(<span style="color: #b58900;">typep</span> #'it   '<span style="color: #b58900;">function</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">functionp</span> #'it)         <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcb20049" class="outline-3">
<h3 id="Macro"><a href="#Macro">Macro</a></h3>
<div class="outline-text-3" id="text-Macro">
<p>
<i>A method of expanding an expression into another expression.</i>
</p>

<p>
Like functions, any list that begins with <code>macro</code>, and whose <code>cdr</code>
is a function, is considered a macro as long as Emacs Lisp is concerned.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">macrop</span> '(macro (<span style="color: #859900; font-weight: bold;">lambda</span> (x) x))) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
</pre>
</div>

<p>
Since <code>defmacro</code> produces an alias, as follows,
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">  (<span style="color: #859900; font-weight: bold;">defmacro</span> <span style="color: #b58900;">name</span> (args) <span style="color: #35a69c; font-style: italic;">"docs"</span> body)
&#8776; (<span style="color: #859900; font-weight: bold;">defalias</span> (<span style="color: #859900; font-weight: bold;">quote</span> name) (<span style="color: #b58900;">cons</span> (<span style="color: #859900; font-weight: bold;">quote</span> macro) (<span style="color: #859900; font-weight: bold;">function</span> (<span style="color: #859900; font-weight: bold;">lambda</span> (args) docs body))))
</pre>
</div>

<p>
You may be concerned that <code>(macrop x) ≟ (equal 'macro (car x))</code>, and so if a user
gives you a macro you might think its a cons cell of data.
Fortunately this is not the case:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">defmacro</span> <span style="color: #b58900;">no-op</span> () )

(<span style="color: #b58900;">macrop</span> #'no-op)    <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; true</span>
(<span style="color: #b58900;">consp</span>  #'no-op)    <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false; whence it's also not a list.</span>
(<span style="color: #b58900;">functionp</span> #'no-op) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>

(<span style="color: #b58900;">typep</span> #'no-op '
       (satisfies (<span style="color: #859900; font-weight: bold;">lambda</span> (x) (<span style="color: #859900; font-weight: bold;">and</span> (<span style="color: #b58900;">listp</span> x) (<span style="color: #b58900;">equal</span> 'macro (<span style="color: #b58900;">car</span> x)))))) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; false</span>
</pre>
</div>

<p>
Why not? Well, you could think of a macro as a ‘record’ whose label is <code>macro</code> and
its only element is the associated function.
</p>
</div>
</div>

<div id="outline-container-org75d337b" class="outline-3">
<h3 id="Record"><a href="#Record">Record</a></h3>
<div class="outline-text-3" id="text-Record">
<p>
<i>Compound objects with programmer-defined types.</i>
</p>

<p>
They are the underlying representation of <code>defstruct</code> and <code>defclass</code> instances.
</p>

<p>
For example:
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">defstruct</span> person
  name age)
</pre>
</div>

<p>
The <code>type-of</code> operator yields the <code>car</code> of instances of such declartions.
</p>
<table>


<colgroup>
<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><code>(record τ e₀ … eₙ) ≈ #s(τ e₀ … eₙ)</code></td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">setq</span> bobert (make-person <span style="color: #d33682; font-style: italic;">:name</span> <span style="color: #2aa198;">"bobby"</span> <span style="color: #d33682; font-style: italic;">:age</span> 'too-much))
(<span style="color: #b58900;">type-of</span> bobert) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; person</span>
</pre>
</div>

<p>
Componenets may be indexed with <code>aref</code>.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">aref</span> bobert 1)      <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; bobby</span>
(person-name bobert) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; bobby</span>
</pre>
</div>

<p>
A record is considered a constant for evaulation: Evaluating it yields itself.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b58900;">type-of</span> #s(person <span style="color: #2aa198;">"mark"</span> twelve)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; person</span>
(<span style="color: #b58900;">recordp</span> #s(nice))                 <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; t</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org5306c0e" class="outline-2">
<h2 id="typing-via-macros"><a href="#typing-via-macros">Typing via Macros &amp; Advice</a></h2>
<div class="outline-text-2" id="text-typing-via-macros">
<p>
Checking the type of inputs is tedious and so I <a href="https://www.reddit.com/r/emacs/comments/cct5hp/functional_type_declarations_in_elisp/">guessed</a> it could be done using
macros and advice. Looking at <a href="https://docs.racket-lang.org/ts-guide/types.html">Typed Racket</a> for inspiration, the following
fictitious syntax would add advice to <code>f</code> that checks the optional arguments <code>xᵢ</code>
have type <code>σᵢ</code> and the mandatory positional arguments have type <code>τᵢ</code> according
to position, and the result of the computation is of type <code>τ</code>.
To the best of my knowledge, no one had done this for Emacs Lisp &#x2014;I don't know why.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(declare-type 'f ((<span style="color: #d33682; font-style: italic;">:x&#8321;</span> &#963;&#8321;) &#8230; (<span style="color: #d33682; font-style: italic;">:x&#8344;</span> &#963;&#8344;)) (&#964;&#8321; &#8230; &#964;&#8345; &#964;))
</pre>
</div>

<p>
To modify a variable, or function, we may simply redefine it; but a much more elegant and powerful
approach is to <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Advising-Functions.html">“advise”</a> the current entity with some new behaviour. In our case of interest, we will
<i>advise functions to check their arguments before executing their bodies</i>.
</p>

<p>
Below is my attempt: <a id="org7d207a3"><code>declare-type</code></a>. Before you get scared or think it's horrendous, be charitable and
note that about a third of the following is documentation and a third is local declarations.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #859900; font-weight: bold;">cl-defmacro</span> <span style="color: #b58900;">declare-type</span> (f key-types <span style="color: #b58900; font-style: italic;">&amp;rest</span> types)
  <span style="color: #35a69c; font-style: italic;">"Attach the given list of types to the function &#8216;f&#8217;</span>
<span style="color: #35a69c; font-style: italic;">   by advising the function to check its arguments&#8217; types</span>
<span style="color: #35a69c; font-style: italic;">   are equal to the list of given types.</span>

<span style="color: #35a69c; font-style: italic;">   We name the advice &#8216;&#10218;f&#10219;-typing-advice&#8217; so that further</span>
<span style="color: #35a69c; font-style: italic;">   invocations to this macro overwrite the same advice function</span>
<span style="color: #35a69c; font-style: italic;">   rather than introducing additional, unintended, constraints.</span>

<span style="color: #35a69c; font-style: italic;">   Using type specifiers we accommodate for unions of types</span>
<span style="color: #35a69c; font-style: italic;">   and subtypes, etc &#9829;&#8255;&#9829;.</span>

<span style="color: #35a69c; font-style: italic;">   &#8216;</span><span style="color: #6c71c4; font-weight: bold; font-style: italic;">key-types</span><span style="color: #35a69c; font-style: italic;">&#8217; should be of the shape (:x&#8320; t&#8320; &#8943; :x&#8345; t&#8345;);</span>
<span style="color: #35a69c; font-style: italic;">    when there are no optional types, use symbol &#8220;:&#8221;.</span>

<span style="color: #35a69c; font-style: italic;">    E.g., (declare-type my-func (:z string :w integer) integer symbol string)</span>
<span style="color: #35a69c; font-style: italic;">  "</span>

  <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Basic coherency checks. When there aren't optional types, key-types is the &#8220;:&#8221; symbol.</span>
  (should (<span style="color: #859900; font-weight: bold;">and</span> (<span style="color: #b58900;">listp</span> types) (<span style="color: #859900; font-weight: bold;">or</span> (<span style="color: #b58900;">listp</span> key-types) (<span style="color: #b58900;">symbolp</span> key-types))))

  (<span style="color: #859900; font-weight: bold;">letf*</span> ((pairify (<span style="color: #859900; font-weight: bold;">lambda</span> (xs) (<span style="color: #859900; font-weight: bold;">loop</span> for i in xs by #'<span style="color: #b58900;">cddr</span>         <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Turn a list of flattenned pairs</span>
                                      for j in (<span style="color: #b58900;">cdr</span> xs) by #'<span style="color: #b58900;">cddr</span>   <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">into a list of explicit pairs.</span>
                                      collect (<span style="color: #b58900;">cons</span> i j))))         <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #dc8cc3;">MA</span><span style="color: #96A7A9; font-style: italic;">: No Lisp method for this!?</span>
         (result-type  (<span style="color: #b58900;">car</span> (<span style="color: #b58900;">-take-last</span> 1 types)))
         (types        (<span style="color: #b58900;">-drop-last</span> 1 types))
         (num-of-types (<span style="color: #b58900;">length</span> types))
         (key-types-og (<span style="color: #859900; font-weight: bold;">unless</span> (<span style="color: #b58900;">symbolp</span> key-types) key-types))
         (key-types    (<span style="color: #b58900;">funcall</span> pairify key-types-og))
         (advice-name  (<span style="color: #b58900;">intern</span> (<span style="color: #b58900;">format</span> <span style="color: #2aa198;">"%s-typing-advice"</span> f)))
         (notify-user  (<span style="color: #b58900;">format</span> <span style="color: #2aa198;">"%s now typed %s &#8594; %s &#8594; %s."</span>
                               `,f key-types-og types result-type)))

      `(<span style="color: #859900; font-weight: bold;">progn</span>
         (<span style="color: #859900; font-weight: bold;">defun</span> ,advice-name (orig-fun <span style="color: #b58900; font-style: italic;">&amp;rest</span> args)

           <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Split into positional and key args; optionals not yet considered.</span>
           (<span style="color: #859900; font-weight: bold;">letf*</span> ((all-args
                     (<span style="color: #b58900;">-split-at</span>
                       (<span style="color: #859900; font-weight: bold;">or</span> (<span style="color: #859900; font-weight: bold;">--find-index</span> (<span style="color: #b58900;">not</span> (<span style="color: #b58900;">s-blank?</span> (<span style="color: #b58900;">s-shared-start</span> <span style="color: #2aa198;">":"</span> (<span style="color: #b58900;">format</span> <span style="color: #2aa198;">"%s"</span> it)))) args) ,num-of-types)
                        args)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">The &#8220;or&#8221; is for when there are no keywords provided.</span>
                  (pos-args  (<span style="color: #b58900;">car</span> all-args))
                  (key-args  (<span style="color: #b58900;">funcall</span> ,pairify (<span style="color: #b58900;">cadr</span> all-args)))
                  (fun-result nil)
                  ((<span style="color: #b58900;">symbol-function</span> 'shucks)
                     (<span style="color: #859900; font-weight: bold;">lambda</span> (e&#964; e g)
                       (<span style="color: #859900; font-weight: bold;">unless</span> (<span style="color: #b58900;">typep</span> g e&#964;)
                         (<span style="color: #b58900;">error</span> <span style="color: #2aa198;">"%s: Type mismatch! Expected %s %s &#8800; Given %s %s."</span>
                                (<span style="color: #859900; font-weight: bold;">function</span> ,f) e&#964; e (<span style="color: #b58900;">type-of</span> g) (<span style="color: #b58900;">prin1-to-string</span> g))))))

         <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Check the types of positional arguments.</span>
         (<span style="color: #859900; font-weight: bold;">unless</span> (<span style="color: #b58900;">equal</span> ,num-of-types (<span style="color: #b58900;">length</span> pos-args))
           (<span style="color: #b58900;">error</span> <span style="color: #2aa198;">"%s: Insufficient number of arguments; given %s, %s, but %s are needed."</span>
                  (<span style="color: #859900; font-weight: bold;">function</span> ,f) (<span style="color: #b58900;">length</span> pos-args) pos-args ,num-of-types))
         (<span style="color: #859900; font-weight: bold;">loop</span> for (ar ty pos) in (<span style="color: #b58900;">-zip</span> pos-args (<span style="color: #859900; font-weight: bold;">quote</span> ,types) (<span style="color: #b58900;">number-sequence</span> 0 ,num-of-types))
               <span style="color: #b58900;">do</span> (shucks ty (<span style="color: #b58900;">format</span> <span style="color: #2aa198;">"for argument %s"</span> pos) ar))

         <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Check the types of *present* keys.</span>
         (<span style="color: #859900; font-weight: bold;">loop</span> for (k . v) in key-args
               <span style="color: #b58900;">do</span> (shucks (<span style="color: #b58900;">cdr</span> (<span style="color: #b58900;">assoc</span> k (<span style="color: #859900; font-weight: bold;">quote</span> ,key-types))) k v))

         <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Actually execute the orginal function on the provided arguments.</span>
         (<span style="color: #859900; font-weight: bold;">setq</span> fun-result (<span style="color: #b58900;">apply</span> orig-fun args))
         (shucks (<span style="color: #859900; font-weight: bold;">quote</span> ,result-type) <span style="color: #2aa198;">"for the result type (!)"</span> fun-result)

         <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Return-value should be given to caller.</span>
         fun-result))

      <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">Register the typing advice and notify user of what was added.</span>
      (<span style="color: #b58900;">advice-add</span> (<span style="color: #859900; font-weight: bold;">function</span> ,f) <span style="color: #d33682; font-style: italic;">:around</span> (<span style="color: #859900; font-weight: bold;">function</span> ,advice-name))
      ,notify-user )))
</pre>
</div>

<pre class="example">
declare-type
</pre>


<p>
There are some notable shortcomings: Lack of support for type variables and, for now, no support for
optional arguments. Nonetheless, I like it &#x2014;of course.
( Using <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Watching-Variables.html#Watching-Variables">variable watchers</a> we could likely add support for type variables as well as
function-types. )
</p>

<p>
<b>We accidentally forgot to consider an argument.</b>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(declare-type f&#8321; (<span style="color: #d33682; font-style: italic;">:z</span> <span style="color: #b58900;">string</span> <span style="color: #d33682; font-style: italic;">:w</span> <span style="color: #b58900;">list</span>) integer symbol <span style="color: #b58900;">string</span>)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; f&#8321; now typed (:z string :w integer) &#8594; (integer symbol) &#8594; string.</span>

(<span style="color: #859900; font-weight: bold;">cl-defun</span> <span style="color: #b58900;">f&#8321;</span> (x y <span style="color: #b58900; font-style: italic;">&amp;key</span> z w) (<span style="color: #b58900;">format</span> <span style="color: #2aa198;">"%s"</span> x))
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; f&#8321; now defined</span>

(f&#8321; 'x) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; f&#8321;: Insufficient number of arguments; given 2, (x), but 3 are needed.</span>
</pre>
</div>
<p>
The type declaration said we needed 3 arguments, but we did not consider one of them.
</p>

<p>
<b>We accidentally returned the wrong value.</b>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(declare-type f&#8322; (<span style="color: #d33682; font-style: italic;">:z</span> <span style="color: #b58900;">string</span> <span style="color: #d33682; font-style: italic;">:w</span> <span style="color: #b58900;">list</span>) integer symbol <span style="color: #b58900;">string</span>)
(<span style="color: #859900; font-weight: bold;">cl-defun</span> <span style="color: #b58900;">f&#8322;</span> (x y <span style="color: #b58900; font-style: italic;">&amp;key</span> z w) x)

(f&#8322; 144 'two)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; f&#8322;: Type mismatch! Expected string for the result type (!) &#8800; Given integer 144.</span>
</pre>
</div>

<p>
<b>We accidentally forgot to supply an argument.</b>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(declare-type f&#8323; (<span style="color: #d33682; font-style: italic;">:z</span> <span style="color: #b58900;">string</span> <span style="color: #d33682; font-style: italic;">:w</span> <span style="color: #b58900;">list</span>) integer symbol <span style="color: #b58900;">string</span>)
(<span style="color: #859900; font-weight: bold;">cl-defun</span> <span style="color: #b58900;">f&#8323;</span> (x y <span style="color: #b58900; font-style: italic;">&amp;key</span> z w) (<span style="color: #b58900;">format</span> <span style="color: #2aa198;">"%s"</span> x))

(f&#8323; 144)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; f&#8323;: Insufficient number of arguments; given 1, (144), but 2 are needed.</span>
</pre>
</div>

<p>
<b>A positional argument is supplied of the wrong type.</b>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(f&#8323; 'one <span style="color: #2aa198;">"two"</span>)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658;  f&#8323;: Type mismatch! Expected integer for argument 0 &#8800; Given symbol one.</span>

(f&#8323; 144 <span style="color: #2aa198;">"two"</span>)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; f&#8323;: Type mismatch! Expected symbol for argument 1 &#8800; Given string "two".</span>
</pre>
</div>
<p>
Notice: When multiple positional arguments have type-errors, the errors are reported one at a time.
</p>

<p>
<b>A keyword argument is supplied of the wrong type.</b>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(f&#8323; 1 'two <span style="color: #d33682; font-style: italic;">:z</span> 'no&#8320; <span style="color: #d33682; font-style: italic;">:w</span> 'no&#8321;)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; f&#8323;: Type mismatch! Expected string :z &#8800; Given symbol no&#8320;.</span>

(f&#8323; 1 'two <span style="color: #d33682; font-style: italic;">:z</span> <span style="color: #2aa198;">"ok"</span> <span style="color: #d33682; font-style: italic;">:w</span> 'no&#8321;)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; f&#8323;: Type mismatch! Expected string :w &#8800; Given symbol no&#8321;.</span>

(f&#8323; 1 'two <span style="color: #d33682; font-style: italic;">:z</span> <span style="color: #2aa198;">"ok"</span> <span style="color: #d33682; font-style: italic;">:w</span> 23)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; f&#8323;: Type mismatch! Expected string :w &#8800; Given integer 23.</span>

(f&#8323; 1 'two <span style="color: #d33682; font-style: italic;">:z</span> <span style="color: #2aa198;">"ok"</span> <span style="color: #d33682; font-style: italic;">:w</span> '(a b 1 2)) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; okay; no type-error.</span>
</pre>
</div>

<p>
<b>We have no optional arguments.</b>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(declare-type f&#8324; : integer symbol <span style="color: #b58900;">string</span>)
(<span style="color: #859900; font-weight: bold;">cl-defun</span> <span style="color: #b58900;">f&#8324;</span> (x y <span style="color: #b58900; font-style: italic;">&amp;key</span> z w) (<span style="color: #b58900;">format</span> <span style="color: #2aa198;">"%s"</span> x))

(f&#8324; 144 'two <span style="color: #d33682; font-style: italic;">:z</span> <span style="color: #2aa198;">"bye"</span>)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658;  f&#8324;: Type mismatch! Expected nil :z &#8800; Given string "bye".</span>
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">( We shouldn't have any keyword :z according to the type declaration! )</span>

(f&#8324; 144 'two) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; "144"</span>
</pre>
</div>

<p>
<b>We can incorporate type specfiers such as unions!</b>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(declare-type f&#8325; : (<span style="color: #859900; font-weight: bold;">or</span> integer <span style="color: #b58900;">string</span>) <span style="color: #b58900;">string</span>)
(<span style="color: #859900; font-weight: bold;">cl-defun</span> <span style="color: #b58900;">f&#8325;</span> (x) (<span style="color: #b58900;">format</span> <span style="color: #2aa198;">"%s"</span> x))

(f&#8325; 144)     <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; "144"</span>
(f&#8325; <span style="color: #2aa198;">"neato"</span>) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; "neato"</span>

(f&#8325; 'shaka-when-the-walls-fell)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; f&#8325;: Type mismatch! Expected (or integer string) for argument 0</span>
<span style="color: #96A7A9; font-style: italic;">;;       </span><span style="color: #96A7A9; font-style: italic;">&#8800; Given symbol shaka-when-the-walls-fell.</span>
</pre>
</div>

<p>
<b>No positional arguments but a complex optional argument!</b>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(declare-type f&#8326; (<span style="color: #d33682; font-style: italic;">:z</span> (satisfies (<span style="color: #859900; font-weight: bold;">lambda</span> (it) (<span style="color: #859900; font-weight: bold;">and</span> (<span style="color: #b58900;">integerp</span> it) (<span style="color: #b58900;">=</span> 0 (<span style="color: #b58900;">mod</span> it 5))))))
                 character)
(<span style="color: #859900; font-weight: bold;">cl-defun</span> <span style="color: #b58900;">f&#8326;</span> (<span style="color: #b58900; font-style: italic;">&amp;key</span> z) ?A)

(f&#8326; 'hi)     <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658;  Keyword argument 144 not one of (:z)</span>
(f&#8326;)         <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 65; i.e., the character &#8216;A&#8217;</span>
(f&#8326; <span style="color: #d33682; font-style: italic;">:z</span> 6)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658;  f&#8326;: Type mismatch!</span>
<span style="color: #96A7A9; font-style: italic;">;;    </span><span style="color: #96A7A9; font-style: italic;">Expected (satisfies (lambda (it) (and (integerp it) (= 0 (mod it 5))))) :z</span>
<span style="color: #96A7A9; font-style: italic;">;;    </span><span style="color: #96A7A9; font-style: italic;">&#8800; Given integer 6.</span>

(f&#8326; <span style="color: #d33682; font-style: italic;">:z</span> 10) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 65; i.e., the expected output since 10 mod 5 &#8776; 0 &amp; so 10 is valid input.</span>
</pre>
</div>

<p>
<b>Preconditions!</b> The previous example had a complex type on a keyword, but that was
essentially a pre-condition; we can do the same on positional arguments.
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(declare-type f&#8327; : (satisfies (<span style="color: #859900; font-weight: bold;">lambda</span> (it) (<span style="color: #b58900;">=</span> it 5)))
                   integer)
(<span style="color: #859900; font-weight: bold;">cl-defun</span> <span style="color: #b58900;">f&#8327;</span> (n) n)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">The identity on 5 function; and undefined otherwise.</span>

(f&#8327; 4)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; f&#8327;: Type mismatch! Expected (satisfies (lambda (it) (= it 5))) for argument 0</span>
<span style="color: #96A7A9; font-style: italic;">;;       </span><span style="color: #96A7A9; font-style: italic;">&#8800; Given integer 4.</span>

(f&#8327; 5) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 5</span>
</pre>
</div>

<p>
<b>Postconditions!</b>
Given an integer greater than 5, we present an integer greater than 2; i.e.,
this is a constructive proof that \(∀ n • n > 5 ⇒ n > 2\).
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(declare-type f&#8328; : (satisfies (<span style="color: #859900; font-weight: bold;">lambda</span> (in)  (<span style="color: #b58900;">&gt;</span> in 5)))
                   (satisfies (<span style="color: #859900; font-weight: bold;">lambda</span> (out) (<span style="color: #b58900;">&gt;</span> out 2))))
(<span style="color: #859900; font-weight: bold;">cl-defun</span> <span style="color: #b58900;">f&#8328;</span> (n) n)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">The identity on 5 function; and undefined otherwise.</span>

(f&#8328; 4)
<span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658;  f&#8328;: Type mismatch! Expected (satisfies (lambda (in) (&gt; in 5))) for argument 0</span>
<span style="color: #96A7A9; font-style: italic;">;;        </span><span style="color: #96A7A9; font-style: italic;">&#8800; Given integer 4.</span>

(f&#8328; 72) <span style="color: #96A7A9; font-style: italic;">;; </span><span style="color: #96A7A9; font-style: italic;">&#8658; 72; since indeed 72 &gt; 5 for the input, and clearly 72 &gt; 2 for the output.</span>
</pre>
</div>

<p>
As it currently stands we cannot make any explicit references between the inputs
and the output, but that's an easy fix: Simply add a local function <code>old</code> to the
<a href="#org7d207a3"><code>declare-type</code></a> macro which is intentionally exposed so that it can be used in the
type declarations to refer to the ‘old’, or initial, values provided to the function.
Additionally, one could also add keyword arguments <code>:requires</code> and <code>:ensures</code>
for a more sophisticated pre- and post-condition framework.
<a href="https://github.com/sellout/quid-pro-quo">Something</a> along these lines is implemented for Common Lisp.
</p>

<p>
Here's a fun exercise: Recast the <a href="https://liquid.kosmikus.org/01-intro.html#/what-is-liquid-haskell">Liquid Haskell</a> examples in Lisp using this
<a href="#org7d207a3"><code>declare-type</code></a> form.
</p>
</div>
</div>

<div id="outline-container-orgbf457a7" class="outline-2">
<h2 id="Closing"><a href="#Closing">Closing</a></h2>
<div class="outline-text-2" id="text-Closing">
<blockquote>
<p>
<i>I have heard more than one LISP advocate state such subjective comments as, "LISP is the most powerful and elegant programming language in the world" and expect such comments to be taken as objective truth. I have never heard a Java, C++, C, Perl, or Python advocate make the same claim about their own language of choice.</i>
</p>

<p>
---<a href="http://www.paulgraham.com/quotes.html">A guy on slashdot</a>
</p>
</blockquote>

<p>
I learned a lot of stuff, hope you did too ^_^
</p>
</div>
</div>

<div id="outline-container-orgc1700bc" class="outline-2">
<h2 id="references"><a href="#references">References</a></h2>
<div class="outline-text-2" id="text-references">
<p>
Neato web articles:
</p>
<ul class="org-ul">
<li><a href="http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html">What to know before debating type systems</a>
<ul class="org-ul">
<li>Debunks a number of fallacies such as
“dynamic typing provides no way to find bugs” and
“static types need type declarations”.</li>
</ul></li>
<li><a href="http://steve-yegge.blogspot.com/2008/05/dynamic-languages-strike-back.html">Dynamic Languages Strike Back</a>
<ul class="org-ul">
<li>Everything you might wanna know about dynamically checked languages.</li>
</ul></li>
<li><a href="http://www.ai.sri.com/~delacaze/alu-site/alu/table/contents.htm">The Association of Lisp Users</a>
<ul class="org-ul">
<li>Abundant resource relating to Lisp.</li>
</ul></li>
<li><a href="https://www.williamjbowman.com/blog/2018/01/19/untyped-programs-don-t-exist/#related">Untyped Programs Don’t Exist</a>
<ul class="org-ul">
<li>It's not a matter of typing but of pragmatics.</li>
</ul></li>
<li><a href="http://homes.sice.indiana.edu/jsiek/what-is-gradual-typing/">What is Gradual Typing</a>:
<ul class="org-ul">
<li>Discusses how static and dynamic typing can be used together hamroniously.</li>
</ul></li>
<li><a href="https://www.cliki.net/">CLiki &#x2014; The Common Lisp Wiki</a>
<ul class="org-ul">
<li>Contains resources for learning about
and using the   programming language Common Lisp.</li>
<li>The humour section is delightful.</li>
</ul></li>
<li><a href="http://www.cs.utexas.edu/users/boyer/ftp/diss/akers.pdf">Strong Static Type Checking for Functional Common Lisp</a>
<ul class="org-ul">
<li>PhD thesis regarding strong static type checking in an applicative subset of CL.</li>
</ul></li>
<li><a href="http://www.paulgraham.com/avg.html">Beating the Averages</a>
<ul class="org-ul">
<li>Paul Graham discusses “the most powerful language available” &#x2014;Lisp.</li>
<li>Other articles he's written about Lisp can be found <a href="http://www.paulgraham.com/lisp.html">here</a>.</li>
</ul></li>
<li><a href="http://www.marktarver.com/bipolar.html">The Bipolar Lisp Programmer</a>
<ul class="org-ul">
<li>“Lisp is, like life, what you make of it.”
Lisps attract a certain kind of personality.</li>
</ul></li>

<li>A <a id="org37d3bcd">bunch of papers</a> on <a href="#org47d3d0a">polymorphic</a> (modal) type systems
for Lisp-like multi-staged languages:
<a href="http://ropas.snu.ac.kr/lib/dock/KiYiCa2005.pdf">This</a> is generic, <a href="https://www.iro.umontreal.ca/~monnier/typer-jfla2019.pdf">this</a> is ML + Scheme, <a href="https://link.springer.com/chapter/10.1007/978-1-4615-2836-4_8">this</a> for compile-time typing,
and <a href="https://hal.archives-ouvertes.fr/hal-01380792/document">this</a> one “allows the programmer to declaratively express the types of
 heterogeneous sequences in a way which is natural in the Common Lisp language.”</li>

<li><a href="http://lambda-the-ultimate.org/node/5426">Type Systems as Macros</a>
<ul class="org-ul">
<li><p>
After defining <a href="#org7d207a3"><code>declare-type</code></a> I thought the slogan “types by macros” sounded nifty;
Googling it led me to this paper where the Racket is endowed with types.
</p>

<p>
Lisp is great lol.
</p></li>
</ul></li>

<li><a href="https://twobithistory.org/2018/10/14/lisp.html">How Lisp Became God's Own Programming Language</a>
<ul class="org-ul">
<li>History and venerance of Lisp.</li>
</ul></li>

<li><a href="http://www.lispworks.com/documentation/lw51/CLHS/Body/04_bc.htm">Common Lisp HyperSpec</a> &#x2013; Type Specifiers</li>
</ul>
</div>
</div>
<div class="taglist"><a href="https://alhassy.github.io/tags.html">Tags</a>: <a href="https://alhassy.github.io/tag-types.html">types</a> <a href="https://alhassy.github.io/tag-lisp.html">lisp</a> <a href="https://alhassy.github.io/tag-program-proving.html">program-proving</a> <a href="https://alhassy.github.io/tag-emacs.html">emacs</a> </div>
<h1 class="post-title"><div class="title" style="padding-bottom: 0px"><a href="https://alhassy.github.io/PathCat.html">Graphs are to categories as lists are to monoids</a></h1></div><center> <img src="images/PathCat.png" alt="Article image"
  width="300" height="300" align="top" /> </center><br><center><strong>Abstract</strong></center>
<div id="myMathJaxStuff" style="display: none;">
<p>
We do not want the MathJax declarations to use vertical whitespace;
so we do not display their residual whitespace.
</p>

<p>
Moreover the form of MathJax declarations differs from usual LaTeX
declarations, so we iffalse&#x2026;fi these ones.
</p>

<p>
Commenting the MathJax using &lt;!&#x2013; HTML comments &#x2013;&gt;
makes the commands inaccessible elsewhere.
</p>

<p>
The alternative is to declare a <a href="https://stackoverflow.com/questions/1992114/how-do-you-create-a-hidden-div-that-doesnt-create-a-line-break-or-horizontal-sp">non-displayed ~div</a>~.
</p>

<p>
\[\newcommand{\step}[1]{ \\ = \;\; & \qquad \color{maroon}{⟨ \text{ #1 } ⟩} \\ & }\]
\[\newcommand{\stepWith}[2]{ \\ #1 \;\; & \qquad \color{maroon}{⟨ \text{ #2 } ⟩} \\ & }\]
\[\newenvironment{calc}{\begin{align*} & }{\end{align*}}\]
</p>

<p>
Having identical label references for different equations will break rendering!
</p>

<p>
eqn            := display name, then display formula.
eqnColour      := display name, then display formula, then colour
eqnLabel       := display name, then display formula, then label
eqnLabelColour := display name, then display formula, then label, then colour
eqnLabelColour := display name, then display formula, then colour, then label &#x2013; safe redundancy!
</p>

<p>
\[\newcommand{\eqnLabelColour}[4]{ \begin{equation} \color{#4}{#2} \label{#3}\tag{$\color{#4}{\text{#1}}$} \end{equation} }\]
</p>

<p>
\[\newcommand{\eqnColourLabel}[4]{ \eqnLabelColour{#1}{#2}{#4}{#3} }\]
</p>

<p>
Default equation colour is: navy
\[\newcommand{\eqnLabel}[3]{ \eqnLabelColour{#1}{#2}{#3}{navy} }\]
</p>

<p>
Default label is the display name
\[\newcommand{\eqnColour}[3]{ \eqnLabelColour{#1}{#2}{#1}{#3} }\]
</p>

<p>
\[\newcommand{\eqn}[2]{ \eqnLabel{#1}{#2}{#1} }\]
</p>

<p>
Notice that \ref{Label} and \ref{Label2} have the same displayed name,
but <b>cannot</b> have the same label!
</p>

<p>
\[\newcommand{\givens}[1]{ \color{teal}{#1} }\]
\[\newcommand{\requireds}[1]{ \color{navy}{#1} }\]
</p>

<p>
\[\def\lands{\;\land\;}\]
\[\def\landS{\quad\land\quad}\]
</p>

<p>
\[\def\impliess{\;\Rightarrow\;}\]
\[\def\impliesS{\quad\Rightarrow\quad}\]
</p>

<p>
\[\def\equivs{\;\equiv\;}\]
\[\def\equivS{\quad\equiv\quad}\]
</p>

<p>
\[\def\eqs{\;=\;}\]
\[\def\eqS{\quad=\quad}\]
</p>

<p>
\[\def\sqleqs{\;\sqsubseteq\;}\]
\[\def\sqleqS{\quad\sqsubseteq\quad}\]
</p>

<p>
\[\def\foldr{\mathsf{foldr}}\]
\[\def\edge{\mathsf{edge}}\]
\[\def\Func{\mathsf{Func}}\]
\[\def\Id{\mathsf{Id}}\]
\[\def\src{\mathsf{src}}\]
\[\def\tgt{\mathsf{tgt}}\]
\[\def\obj{\mathsf{obj}}\]
\[\def\mor{\mathsf{mor}}\]
\[\def\natTo{\overset{.}{→}}\]
\[\def\Obj{\mathsf{Obj}\,}\]
\[\def\List{\mathsf{List}\,}\]
</p>
<p>
After this, only pure latex commands should exist.
</p>

<p>
However, the whitespace they produce via MathJax is ignored
since the HTML div is not yet closed.
</p>


</div>

<style> pre.src-haskell:before { content: 'Agda' !important; }</style>

<nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#Introduction">Introduction</a>
<ul>
<li><a href="#Imports">Imports</a></li>
</ul>
</li>
<li><a href="#Graph-me-to-the-moon"><i>Graph me to the moon!</i></a>
<ul>
<li><a href="#Types-Require-Casting">Types Require Casting</a></li>
<li><a href="#Signatures">Signatures</a></li>
</ul>
</li>
<li><a href="#Cats-but-no-alligators"><i>Cats but no alligators</i></a>
<ul>
<li><a href="#Strict-Categories">Strict Categories</a></li>
<li><a href="#Familiar-𝒮ℯ𝓉-tings">Familiar <code>𝒮ℯ𝓉</code>-tings</a></li>
</ul>
</li>
<li><a href="#Endowing-Structure-with-Functors"><i>Endowing Structure with Functors</i></a>
<ul>
<li><a href="#Functor-Examples">Examples</a></li>
</ul>
</li>
<li><a href="#The-four-postulates-of-the-apocalypse"><i>The four postulates of the apocalypse</i></a>
<ul>
<li><a href="#A-very-big-𝒞𝒶𝓉">A very big <code>𝒞𝒶𝓉</code></a></li>
<li><a href="#𝒢𝓇𝒶𝓅𝒽"><code>𝒢𝓇𝒶𝓅𝒽</code></a></li>
<li><a href="#𝒞𝒶𝓉-'s-are-𝒢𝓇𝒶𝓅𝒽-'s"><code>𝒞𝒶𝓉</code>'s are <code>𝒢𝓇𝒶𝓅𝒽</code>'s</a></li>
</ul>
</li>
<li><a href="#How-natural-is-naturality"><i>How natural is naturality?</i></a>
<ul>
<li><a href="#Identification-of-possible-paths-contraction-of-choices">Identification of possible paths &#x2014;contraction of choices</a></li>
<li><a href="#No-Choice-free-will-is-only-an-illusion">No Choice &#x2013;free will is only an illusion</a></li>
<li><a href="#Natural-means-polymorphic-without-type-inspection">Natural means polymorphic without type inspection</a></li>
<li><a href="#Natural-means-no-reference-to-types">Natural means no reference to types</a></li>
<li><a href="#Natural-means-uniformly-and-simultaneously-defined">Natural means uniformly and simultaneously defined</a></li>
<li><a href="#Naturality-is-restructure-modify-commutativity">Naturality is restructure-modify commutativity</a></li>
<li><a href="#Natural-means-obvious">Natural means obvious</a></li>
<li><a href="#Naturality-is-promotion">Naturality is promotion</a></li>
<li><a href="#Naturality-as-a-rewrite-rule">Naturality as a rewrite rule</a></li>
<li><a href="#Naturality-is-just-model-morphism">Naturality is just model morphism</a></li>
<li><a href="#Naturality-yields-pattern-matching">Naturality yields pattern matching</a></li>
<li><a href="#Naturality-Examples">Examples</a></li>
</ul>
</li>
<li><a href="#Functor-Categories"><i>Functor Categories</i></a>
<ul>
<li><a href="#FunctorCats-Examples">Examples</a></li>
<li><a href="#Graphs-as-functors">Graphs as functors</a></li>
</ul>
</li>
<li><a href="#A-few-categorical-constructions">A few categorical constructions</a>
<ul>
<li><a href="#Opposite">Opposite</a></li>
<li><a href="#Products">Products</a></li>
<li><a href="#Pointwise-extensions-and-the-hom-functor">Pointwise extensions and the hom functor</a></li>
</ul>
</li>
<li><a href="#𝒮implicity-𝒰nderlies-𝒞omplexity">𝒮implicity 𝒰nderlies 𝒞omplexity</a>
<ul>
<li><a href="#Being-forgetful-from-injections-to-faithful-functors">Being forgetful: from injections to faithful functors</a></li>
<li><a href="#Of-basis-vectors">Of basis vectors</a></li>
<li><a href="#Of-adjunctions">Of adjunctions</a></li>
<li><a href="#Adjunctions-and-Representable-Functors">Adjunctions and Representable Functors</a></li>
<li><a href="#Concluding-remarks">Concluding remarks</a></li>
</ul>
</li>
<li><a href="#Designing-Paths">Designing Paths</a>
<ul>
<li><a href="#Aside-An-Adjunction-between-𝒮ℯ𝓉-and-𝒞𝒶𝓉">Aside: An Adjunction between 𝒮ℯ𝓉 and 𝒞𝒶𝓉</a></li>
<li><a href="#Equality-Combinators-for-Paths">Equality Combinators for Paths</a></li>
<li><a href="#Category-of-paths-over-a-graph">Category of paths over a graph</a></li>
<li><a href="#The-𝒫ath-to-freedom">The 𝒫ath to freedom</a></li>
</ul>
</li>
<li><a href="#Free-at-last">Free at last</a>
<ul>
<li><a href="#Defining-the-needed-operations">Defining the needed operations</a></li>
<li><a href="#Realising-the-proof-obligations">Realising the proof-obligations</a></li>
<li><a href="#Another-freedom-proof">Another freedom proof</a></li>
<li><a href="#𝒫-𝒰"><code>𝒫 ⊣ 𝒰</code></a></li>
</ul>
</li>
<li><a href="#Folds-Over-Paths">Folds Over Paths</a>
<ul>
<li><a href="#Lists-are-special-kinds-of-paths">Lists are special kinds of paths</a></li>
</ul>
</li>
<li><a href="#That-was-fun-Bye">That was fun; Bye!</a></li>
</ul>
</div>
</nav>

<p>
Numbers are the lengths of lists which are the flattenings of trees which are
the spannings of graphs.
Unlike the first three, graphs have <i>two</i> underlying types of interest
&#x2013;the vertices and the edges&#x2013; and it is getting to grips with this complexity
that we attempt to tackle by considering their ‘algebraic’ counterpart: Categories.
</p>

<p>
In our exploration of what graphs could possibly be and their relationships to lists are,
we shall <i>mechanise,</i> or <i>implement,</i> our claims since there will be many details and it is easy
to make mistakes &#x2013;moreover as a self-learning project, I'd feel more confident to make
<b>bold</b> claims when I have a proof assistant checking my work ;-)
</p>

<p>
Assuming slight familiarity with the Agda programming language, we motivate the need for
basic concepts of category theory with the aim of discussing adjunctions with
a running example of a detailed construction and proof of a free functor.
Moreover, the article contains a host of <code>exercises</code> whose solutions can be found in the
literate source file. Raw Agda code can be found <a href="https://github.com/alhassy/AgdaCheatSheet/blob/master/PathCat.agda">here</a>.
</p>

<p>
Since the read time for this article is more than two hours, excluding the interspersed
exercises, it may help to occasionally consult a some reference sheets:
</p>
<div class="org-center">
<p>
<a href="https://alhassy.github.io/CatsCheatSheet/CheatSheet.pdf"><img src="https://img.shields.io/badge/Category_Theory-CheatSheet-success?logo=gimp"></a>
<a href="https://alhassy.github.io/AgdaCheatSheet/CheatSheet.pdf"><img src="https://img.shields.io/badge/Agda-CheatSheet-success?logo=haskell"></a>
</p>
</div>

<p>
Coming from a background in order theory, I love Galois Connections and so
our categorical hammer will not be terminal objects nor limits, but rather adjunctions.
As such, <i>everything is an adjunction</i> is an apt slogan for us :-)
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">This file has been extracted from https://alhassy.github.io/PathCat/</span>
<span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Type checks with Agda version 2.6.0.</span>
</pre>
</div>
<small> <center>
<p>
( Photo by
<a href="https://unsplash.com/@miklevasilyev">Mikhail Vasilyev</a>
on <a href="https://unsplash.com/">Unsplash</a> )
</p>
</center> </small>

<div id="outline-container-org82aa0e6" class="outline-2">
<h2 id="Introduction">Introduction</h2>
<div class="outline-text-2" id="text-Introduction">
<p>
Lists give free monoids \(ℒ\, A = (\List\, A, +\!+, [])\)
&#x2014;a monoid \(𝒮 = (S, ⊕, 0_⊕)\) is a triple consisting of a set \(S\) with a binary operation
\(⊕\) on it that is associative and has a unit, \(0_⊕\).
That it is ‘free’ means that to define a structure-preserving map between monoids
\((\List\, A, +\!+, []) \,⟶\, (S, ⊕, 0_⊕)\) it suffices to only provide a map between their
carriers \(\List\, A → S\) &#x2014;freedom means that plain old maps between types freely,
at no cost or effort, give rise to maps that preserve monoid structure.
Moreover, the converse also holds and in-fact we have a bijection:
\[
  (ℒ\, A ⟶ 𝒮) \qquad≅\qquad (A ⟶ 𝒰\, 𝒮)
\]
Where we write \(𝒰\, (S, ⊕, 0_⊕) = S\) for the operation that gives us the 𝒰nderlying carrier
of a monoid.
</p>

<p>
Loosely put, one says we have an ‘adjunction’, written \(ℒ ⊣ 𝒰\).
</p>

<p>
Observe that natural numbers <code>ℕ ≅ List Unit</code> are a monoid whose operation is commutative.
By using different kinds of elements <code>A</code> &#x2013;and, importantly, still not imposing any equations&#x2013;
we lose commutativity with <code>List A</code>.
Then by generalising further to binary trees <code>BinTree A</code>, we lose associtivity and identity
are are only left with a set and an operation on it &#x2014;a structure called a ‘magma’.
</p>

<p>
This is the order that one usually learns about these inductively built structures.
One might be curious as to what the next step up is in this hierarchy of generalisations.
It is a non-inductive type called a ‘graph’ and in this note we investigate them by
comparison to lists.
Just as we shifted structures in the hierarchy, we will
move to a setting called a ‘category’ &#x2014;such are more structured than magmas
but less restrictive than monoids.
</p>

<p>
For those who know category theory, this article essentially formalises the
often seen phrase “consider the category generated by this diagram, or graph”.
Indeed every category is essentially a free category over a graph but with
additional equations that ‘confuse’ two paths thereby declaring, e.g., that
one edge is the composition of two other edges.
</p>
</div>

<div id="outline-container-org77904e6" class="outline-3">
<h3 id="Imports">Imports</h3>
<div class="outline-text-3" id="text-Imports">
<p>
In our exploration of what graphs could possibly be and their relationships to lists are,
we shall <i>mechanise</i> or <i>implement</i> our claims since there will be many details and it is easy
to make mistakes &#x2013;moreover as a self-learning project, I'd feel more confident to make
<b>bold</b> claims when I have a proof assistant checking my work ;-)
</p>

<p>
Before reading any further please ingrain into your mind that the Agda keyword
<code>Set</code> is read “type”! This disparity is a historical accident.
</p>

<p>
Since the Agda prelude is so simple, the core language doesn’t even come with Booleans or numbers by default
&#x2014;they must be imported from the standard library. This is a pleasant feature.
As a result, Agda code tends to begin with a host of imports.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">PathCat</span> <span style="color: #859900; font-weight: bold;">where</span>

<span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Level</span> using (<span style="color: #b58900; font-style: italic;">Level</span>) renaming (zero to &#8467;&#8320; ; suc to &#8467;suc ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8852;</span><span style="color: #859900; font-weight: bold;">_</span> to <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8845;</span><span style="color: #859900; font-weight: bold;">_</span>)

<span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Numbers</span>
<span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Data.Fin</span>
  using (<span style="color: #b58900; font-style: italic;">Fin</span> ; to&#8469; ; from&#8469; ; from&#8469;<span style="color: #268bd2;">&#8804;</span> ; reduce<span style="color: #268bd2;">&#8805;</span> ; inject<span style="color: #268bd2;">&#8804;</span>)
  renaming (<span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&lt;</span><span style="color: #859900; font-weight: bold;">_</span> to _f<span style="color: #268bd2;">&lt;</span><span style="color: #859900; font-weight: bold;">_</span> ; zero to fzero ; suc to fsuc)
<span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Data.Nat</span>
<span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Relation.Binary</span> using (<span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">DecTotalOrder</span>)
<span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Data.Nat.Properties</span> using(<span style="color: #268bd2;">&#8804;-</span>decTotalOrder ; <span style="color: #268bd2;">&#8804;-</span>refl)
<span style="color: #b58900;">open</span> <span style="color: #b58900; font-style: italic;">DecTotalOrder</span> <span style="color: #268bd2;">Data.Nat.Properties.&#8804;-</span>decTotalOrder

<span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Z-notation for sums</span>
<span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Data.Product</span> using (<span style="color: #b58900; font-style: italic;">&#931;</span> ; proj&#8321; ; proj&#8322; ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#215;</span><span style="color: #859900; font-weight: bold;">_</span> ; <span style="color: #859900; font-weight: bold;">_</span>,<span style="color: #859900; font-weight: bold;">_</span>)
<span style="color: #b58900; font-style: italic;">&#931;</span><span style="color: #b58900;">&#8758;&#8226;</span> <span style="color: #b58900; font-style: italic;">:</span> {a b <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Level</span>} (<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> a) (<span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> b) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> (a <span style="color: #268bd2;">&#8845;</span> b)
<span style="color: #b58900; font-style: italic;">&#931;</span><span style="color: #b58900;">&#8758;&#8226;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#931;</span>
<span style="color: #859900; font-weight: bold;">infix</span> <span style="color: #b58900;">-</span>666 <span style="color: #b58900; font-style: italic;">&#931;</span><span style="color: #268bd2;">&#8758;&#8226;</span>
<span style="color: #b58900;">syntax</span> <span style="color: #b58900; font-style: italic;">&#931;</span><span style="color: #268bd2;">&#8758;&#8226;</span> <span style="color: #b58900; font-style: italic;">A</span> (&#955; x <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span>) <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#931;</span> x <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8226;</span> <span style="color: #b58900; font-style: italic;">B</span>

<span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Equalities</span>
<span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Relation.Binary.PropositionalEquality</span> using (<span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8791;</span><span style="color: #859900; font-weight: bold;">_</span> ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8801;</span><span style="color: #859900; font-weight: bold;">_</span>)
  renaming (sym to <span style="color: #268bd2;">&#8801;-</span>sym ; refl to <span style="color: #268bd2;">&#8801;-</span>refl ; trans to <span style="color: #859900; font-weight: bold;">_</span>&#10216;<span style="color: #268bd2;">&#8801;&#8801;</span>&#10217;<span style="color: #859900; font-weight: bold;">_</span>
           ; cong to <span style="color: #268bd2;">&#8801;-</span>cong ; cong&#8322; to <span style="color: #268bd2;">&#8801;-</span>cong&#8322;
           ; subst to <span style="color: #268bd2;">&#8801;-</span>subst ; subst&#8322; to <span style="color: #268bd2;">&#8801;-</span>subst&#8322; ; setoid to <span style="color: #268bd2;">&#8801;-</span>setoid)
</pre>
</div>

<p>
Notice that we renamed transitivity to be an infix combinator.
</p>

<p>
Let us make equational-style proofs available for any type.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #859900; font-weight: bold;">_</span> {i} {<span style="color: #b58900; font-style: italic;">S</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> i} <span style="color: #859900; font-weight: bold;">where</span>
    open <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Relation.Binary.EqReasoning</span> (<span style="color: #268bd2;">&#8801;-</span>setoid <span style="color: #b58900; font-style: italic;">S</span>) public
</pre>
</div>

<p>
We intend our proofs to be sequences of formulae interleaved with
justifications for how the formulae are related. At times, the justifications
are by definition and so may be omitted, but we may want to mention them
for presentational &#x2013;pedagogical?&#x2013; purposes. Hence, we introduce the
combinator notation <code>lhs ≡⟨" by definition of something "⟩′ rhs</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Agda.Builtin.String</span>

defn<span style="color: #b58900;">-</span>chasing <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i} {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> i} (x <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span>) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">String</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">A</span>
defn<span style="color: #b58900;">-</span>chasing x reason supposedly<span style="color: #268bd2;">-</span>x<span style="color: #268bd2;">-</span>again <span style="color: #268bd2;">=</span> supposedly<span style="color: #268bd2;">-</span>x<span style="color: #268bd2;">-</span>again

<span style="color: #b58900;">syntax</span> defn<span style="color: #268bd2;">-</span>chasing x reason xish <span style="color: #268bd2;">=</span> x <span style="color: #268bd2;">&#8801;</span>&#10216; reason &#10217;<span style="color: #268bd2;">&#8242;</span> xish

<span style="color: #859900; font-weight: bold;">infixl</span> 3 defn<span style="color: #268bd2;">-</span>chasing
</pre>
</div>

<p>
While we’re making synonyms for readability, let’s make another:
</p>
<div class="org-src-container">
<pre class="src src-haskell">_even<span style="color: #b58900;">-</span>under_ <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {a b} {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> a} {<span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> b} {x y} <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#8801;</span> y <span style="color: #268bd2;">&#8594;</span> (f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span>) <span style="color: #268bd2;">&#8594;</span> f x <span style="color: #268bd2;">&#8801;</span> f y
_even<span style="color: #b58900;">-</span>under_ <span style="color: #268bd2;">=</span> &#955; eq f <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">&#8801;-</span>cong f eq
</pre>
</div>

<p>
Example usage would be to prove
<code>mor G (mor F Id) ≡ mor G Id</code> directly by <code>≡-cong (mor G) (id F)</code>
which can be written more clearly as
<code>functor F preserves-identities even-under (mor G)</code>,
while longer it is also much clearer and easier to read and understand
&#x2013;self-documenting in some sense.
</p>

<p>
Interestingly, our first calculational proof is in section 5 when
we introduced an large 𝒞𝒶𝓉egory.
</p>
</div>
</div>
</div>

<div id="outline-container-org52f311e" class="outline-2">
<h2 id="Graph-me-to-the-moon"><i>Graph me to the moon!</i></h2>
<div class="outline-text-2" id="text-Graph-me-to-the-moon">
<div class="org-center">
<p>
<i>What's a graph? Let's motivate categories!</i>
</p>
</div>
<p>
A ‘graph’ is just a parallel-pair of maps,
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900;">record</span> <span style="color: #b58900; font-style: italic;">Graph</span>&#8320; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>&#8321; <span style="color: #859900; font-weight: bold;">where</span>
  field
    <span style="color: #b58900; font-style: italic;">V</span>   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>
    <span style="color: #b58900; font-style: italic;">E</span>   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>
    src <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">E</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">V</span>
    tgt <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">E</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">V</span>
</pre>
</div>
<p>
This of-course captures the usual notion of a set of nodes <code>V</code> and a set of directed and labelled
edges <code>E</code> where an edge <code>e</code> begins at <code>src e</code> and concludes at <code>tgt e</code>.
</p>

<p>
What is good about this definition is that it can be phrased in any category: <code>V</code> and <code>E</code> are
any two objects and <code>src, tgt</code> are a parallel pair of morphisms between them.
How wonderful! We can study the notion of graphs in arbitrary categories!
&#x2014;This idea will be made clearer when categories and functors are formally introduced.
</p>

<p>
However, the notion of structure-preserving map between graphs, or ‘graph-maps’ for short,
then becomes:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900;">record</span> _&#119970;<span style="color: #268bd2;">&#10230;</span>&#8320;<span style="color: #859900; font-weight: bold;">_</span> (<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span>&#8320;) <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>&#8321; <span style="color: #859900; font-weight: bold;">where</span>
  open <span style="color: #b58900; font-style: italic;">Graph</span>&#8320;
  field
    vertex <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span>(<span style="color: #b58900; font-style: italic;">G</span>) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">V</span>(<span style="color: #b58900; font-style: italic;">H</span>)
    edge   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">E</span>(<span style="color: #b58900; font-style: italic;">G</span>) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">E</span>(<span style="color: #b58900; font-style: italic;">H</span>)
    src<span style="color: #268bd2;">-</span>preservation <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> e <span style="color: #268bd2;">&#8594;</span> src(<span style="color: #b58900; font-style: italic;">H</span>) (edge e) <span style="color: #268bd2;">&#8801;</span>  vertex (src(<span style="color: #b58900; font-style: italic;">G</span>) e)
    tgt<span style="color: #268bd2;">-</span>preservation <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> e <span style="color: #268bd2;">&#8594;</span> tgt(<span style="color: #b58900; font-style: italic;">H</span>) (edge e) <span style="color: #268bd2;">&#8801;</span>  vertex (tgt(<span style="color: #b58900; font-style: italic;">G</span>) e)
</pre>
</div>
<p>
( The fancy 𝒢 and ⟶ are obtained in Agda input mode by <code>\McG</code> and <code>\--&gt;</code>, respectively. )
</p>

<p>
This is a bit problematic in that we have two proof obligations and at a first glance it is not
at all clear their motivation besides ‘‘structure-preserving’’.
</p>

<p>
However, our aim is in graphs in usual type theory, and as such we can use a definition that is
equivalent in this domain: A graph is a
type <code>V</code> of vertices and a ‘type’ <code>v ⟶ v’</code> of edges for each pair of vertices <code>v</code> and <code>v’</code>.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8216;small graphs&#8217; , since we are not using levels</span>
<span style="color: #b58900;">record</span> <span style="color: #b58900; font-style: italic;">Graph</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>&#8321; <span style="color: #859900; font-weight: bold;">where</span>
  field
    <span style="color: #b58900; font-style: italic;">V</span>    <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>
    <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">V</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span>

<span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">i.e., Graph &#8776; &#931; V &#8758; Set &#8226; (V &#8594; V)</span>
<span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Graphs are a dependent type!</span>
</pre>
</div>

<p>
Now the notion of graph-map, and the meaning of structure-preserving, come to the forefront:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900;">record</span> <span style="color: #b58900; font-style: italic;">GraphMap</span> (<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span>) <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>&#8321; <span style="color: #859900; font-weight: bold;">where</span>
    private
      open <span style="color: #b58900; font-style: italic;">Graph</span> using (<span style="color: #b58900; font-style: italic;">V</span>)
      <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span>g_ <span style="color: #268bd2;">=</span> Graph._<span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">G</span>
      <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span>h_ <span style="color: #268bd2;">=</span> Graph._<span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">H</span>
    field
      ver  <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span>(<span style="color: #b58900; font-style: italic;">G</span>) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">V</span>(<span style="color: #b58900; font-style: italic;">H</span>)                                <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">vertex morphism</span>
      edge <span style="color: #b58900; font-style: italic;">:</span> {x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span>(<span style="color: #b58900; font-style: italic;">G</span>)} <span style="color: #268bd2;">&#8594;</span> (x <span style="color: #268bd2;">&#10230;</span>g y) <span style="color: #268bd2;">&#8594;</span> (ver x <span style="color: #268bd2;">&#10230;</span>h ver y) <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">arrow preservation</span>

<span style="color: #b58900;">open</span> <span style="color: #b58900; font-style: italic;">GraphMap</span>
</pre>
</div>

<p>
Note <code>edge</code> essentially says that <code>mor</code> ‘shifts’, or ‘translates’, types
<code>x ⟶g y</code> into types <code>ver x ⟶h ver y</code>.
</p>

<p>
While equivalent, this two-piece definition is preferable over the four-piece one given
earlier since it means less proof-obligations and less constructions in general, but the same
expressiblity. Yay!
</p>

<p>
Before we move on, let us give an example of a simple chain-graph.
For clarity, we present it in both variations.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">embedding: j &lt; n &#8658; j &lt; suc n</span>
`<span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{n} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Fin</span> n <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Fin</span> (suc n)
` j <span style="color: #268bd2;">=</span> inject<span style="color: #268bd2;">&#8804;</span> j (<span style="color: #268bd2;">&#8804;-</span>step <span style="color: #268bd2;">&#8804;-</span>refl) <span style="color: #859900; font-weight: bold;">where</span> open <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Data.Nat.Properties</span> using (<span style="color: #268bd2;">&#8804;-</span>step)
</pre>
</div>
<p>
This' an example of a ‘forgetful functor’, keep reading!
</p>

<div class="org-src-container">
<pre class="src src-haskell">[<span style="color: #859900; font-weight: bold;">_</span>]&#8320; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#8469;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Graph</span>&#8320;
[ n ]&#8320; <span style="color: #268bd2;">=</span> record
    { <span style="color: #b58900; font-style: italic;">V</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Fin</span> (suc n)                  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8776; {0, 1, ..., n - 1, n}</span>
    ; <span style="color: #b58900; font-style: italic;">E</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Fin</span> n                        <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8776; {0, 1, ..., n - 1}</span>
    ; src <span style="color: #268bd2;">=</span> &#955; j <span style="color: #268bd2;">&#8594;</span> ` j
    ; tgt <span style="color: #268bd2;">=</span> &#955; j <span style="color: #268bd2;">&#8594;</span> fsuc j
    }
</pre>
</div>
<p>
That is, we have <code>n+1</code> vertices named <code>0, 1, …, n</code> and <code>n</code> edges named <code>0, 1, …, n-1</code>
with one typing axiom being <code>j : j ⟶ (j+1)</code>. Alternatively,
</p>

<div class="org-src-container">
<pre class="src src-haskell">[<span style="color: #859900; font-weight: bold;">_</span>] <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#8469;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Graph</span>
[ n ] <span style="color: #268bd2;">=</span> record {<span style="color: #b58900; font-style: italic;">V</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Fin</span> (suc n) ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> &#955; x y <span style="color: #268bd2;">&#8594;</span> fsuc x <span style="color: #268bd2;">&#8801;</span> ` y }
</pre>
</div>
</div>

<div id="outline-container-org3097e40" class="outline-3">
<h3 id="Types-Require-Casting">Types Require Casting</h3>
<div class="outline-text-3" id="text-Types-Require-Casting">
<p>
However, we must admit that a slight downside of the typed approach
&#x2013;the two-piece definition&#x2013; is now
we may need to use the following ‘shifting’ combinators:
They shift, or slide, the edge types.
</p>

<pre class="example">
-- casting
_⟫_ : ∀{x y y’} →  (x ⟶ y) → (y ≡ y’) → (x ⟶ y’)
e ⟫ ≡-refl = e

-- Casting leaves the edge the same, only type information changes
≅-⟫ : ∀{x y y’} {e : x ⟶ y} (y≈y’ : y ≡ y’) → e ≅ (e ⟫ y≈y’)
≅-⟫ ≡-refl = ≅-refl
</pre>

<p>
Such is the cost of using a typed-approach.
</p>

<p>
Even worse, if we use homogeneous equality then we’d have the ghastly operator
</p>
<pre class="example">
≡-⟫ : ∀{x y y’} {e : x ⟶ y} (y≈y’ : y ≡ y’) → e ⟫ y≈y’ ≡ (≡-subst (λ ω → x ⟶ ω) y≈y’ e)
</pre>

<p>
However, it seems that our development does not even make use of these.
Lucky us! However, it is something to be aware of.
</p>
</div>
</div>

<div id="outline-container-orgbe82e3c" class="outline-3">
<h3 id="Signatures">Signatures</h3>
<div class="outline-text-3" id="text-Signatures">
<p>
A <i>signature</i> consists of ‘sort symbols’ and ‘function symbols’ each of which is associated source-sorts
and a target-sort &#x2013;essentially it is an interface in the programming sense of the word thereby providing
a lexicon for a language.
A <i>model</i> or <i>algebra</i> of a language is an interpretation of the sort symbols as sets and an interpretation of the
function symbols as functions between those sets; i.e., it is an <i>implementation</i> in programming terms.
Later you may note that instead of sets and functions we may use the objects and morphisms of
a fixed category instead, and so get a model in that category.
</p>

<div class="org-center">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left"><span class="underline">Math</span></td>
<td class="org-left">≅</td>
<td class="org-left"><span class="underline">Coding</span></td>
</tr>

<tr>
<td class="org-left">Signature</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Interface, record type, class</td>
</tr>

<tr>
<td class="org-left">Algebra</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Implementation, instance, object</td>
</tr>

<tr>
<td class="org-left">Language Term</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Syntax</td>
</tr>

<tr>
<td class="org-left">Interpretation</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Semantics, i.e., an implementation</td>
</tr>
</tbody>
</table>
</div>

<p>
Formally, one-sorted signatures are defined:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Data.Vec</span>
  using (<span style="color: #b58900; font-style: italic;">Vec</span>)
  renaming (<span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8759;</span><span style="color: #859900; font-weight: bold;">_</span> to <span style="color: #859900; font-weight: bold;">_</span>,,<span style="color: #859900; font-weight: bold;">_</span> ; <span style="color: #b58900; font-style: italic;">[]</span> to nil) <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">, already in use for products :/</span>

<span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">one sorted</span>
<span style="color: #b58900;">record</span> <span style="color: #b58900; font-style: italic;">Signature</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
    field
     <span style="color: #b58900; font-style: italic;">&#119977;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#8469;</span>        <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">How many function symbols there are</span>
     ar <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Vec</span> <span style="color: #b58900; font-style: italic;">&#8469;</span> <span style="color: #b58900; font-style: italic;">&#119977;</span> <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Their arities: lookup i ar == arity of i-th function symbol</span>

<span style="color: #b58900;">open</span> <span style="color: #b58900; font-style: italic;">Signature</span> &#10627;<span style="color: #268bd2;">...</span>&#10628; <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">&#119977; now refers to the number of function symbols in a signature</span>
</pre>
</div>

<p>
For example, the signature of monoids consists of a single sort symbol <code>C</code> &#x2013;which can be
interpreted as the carrier of the monoid&#x2013; and two function symbols <code>m , u</code>
&#x2013;which can be interpreted as the monoid multiplication and unit&#x2013; with source-target
sort lists <code>((),C) , ((C,C), C)</code> &#x2014;some would notate this by <code>u :→ C , m : C × C → C</code>.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">MonSig</span> <span style="color: #b58900;">:</span> <span style="color: #b58900; font-style: italic;">Signature</span>
<span style="color: #b58900; font-style: italic;">MonSig</span> <span style="color: #268bd2;">=</span> record { <span style="color: #b58900; font-style: italic;">&#119977;</span> <span style="color: #268bd2;">=</span> 2 ; ar <span style="color: #268bd2;">=</span> 0 ,, 2 ,, nil }
<span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">unit u : X&#8304; &#8594; X and multiplication m : X&#178; &#8594; X</span>
</pre>
</div>

<p>
Generalising on monoids by typing the multiplication we obtain
the signature of categories which consists of three sort symbols <code>O, A, C</code> &#x2013;which can be
interepreted as objects, arrows, and composable pairs of arrows&#x2013; and four function symbols
<code>⨾ , src, tgt, id</code> with source-target sort lists <code>(C,A) , (A,O) , (A,O) , (O,A)</code>
&#x2014;notice that only a language of symbols
has been declared without any properties besides those of typing. If we discard <code>C, ⨾, id</code> we
then obtain the signature of graphs. Without knowing what categories are, we have seen that their
signatures are similar to both the graph and monoid signatures and so expect their logics to
also be similar. Moreover we now have a few slogans,
\[\color{green}{\text{Categories are precisely typed monoids!}}\]
\[\color{green}{\text{Categories are precisely graphs with a monoidal structure!}}\]
\[\color{green}{\text{Categories are precisely coherently constructive lattices!}}\]
</p>

<p>
( The last one is completely unmotivated from our discussion, but it's a good place for the slogan and
  will be touched on when we look at examples of categories. )
</p>

<p>
A signature can be visualised in the plane by associating a dot for each sort symbol and an arrow
for each function symbol such that the arrow has a tail from each sort in the associated function
symbols source sorts list and the end of the arrow is the target sort of the sort symbol.
That is, a signature can be visualised as a hyper-graph.
</p>

<ul class="org-ul">
<li>A signature whose function symbols each have only one sort symbol for source-sorts is called a
‘graph signature’ since it corresponds to &#x2014;or can be visualised as&#x2014; a graph.</li>

<li>Then a model of a graph (signature) <code>𝒢</code> is an interpreation/realisation of the graph’s vertices
as sets and the graph’s edges as functions between said sets.</li>

<li>A model of <code>𝒢</code> is nothing more than a graph morphism
<code>𝒢 ⟶ 𝒮e𝓉</code>, where <code>𝒮e𝓉</code> is the graph with vertices being sets and edges being functions.</li>
</ul>

<p>
Notice that a <code>Graph₀</code> is precisely a model of the graph <code>• ⇉ •</code>, which consists of
two vertices and two edges from the first vertex to the second vertex.
We will return to this point ;-)
</p>

<p>
Before we move on, it is important to note that a signature does not capture any
constraints required on the symbols &#x2013;e.g., a monoid is the monoid signature as well
as the constraint that the 2-arity operation is associative and the 0-arity operation is its unit.
More generally, a <i>specification</i> consists of a signature declaring symbols of interest,
along with a set of sentences over it that denote axioms or constraints.
In programming parlance, this is an interface consisting of types and functions
that need to be provided and implemented, along with constraints that are usually documented in comments.
Unsurprisingly, models of specifications also form categories.
</p>
</div>
</div>
</div>

<div id="outline-container-org3a3fa37" class="outline-2">
<h2 id="Cats-but-no-alligators"><i>Cats but no alligators</i></h2>
<div class="outline-text-2" id="text-Cats-but-no-alligators">
<p>
In this section we introduce the notion of a ‘‘poor-man’s category’’ along with the notion of
structure preserving transformations and structure preserving transformations between such
transformations. The former are called <i>functors</i> and the latter are known as <i>natural transformations</i>
and are considered one of the most important pieces of the fundamentals of category theory;
as such, we discuss them at length.
Afterwards, we relate this section back to our motivating discussion of graphs.
</p>
</div>

<div id="outline-container-orge0ee361" class="outline-3">
<h3 id="Strict-Categories">Strict Categories</h3>
<div class="outline-text-3" id="text-Strict-Categories">
<p>
A category, like a monoid, is a a few types and operations for which some equations hold.
However, to discuss equations a notion of equality is needed and rather than enforce one
outright it is best to let it be given. This is a ‘set’ in constructive mathematics:
A type with an <code>E</code>-quivalence relation on it &#x2014;also called a <i>setoid</i> or an <code>E</code>-set.
However, then the structure must have a few added axioms: The operations must be congruences,
i.e., preserve the equivalence relation, and structure-preserving maps must also be congruences.
</p>

<p>
For our purposes we will use propositional equality and point-wise propositional equality,
and as such most of the proofs fall out of the fact that propositional equality is an equivalence.
However, this setoid structure becomes a bit of a noise, without providing any real insight for our uses,
and the issues of equivalences will be a distraction from the prime focus.
Instead, for our two cases where we use point-wise propositional,
we will postulate two forms of extensionality. Without question this is not a general approach
&#x2014;then again, our aim is not to develop a library for category theory, which has already been
done so elegantly by Kahl who calls it the <a href="http://relmics.mcmaster.ca/RATH-Agda/RATH-Agda-2.0.0.pdf">RATH-Agda</a> project.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #859900; font-weight: bold;">where</span> <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">An anyonomous module for categorial definitions</span>

 record <span style="color: #b58900; font-style: italic;">Category</span> {i j <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Level</span>} <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> (&#8467;suc (i <span style="color: #268bd2;">&#8845;</span> j)) <span style="color: #859900; font-weight: bold;">where</span>
  <span style="color: #859900; font-weight: bold;">infixr</span> 10 <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span>
  field
    <span style="color: #b58900; font-style: italic;">Obj</span>      <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> i
    <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span>     <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> j
    <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span>      <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span>} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">C</span>
    assoc    <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #b58900; font-style: italic;">D</span>} {f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">B</span>}{g <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">C</span>} {h <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">D</span>} <span style="color: #268bd2;">&#8594;</span> (f <span style="color: #268bd2;">&#10814;</span> g) <span style="color: #268bd2;">&#10814;</span> h <span style="color: #268bd2;">&#8801;</span> f <span style="color: #268bd2;">&#10814;</span> (g <span style="color: #268bd2;">&#10814;</span> h)
    <span style="color: #b58900; font-style: italic;">Id</span>       <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span>} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">A</span>
    leftId   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span>} {f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">B</span>} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #268bd2;">&#10814;</span> f <span style="color: #268bd2;">&#8801;</span> f
    rightId  <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span>} {f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">B</span>} <span style="color: #268bd2;">&#8594;</span> f <span style="color: #268bd2;">&#10814;</span> <span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #268bd2;">&#8801;</span> f

 open <span style="color: #b58900; font-style: italic;">Category</span> using (<span style="color: #b58900; font-style: italic;">Obj</span>)
 open <span style="color: #b58900; font-style: italic;">Category</span> &#10627;<span style="color: #268bd2;">...</span>&#10628; hiding (<span style="color: #b58900; font-style: italic;">Obj</span>)

 <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Some sugar for times when we must specify the category</span>
 <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8220;colons associate to the right&#8221; ;-)</span>

 arr <span style="color: #268bd2;">=</span> Category._<span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span>
 syntax arr <span style="color: #b58900; font-style: italic;">&#119966;</span> x y  <span style="color: #268bd2;">=</span>  x <span style="color: #268bd2;">&#10230;</span> y <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8220;ghost colon&#8221;</span>

 cmp <span style="color: #268bd2;">=</span> Category._<span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span>
 syntax cmp <span style="color: #b58900; font-style: italic;">&#119966;</span> f g  <span style="color: #268bd2;">=</span>  f <span style="color: #268bd2;">&#10814;</span> g <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8220;ghost colon&#8221;</span>
</pre>
</div>

<p>
However, similar to nearly everything else in this document, we can leave the setoid approach as an exercise
for the reader, which of course has solutions being in the literate source.
</p>

<p>
Moreover, lest you’re not convinced that my usage of extensionality is at all acceptable,
then note that others have used it to simplify their presentations; e.g.,
<a href="http://cs.ioc.ee/~tarmo/papers/jfr14.pdf">Relative monads formalised</a>.
Such ‘appeal to authority’ is for the lazy reader who dares not think for him- or her-self,
otherwise one ought to read up on the <a href="https://ncatlab.org/nlab/show/principle+of+equivalence">evils</a>
of using equality instead of equivalence relations so as to understand
<a href="http://www.math.harvard.edu/~mazur/preprints/when_is_one.pdf">when one thing is really another</a>.
</p>

<p>
The diligent reader may be interested to know that Maarten Fokkinga has written a very
<a href="http://maartenfokkinga.github.io/utwente/mmf92b.pdf">gentle introduction to category theory using the calculational approach</a>; I highly recommend it!
</p>

<p>
Anyhow, in place of strict equality, one uses categorical isomorphism instead.
</p>
<div class="org-src-container">
<pre class="src src-haskell"> open <span style="color: #b58900; font-style: italic;">Category</span> using (<span style="color: #b58900; font-style: italic;">Obj</span>) public

 record <span style="color: #b58900; font-style: italic;">Iso</span> {i} {j} (<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j}) (<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>) <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> j <span style="color: #859900; font-weight: bold;">where</span>
   private <span style="color: #859900; font-weight: bold;">instance</span> <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> ; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>
   field
     to   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">B</span>
     from <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">A</span>
     lid  <span style="color: #b58900; font-style: italic;">:</span> to <span style="color: #268bd2;">&#10814;</span> from <span style="color: #268bd2;">&#8801;</span> <span style="color: #b58900; font-style: italic;">Id</span>
     rid  <span style="color: #b58900; font-style: italic;">:</span> from <span style="color: #268bd2;">&#10814;</span> to <span style="color: #268bd2;">&#8801;</span> <span style="color: #b58900; font-style: italic;">Id</span>

 syntax <span style="color: #b58900; font-style: italic;">Iso</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8773;</span> <span style="color: #b58900; font-style: italic;">B</span> within <span style="color: #b58900; font-style: italic;">&#119966;</span>
</pre>
</div>

<p>
Interestingly, we shall later encounter a rather large category named
𝒞𝒶𝓉 possessing the special property of being a <a href="https://ncatlab.org/nlab/show/2-category">“2-Category”</a>:
It has morphisms between objects, as expected, which are now called “1-morphisms”,
and it has morphisms between 1-morphisms, also called “2-morphisms”.
</p>

<p>
That is, it has morphisms between morphisms.
</p>

<p>
Above we argued that equality should be deferred in favour of isomorphism
at the morphism level. Hence, in a 2-Category, it is only reasonable to defer
an equation involving objects to be up to isomorphism of 2-morphisms
&#x2014;this is then called an “equivalence”.
</p>
<pre class="example">
ℒHS ≃ ℛHS  ⇔  Σ F ∶ ℒHS ⟶ ℛHS • Σ G ∶ ℛHS ⟶ ℒHS • F ⨾ G ≅ G ⨾ F ≅ Id
</pre>

<p>
Hence when it comes to categories themselves, one usually speaks in terms of
equivalences rather than isomorphisms.
</p>

<p>
For example, let 𝒫𝒶𝓇 be the supercategory of 𝒮e𝓉 with morphisms being ‘partial
functions’ <code>(A ⟶ B) = (A → B + 𝟙)</code> where the extra element of <code>𝟙 = { * }</code> represents
‘undefined’ &#x2014;also known as the <code>Partial</code>, <code>Option</code>, or <code>Maybe</code> monads.  Moreover,
let 𝒫𝒮ℯ𝓉 be the category of sets with an elected point.  Then, <code>𝒫𝒶𝓇 ≃ 𝒫𝒮e𝓉</code> is
witnessed by <code>(A ⟶ B) ↦ ( (A + 𝟙, *) ⟶ (B + 𝟙, *) )</code> and conversely
<code>( (A , a) ⟶ (B , b) ) ↦ ( A - a ⟶ B - b)</code> where
 <br> <code>X - x ≡ Σ y ∶ X • ¬(x ≡
y)</code>. Exercise: Work out the remaining details for the equivalence.
</p>
</div>
</div>

<div id="outline-container-org72a540b" class="outline-3">
<h3 id="Familiar-𝒮ℯ𝓉-tings">Familiar <code>𝒮ℯ𝓉</code>-tings</h3>
<div class="outline-text-3" id="text-Familiar-𝒮ℯ𝓉-tings">
<p>
Let us give some elementary examples of the notion of a category to exhibit its ubiquity.
</p>
</div>

<div id="outline-container-org3875cf6" class="outline-4">
<h4 id="𝒮ℯ𝓉's">𝒮ℯ𝓉's</h4>
<div class="outline-text-4" id="text-𝒮ℯ𝓉's">
<p>
The collection of small, say level <code>i</code>, types and functions between them and usual function composition
with usual identity form a category and this is not at all difficult to see:
</p>
<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #859900; font-weight: bold;">instance</span>
  <span style="color: #b58900; font-style: italic;">&#119982;e&#120009;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Category</span> {&#8467;suc i} {i} <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">this is a &#8216;big&#8217; category</span>
  <span style="color: #b58900; font-style: italic;">&#119982;e&#120009;</span> {i} <span style="color: #268bd2;">=</span> record {
      <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Set</span> i
    ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> &#955; <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#8594;</span> (<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span>)
    ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> &#955; f g <span style="color: #268bd2;">&#8594;</span> (&#955; x <span style="color: #268bd2;">&#8594;</span> g (f x))
    ; assoc <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
    ; <span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #268bd2;">=</span> &#955; x <span style="color: #268bd2;">&#8594;</span> x
    ; leftId <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
    ; rightId <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
    }
</pre>
</div>
<p>
Sadly, this category is traditionally used to motivate constructions in arbitrary categories
and as such people usually think of objects in an arbitrary category as nothing more than
sets with extra datum &#x2014;which is completely false.
</p>

<p>
For example, the category <code>Div</code> consists of objects <i>and</i> arrows both being numbers ℕ
and there is an arrow \(k : m → n\) precisely when <code>k × m = n</code>, so that an arrow is a
constructive witness that \(m\) divides \(n\). Notice that besides ℕ, no sets nor functions
were involved in the making of this useful number-theoretic category.
</p>
</div>
</div>

<div id="outline-container-org20d552f" class="outline-4">
<h4 id="Sets-are-trivial-categories">Sets are trivial categories</h4>
<div class="outline-text-4" id="text-Sets-are-trivial-categories">
<p>
Recall that a type, or set, is nothing more than a specified collection of values.
</p>

<p>
Every set is also a category: There is a formal syntactic object associated with each element, the only morphisms are (formal)
identities, and composition is constantly a syntactic identity.
Some define a set to be a category with only identity morphisms; also called a
‘discrete category’ when one wants to distance themself from set theory ;)
&#x2014;less loosely, a discrete category over a type <code>S</code> has <code>Obj = S</code> and <code>(x ⟶ y) = (x ≡ y)</code>,
where the equivalence is classical, having two possible members <i>true</i> or <i>false</i>.
</p>

<p>
Discrete categories are quite an important space for <a href="http://homotopytypetheory.org/">hott</a> people &#x2026;
that’s right, attractive people are interested in these things.
</p>

<p>
Observe that all arrows are invertible! &#x2014;due to the symmetry of equality.
Categories with this property are known as <i>groupoids</i>.
</p>
</div>
</div>

<div id="outline-container-orgde07e52" class="outline-4">
<h4 id="Categories-are-typed-monoids">Categories are typed monoids</h4>
<div class="outline-text-4" id="text-Categories-are-typed-monoids">
<p>
Recall that a monoid <code>(M, ⊕, e)</code> is a type <code>M</code> with an associative operation <code>⊕ : M × M → M</code>
that has a unit <code>e</code>.
</p>

<p>
Every monoid is also a category: There is one object, call it <code>★</code>, the morphisms are the monoid
elements, and composition is the monoid operation.
&#x2014;less loosely, for a monoid <code>(M, ⊕, e)</code> we take <code>Obj = {★} , _⟶_ = M</code>.
</p>

<p>
In fact, some would define a monoid to be a one-object category!
&#x2013;I'm looking at you <a href="https://books.google.ca/books/about/Categories_Allegories.html?id=fCSJRegkKdoC&amp;printsec=frontcover&amp;source=kp_read_button&amp;redir_esc=y#v=onepage&amp;q&amp;f=false">Freyd &amp; Scedrov</a> =)
</p>
</div>
</div>

<div id="outline-container-orgbeab04a" class="outline-4">
<h4 id="Categories-are-coherently-preordered-sets">Categories are coherently preordered sets</h4>
<div class="outline-text-4" id="text-Categories-are-coherently-preordered-sets">
<p>
<a href="http://www.cs.utexas.edu/~EWD/ewd11xx/EWD1102.PDF">Recall</a> that a preordered set, or preset, is a type <code>P</code> with a relation <code>≤</code> on
it that satisfies <i>indirect inequality from above</i>:
\[
  ∀ x , y •\qquad x ≤ y \quad⇔\quad (∀ z •\; y ≤ z ⇒ x ≤ z)
\]
Equivalently, if it satisfies <i>indirect equality from below</i>:
\[ ∀ x , y •\qquad x ≤ y \quad⇔\quad (∀ z •\; z ≤ x ⇒ z ≤ y) \]
If we also have \(∀ x , y •\; x ≤ y \,∧\, y ≤ x \;⇒\; x = y\),
then we say <code>(P, ≤)</code> is a ‘poset’ or an ‘ordered set’.
</p>

<p>
Every (pre)ordered set is also a category:
The objects are the elements,
the morphisms are the order-relations,
identities are the relfexitivity of <code>≤</code>,
and composition is transitivity of <code>≤</code>.
To see this more clearly, suppose you have a group
\((M, ⊕, \_{}⁻¹, e)\) and you define \(x ≤ y \;⇔\; (∃ m : M •\; m ⊕ x = y)\)
then the this is a preorder whose induced category has a morphism
\(m : x → y\) precicely when \(m ⊕ x = y\)
&#x2013;now sit down and define the remaining categorical structure of this
‘constructive’ preorder associated to the group.
</p>

<p>
Traditionally, classically, the relation <code>≤</code> is precicely a function <code>P × P ⟶ 𝔹 = {true, flase}</code>
and thus there is at-most one morphism between any two objects
&#x2013;consequently, categories with this property are called <i>poset categories</i>.
</p>

<p>
In the constructive setting, the relation <code>≤</code> is typed <code>P × P → Set</code> and then
for a preset <code>(P, ≤)</code> we take <code>Obj = P, _⟶_ = a ≤ b</code> and insist
on ‘proof-irrelevance’ <code>∀ {a b} (p q : a ≤ b) → p ≡ q</code> so that there is at most one morphism
between any two objects.
The restriction is not needed if we were using actual categories-with-setoids since then we would
<i>define</i> morphism equality to be  <br>
<code>((a, b, p) ≈ (a’, b’, q) )  =  (a ≡ a’  ×  b ≡ b’)</code>.
</p>

<p>
Observe that in the case we have a poset, every isomorphism is an equality:
\[
  ∀ x, y •\qquad x ≅ y ⇔ x ≡ y
\]
Categories with this property are called <i>skeletal</i>.
Again, hott people like this; so much so, that they want it, more-or-less, to be a
<a href="http://arxiv.org/abs/1302.4731">foundational axiom</a>!
</p>

<p>
Poset categories are a wonderful and natural motivator for many constructions and definitions in
category theory. This idea is so broad-reaching that it would not be an exaggeration to think of
<a href="http://www.cs.nott.ac.uk/~psarb2/papers/abstract.html#CatTheory">categories as coherently constructive lattices</a>!
</p>
</div>
</div>

<div id="outline-container-orgd39b60a" class="outline-4">
<h4 id="Groupoids">Groupoids</h4>
<div class="outline-text-4" id="text-Groupoids">
<p>
Equivalence relations are relations that are symmetric, reflexive, and transitive.
Alternatively, they are preorder categories where every morphism is invertible &#x2014;this is the
symmetry property. But categories whose morphisms are invertible are groupoids!
</p>

<p>
Hence, groupoids can be thought of as generalized equivalence relations.
Better yet, as “constructive” equivalence relations: there might be more than one morphism/construction
witnessing the equivalence of two items.
</p>

<p>
Some insist that a <i>true</i> ‘set’ is a type endowed with an equivalence relation, that is a setoid.
However, since groupoids generalise equivalence relations, others might insist on a true set to be
a "groupoid". However, in the constructive setting of dependent-type theory, these notions
coincide!
</p>
</div>
</div>

<div id="outline-container-org1f67498" class="outline-4">
<h4 id="Rule-of-Thumb">Rule of Thumb</h4>
<div class="outline-text-4" id="text-Rule-of-Thumb">
<p>
It’s been said that the aforementioned categories should be consulted whenever one learns a new
concept of category theory.
Indeed, these examples show that a category is a generalisation of a system of processes,
a system of compositionality, and an ordered system.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orga5bf64e" class="outline-2">
<h2 id="Endowing-Structure-with-Functors"><i>Endowing Structure with Functors</i></h2>
<div class="outline-text-2" id="text-Endowing-Structure-with-Functors">
<p>
Now the notion of structure-preserving maps, for categories, is just that of graphs
but with attention to the algebraic portions as well.
</p>

<div class="org-src-container">
<pre class="src src-haskell"> record <span style="color: #b58900; font-style: italic;">Functor</span> {i j k l} (<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j}) (<span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {k} {l})
  <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> (&#8467;suc (i <span style="color: #268bd2;">&#8845;</span> j <span style="color: #268bd2;">&#8845;</span> k <span style="color: #268bd2;">&#8845;</span> l)) <span style="color: #859900; font-weight: bold;">where</span>
  private
    <span style="color: #859900; font-weight: bold;">instance</span>
      <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> ;  <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>
      <span style="color: #b58900; font-style: italic;">&#119967;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> ;  <span style="color: #b58900; font-style: italic;">&#119967;</span><span style="color: #268bd2;">&#8242;</span>  <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>
  field
    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Usual graph homomorphism structure: An object map, with morphism preservation</span>
    obj   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>
    mor   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#10230;</span> y <span style="color: #268bd2;">&#8594;</span> obj x <span style="color: #268bd2;">&#10230;</span> obj y
    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Interaction with new algebraic structure: Preservation of identities &amp; composition</span>
    id    <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} <span style="color: #268bd2;">&#8594;</span> mor (<span style="color: #b58900; font-style: italic;">Id</span> {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">=</span> x}) <span style="color: #268bd2;">&#8801;</span> <span style="color: #b58900; font-style: italic;">Id</span>       <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">identities preservation</span>
    comp  <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x y z} {f <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#10230;</span> y} {g <span style="color: #b58900; font-style: italic;">:</span> y <span style="color: #268bd2;">&#10230;</span> z} <span style="color: #268bd2;">&#8594;</span> mor (f <span style="color: #268bd2;">&#10814;</span> g) <span style="color: #268bd2;">&#8801;</span> mor f <span style="color: #268bd2;">&#10814;</span> mor g

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Aliases for readability</span>
  functor_preserves<span style="color: #268bd2;">-</span>composition <span style="color: #268bd2;">=</span> comp
  functor_preserves<span style="color: #268bd2;">-</span>identities  <span style="color: #268bd2;">=</span> id

 open <span style="color: #b58900; font-style: italic;">Functor</span> public hiding (id ; comp)
</pre>
</div>

<p>
For a functor <code>F</code>, it is common practice to denote both <code>obj F</code> and <code>mor F</code> by <code>F</code> and this is usually
not an issue since we can use type inference to deduce which is meant. However, in the Agda formalization
we will continue to use the names <code>mor , obj</code>. Incidentally in the Haskell community, <code>mor</code>
is known as <code>fmap</code> but we shall avoid that name or risk asymmetry in the definition of
a functor, as is the case in Haskell which turns out to be pragmatically useful.
</p>

<p>
A functor can be thought of as endowing an object with some form of structure
&#x2014;since categories are intrinsically structureless in category theory&#x2014;
and so the morphism component of a functor can be thought of as preserving relations:
<code>f : a ⟶ b ⇒ F f : F a ⟶ F b</code> can be read as, ‘‘if <code>a</code> is related to <code>b</code> (as witnessed by <code>f</code>)
then their structured images are also related (as witness by <code>F f</code>)’’.
Recall the category <code>Div</code> for constructive divisibility relationships ;-)
</p>
</div>

<div id="outline-container-orgfc45a93" class="outline-3">
<h3 id="Functor-Examples">Examples</h3>
<div class="outline-text-3" id="text-Functor-Examples">
<p>
A functor among monoids &#x2013;construed as categories&#x2013; is just a monoid homomorphism;
i.e., an identity and multiplication preserving function of the carriers.
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><i>(M, ⊕, e) ⟶ (N, ⊗, d)</i></td>
</tr>

<tr>
<td class="org-left">=</td>
<td class="org-left"><i>Σ h ∶ M → N • ∀ x,y • h(x ⊕ y) = h x ⊗ h y ∧ h e = d</i></td>
</tr>
</tbody>
</table>

<p>
By induction, <code>h</code> preserves all finite ⊕-multiplication and, more generally,
functors preserve finite compositions:
\[ F (f₀ ⨾ f₁ ⨾ ⋯ ⨾ fₙ) \;\;=\;\; F\,f₀ ⨾ F\,f₁ ⨾ ⋯ ⨾ F\,fₙ \]
Cool beans :-)
</p>

<p>
In the same way, sit down and check your understanding!
</p>
<ul class="org-ul">
<li>A functor among discrete categories is just a function of the associated sets.</li>
<li>A functor among poset categories is an order-preserving function.</li>
</ul>

<p>
Two examples of functors from a poset (category) to a monoid (category):
</p>

<ul class="org-ul">
<li><code>monus : (ℕ, ≤) ⟶ (ℕ,+, 0)</code> is a functor defined on morphisms by
\[ i ≤ j \quad⇒\quad \mathsf{monus}(i,j) ≔ j - i\]
Then the functor laws become  <code>i - i = 0</code> and <code>(k - j) + (j - i) = k - i</code>.</li>

<li><code>div : (ℕ⁺, ≤) → (ℚ, ×, 1)</code> is defined on morphisms by
\[i ≤ j \quad⇒\quad \mathsf{div}(i,j) ≔ j / i\]
The functor laws become <code>i / i = 1</code> and <code>(k / j) × (j / i) = k / i</code>.</li>
</ul>

<p>
Hey, these two seem alarmingly similar! What gives!
Well, they’re both functors from posets to monoids ;)
Also, they are instances of ‘residuated po-monoids’.
Non-commutative monoids may have not have a general inverse operation,
but instead might have left- and right- inverse operations known as residuals
&#x2014;we’ll mention this word again when discussing adjunctions and are
categorically seen as kan extensions.
Alternatively, they’re are instances of <a href="http://link.springer.com.libaccess.lib.mcmaster.ca/article/10.1007/s10773-004-7710-7">‘(Kopka) Difference-posets’</a>.
</p>


<p>
For more examples of categories, we will need to reason
by extensionality &#x2013;two things are ‘equal’ when they have
equivalent properties &#x2026; recall Leibniz and his
<a href="https://en.wikipedia.org/wiki/Identity_of_indiscernibles">law of indiscernibles</a> ;p
</p>
</div>
</div>
</div>
<div id="outline-container-org19f0cd4" class="outline-2">
<h2 id="The-four-postulates-of-the-apocalypse"><i>The four postulates of the apocalypse</i></h2>
<div class="outline-text-2" id="text-The-four-postulates-of-the-apocalypse">
<p>
Categories have objects and morphisms between them, functors are morphisms between categories,
and then we can go up another level and consider morphisms between functors.
These ‘level 2 morphisms’ are pretty cool, so let’s touch on them briefly.
</p>

<p>
Recall that a poset ordering is extended to (possibly non-monotone) functions \(f , g\) pointwise
\[f \overset{.}{≤} g \quad\iff\quad (∀ x •\; f\, x \,≤\, g\, x)\]
As such, with posets as our guide, we extend the notion of ‘morphism between functors’
to be a ‘witness’ of these orderings \(η : ∀ {X} → F\, X ⟶ G\, X\)
&#x2013;this is a dependent type, note that the second arrow notates category morphisms, whereas
the first acts as a separator from the implicit parameter \(X\); sometimes one sees \(η_X\)
for each component/instance of such an operation.
</p>

<div class="org-center">
<p>
\(\require{AMScd}\)
</p>
\begin{CD}
\color{navy}{F\, A} @>\color{fuchsia}{η_A}>>      \color{teal}{G\, A}    \\
@V\color{navy}{F\, f}VV    \!=                    @VV\color{teal}{G\, f}V \\
\color{navy}{F\, B} @>>\color{fuchsia}{η_B}>      \color{teal}{G\, B}
\end{CD}
</div>

<p>
However, then for any morphism \(f : A ⟶ B\) we have two ways to get from \(F\, A\) to \(G\, B\) via
<code>F f ⨾ η {B}</code> and <code>η {A} ⨾ G f</code> and rather than choose one or the other, we request that they
are identical &#x2014;similar to the case of associativity.
</p>
<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #b58900; font-style: italic;">NatTrans</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j i&#8217; j&#8217;}  &#10627; <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j} &#10628; &#10627; <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i&#8217;} {j&#8217;} &#10628;
            (<span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> (j&#8217; <span style="color: #268bd2;">&#8845;</span> i <span style="color: #268bd2;">&#8845;</span> j)
 <span style="color: #b58900; font-style: italic;">NatTrans</span> &#10627; <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> &#10628; &#10627; <span style="color: #b58900; font-style: italic;">&#119967;</span> &#10628; <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">=</span>
   <span style="color: #b58900; font-style: italic;">&#931;</span> &#951; <span style="color: #268bd2;">&#8758;</span> (<span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} <span style="color: #268bd2;">&#8594;</span> (obj <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">X</span>) <span style="color: #268bd2;">&#10230;</span> (obj <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">X</span>))
       <span style="color: #268bd2;">&#8226;</span> (<span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span>} {f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">B</span>} <span style="color: #268bd2;">&#8594;</span> mor <span style="color: #b58900; font-style: italic;">F</span> f <span style="color: #268bd2;">&#10814;</span> &#951; {<span style="color: #b58900; font-style: italic;">B</span>} <span style="color: #268bd2;">&#8801;</span> &#951; {<span style="color: #b58900; font-style: italic;">A</span>} <span style="color: #268bd2;">&#10814;</span> mor <span style="color: #b58900; font-style: italic;">G</span> f)
</pre>
</div>
<p>
The naturality condition is remembered by placing the target component <code>η {B}</code> <i>after</i>
lifting <code>f</code> using the <i>source</i> functor <code>F</code>;
likewise placing the source component <i>before</i> applying the target functor.
</p>

<p>
Another way to remember it:
<code>η : F ⟶̇ G</code> starts at <code>F</code> and ends at <code>G</code>, so the naturality also starts with <code>F</code> and ends
with <code>G</code>; i.e., <code>F f ⨾ η {B} = η {A} ⨾ G f</code> :-)
</p>

<p>
It is at this junction that aforementioned problem with our definition
of category comes to light: Function equality is extensional by definition
and as such we cannot prove it.
Right now we have two function-like structures for which we will postulate a
form of extensionality,
</p>
<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">function extensionality</span>
 postulate extensionality <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j} {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> i} {<span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> j}
                              {f g <span style="color: #b58900; font-style: italic;">:</span> (a <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span>) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span> a}
                          <span style="color: #268bd2;">&#8594;</span> (<span style="color: #268bd2;">&#8704;</span> {a} <span style="color: #268bd2;">&#8594;</span> f a <span style="color: #268bd2;">&#8801;</span> g a) <span style="color: #268bd2;">&#8594;</span> f <span style="color: #268bd2;">&#8801;</span> g

 <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">functor extensionality</span>
 postulate funcext <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j k l} &#10627; <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j} &#10628; &#10627; <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {k} {l} &#10628;
                       {<span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>}
                     <span style="color: #268bd2;">&#8594;</span> (oeq <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {o} <span style="color: #268bd2;">&#8594;</span> obj <span style="color: #b58900; font-style: italic;">F</span> o <span style="color: #268bd2;">&#8801;</span> obj <span style="color: #b58900; font-style: italic;">G</span> o)
                     <span style="color: #268bd2;">&#8594;</span> (<span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">Y</span>} {f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">Y</span>}
                        <span style="color: #268bd2;">&#8594;</span> mor <span style="color: #b58900; font-style: italic;">G</span> f  <span style="color: #268bd2;">&#8801;</span>  <span style="color: #268bd2;">&#8801;-</span>subst&#8322; (Category._<span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>) oeq oeq (mor <span style="color: #b58900; font-style: italic;">F</span> f))
                     <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #268bd2;">&#8801;</span> <span style="color: #b58900; font-style: italic;">G</span>

 <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">graph map extensionality</span>
 postulate graphmapext <span style="color: #b58900; font-style: italic;">:</span> {<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span> } {f g <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">GraphMap</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span>}
                       <span style="color: #268bd2;">&#8594;</span> (veq <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {v} <span style="color: #268bd2;">&#8594;</span> ver f v <span style="color: #268bd2;">&#8801;</span> ver g v)
                       <span style="color: #268bd2;">&#8594;</span> (<span style="color: #268bd2;">&#8704;</span> {x y} {e <span style="color: #b58900; font-style: italic;">:</span> Graph._<span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">G</span> x y}
                          <span style="color: #268bd2;">&#8594;</span> edge g e <span style="color: #268bd2;">&#8801;</span> <span style="color: #268bd2;">&#8801;-</span>subst&#8322; (Graph._<span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">H</span>) veq veq (edge f e))
                       <span style="color: #268bd2;">&#8594;</span> f <span style="color: #268bd2;">&#8801;</span> g

 <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">natural transformation extensionality</span>
 postulate nattransext <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j i&#8217; j&#8217;} {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j} } {<span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i&#8217;} {j&#8217;} }
                         {<span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>} (&#951; &#947; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">NatTrans</span> <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">G</span>)
                       <span style="color: #268bd2;">&#8594;</span> (<span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">X</span>} <span style="color: #268bd2;">&#8594;</span> proj&#8321; &#951; {<span style="color: #b58900; font-style: italic;">X</span>} <span style="color: #268bd2;">&#8801;</span> proj&#8321; &#947; {<span style="color: #b58900; font-style: italic;">X</span>})
                       <span style="color: #268bd2;">&#8594;</span> &#951; <span style="color: #268bd2;">&#8801;</span> &#947;
</pre>
</div>

<p>
Natural transformations are too cool to end discussing so briefly
and so we go on to discuss their usage is mathematics later on.
</p>
</div>

<div id="outline-container-org8f237d9" class="outline-3">
<h3 id="A-very-big-𝒞𝒶𝓉">A very big <code>𝒞𝒶𝓉</code></h3>
<div class="outline-text-3" id="text-A-very-big-𝒞𝒶𝓉">
<p>
With the notions of categories, functors, and extensionality in-hand we can now discus the
notion of the category of small categories and the category of small graphs.
Afterwards we give another example of a functor that says how every category can be
construed as a graph.
</p>

<p>
First the category of <i>smaller</i> categories,
</p>
<blockquote>
<p>
<code>𝒞𝒶𝓉</code> is a category of kind <code>(ℓsuc m, ℓsuc m)</code>, where <code>m = i ⊍ j</code>, and its objects
are categories of kind <code>(i , j)</code> and so it is not an object of itself.
</p>

<p>
Thank-you Russel and friends!
</p>

<p>
( You may proceed to snicker at the paradoxical and size issues encountered
  by those who use set theory.
  &#x2014;Then again, I’ve never actually learned, nor even attempted to learn,
  any ‘‘formal set theory’’;
  what I do know of set theory is usually couched in the language of type theory;
  I heart <a href="https://www.springer.com/gp/book/9780387941158">LADM</a>!
)
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #859900; font-weight: bold;">instance</span>
  <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Category</span> {&#8467;suc (i <span style="color: #268bd2;">&#8845;</span> j)} {&#8467;suc (i <span style="color: #268bd2;">&#8845;</span> j)}
  <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span> {i} {j} <span style="color: #268bd2;">=</span> record {
      <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j}
    ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Functor</span>
    ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> &#955; {<span style="color: #b58900; font-style: italic;">&#119966;</span>} {<span style="color: #b58900; font-style: italic;">&#119967;</span>} {<span style="color: #b58900; font-style: italic;">&#8496;</span>} <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#8594;</span>
        <span style="color: #859900; font-weight: bold;">let</span> <span style="color: #859900; font-weight: bold;">instance</span>
                   <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> ; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>
                   <span style="color: #b58900; font-style: italic;">&#119967;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> ; <span style="color: #b58900; font-style: italic;">&#119967;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>
                   <span style="color: #b58900; font-style: italic;">&#8496;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> ; <span style="color: #b58900; font-style: italic;">&#8496;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#8496;</span>
        <span style="color: #859900; font-weight: bold;">in</span> record
        { obj  <span style="color: #268bd2;">=</span>  obj <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #268bd2;">&#10814;</span> obj <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">this compositon lives in &#119982;e&#120009;</span>
        ; mor  <span style="color: #268bd2;">=</span>  mor <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #268bd2;">&#10814;</span> mor <span style="color: #b58900; font-style: italic;">G</span>
        ; id   <span style="color: #268bd2;">=</span>  &#955; {x} <span style="color: #268bd2;">&#8594;</span> begin
              (mor <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #268bd2;">&#10814;</span> mor <span style="color: #b58900; font-style: italic;">G</span>) (<span style="color: #b58900; font-style: italic;">Id</span> &#10627; <span style="color: #b58900; font-style: italic;">&#119966;</span> &#10628; {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">=</span> x})
            <span style="color: #268bd2;">&#8801;</span>&#10216; <span style="color: #2aa198;">"definition of function composition"</span> &#10217;<span style="color: #268bd2;">&#8242;</span>
              mor <span style="color: #b58900; font-style: italic;">G</span> (mor <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">Id</span>)
            <span style="color: #268bd2;">&#8801;</span>&#10216; functor <span style="color: #b58900; font-style: italic;">F</span> preserves<span style="color: #268bd2;">-</span>identities even<span style="color: #268bd2;">-</span>under (mor <span style="color: #b58900; font-style: italic;">G</span>) &#10217;
              mor <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">Id</span>
            <span style="color: #268bd2;">&#8801;</span>&#10216; functor <span style="color: #b58900; font-style: italic;">G</span> preserves<span style="color: #268bd2;">-</span>identities &#10217;
              <span style="color: #b58900; font-style: italic;">Id</span>
            <span style="color: #268bd2;">&#8718;</span>
        ; comp <span style="color: #268bd2;">=</span> &#955; {x y z f g} <span style="color: #268bd2;">&#8594;</span>
             begin
               (mor <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #268bd2;">&#10814;</span> mor <span style="color: #b58900; font-style: italic;">G</span>) (f <span style="color: #268bd2;">&#10814;</span> g)
            <span style="color: #268bd2;">&#8801;</span>&#10216; <span style="color: #2aa198;">"definition of function composition"</span> &#10217;<span style="color: #268bd2;">&#8242;</span>
               mor <span style="color: #b58900; font-style: italic;">G</span> (mor <span style="color: #b58900; font-style: italic;">F</span> (f <span style="color: #268bd2;">&#10814;</span> g))
             <span style="color: #268bd2;">&#8801;</span>&#10216; functor <span style="color: #b58900; font-style: italic;">F</span> preserves<span style="color: #268bd2;">-</span>composition even<span style="color: #268bd2;">-</span>under mor <span style="color: #b58900; font-style: italic;">G</span> &#10217;
               mor <span style="color: #b58900; font-style: italic;">G</span> (mor <span style="color: #b58900; font-style: italic;">F</span> f <span style="color: #268bd2;">&#10814;</span> mor <span style="color: #b58900; font-style: italic;">F</span> g)
             <span style="color: #268bd2;">&#8801;</span>&#10216; functor <span style="color: #b58900; font-style: italic;">G</span> preserves<span style="color: #268bd2;">-</span>composition &#10217;
               (mor <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #268bd2;">&#10814;</span> mor <span style="color: #b58900; font-style: italic;">G</span>) f <span style="color: #268bd2;">&#10814;</span> (mor <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #268bd2;">&#10814;</span> mor <span style="color: #b58900; font-style: italic;">G</span>) g
             <span style="color: #268bd2;">&#8718;</span>
        }
    ; assoc    <span style="color: #268bd2;">=</span>  &#955; {a b c d f g h} <span style="color: #268bd2;">&#8594;</span> funcext <span style="color: #268bd2;">&#8801;-</span>refl <span style="color: #268bd2;">&#8801;-</span>refl
    ; <span style="color: #b58900; font-style: italic;">Id</span>       <span style="color: #268bd2;">=</span>  record { obj <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Id</span> ; mor <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Id</span> ; id <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl ; comp <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl }
    ; leftId   <span style="color: #268bd2;">=</span>  funcext <span style="color: #268bd2;">&#8801;-</span>refl <span style="color: #268bd2;">&#8801;-</span>refl
    ; rightId  <span style="color: #268bd2;">=</span>  funcext <span style="color: #268bd2;">&#8801;-</span>refl <span style="color: #268bd2;">&#8801;-</span>refl
    }
</pre>
</div>

<p>
Some things to note,
</p>

<ul class="org-ul">
<li>First off: <code>functor F preserves-composition even-under mor G</code> is a real line of code!
It consists of actual function calls and is merely an alias for
<code>≡-cong (mor G) (mor F)</code> but it sure is far more readable than this form!</li>

<li><p>
We could have written <code>id = ≡-cong (mor G) (id F) ⟨≡≡⟩ id G</code>,
but this is not terribly clear what is going on.
Especially since we introduced categories not too long ago,
we choose to elaborate the detail.
</p>

<p>
Likewise, <code>comp = (≡-cong (mor G) (comp F)) ⟨≡≡⟩ (comp G)</code>.
</p></li>

<li><code>assoc</code> is trivial since function composition is, by definition, associative.
Likewise <code>leftId, rightId</code> hold since functional identity is, by definition, unit of function composition.</li>
</ul>
</div>
</div>
<div id="outline-container-org60f6a6e" class="outline-3">
<h3 id="𝒢𝓇𝒶𝓅𝒽"><code>𝒢𝓇𝒶𝓅𝒽</code></h3>
<div class="outline-text-3" id="text-𝒢𝓇𝒶𝓅𝒽">
<p>
In a nearly identical way, just ignoring the algebraic datum, we can show that
<code>Graph</code>'s with <code>GraphMap</code>'s form a graph
</p>
<pre class="example">
  𝒢𝓇𝒶𝓅𝒽 : Category
  𝒢𝓇𝒶𝓅𝒽 = {! exercise !}
</pre>
</div>
</div>

<div id="outline-container-org1f631ef" class="outline-3">
<h3 id="𝒞𝒶𝓉-'s-are-𝒢𝓇𝒶𝓅𝒽-'s"><code>𝒞𝒶𝓉</code>'s are <code>𝒢𝓇𝒶𝓅𝒽</code>'s</h3>
<div class="outline-text-3" id="text-𝒞𝒶𝓉-'s-are-𝒢𝓇𝒶𝓅𝒽-'s">
<div class="org-center">
<p>
<i>Forgive and forget: The 𝒰nderlying functor.</i>
</p>
</div>

<p>
Let’s formalise what we meant earlier when we said graphs are categories
but ignoring the algebraic data.
</p>

<p>
Given a category, we ignore the algebraic structure to obtain a graph,
</p>
<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8320; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Graph</span>
 <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8320; <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">=</span> record { <span style="color: #b58900; font-style: italic;">V</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> Category._<span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> }
</pre>
</div>

<p>
Likewise, given a functor we ‘forget’ the property that the map of morphisms needs to preserve all
finite compositions to obtain a graph map:
</p>
<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">:</span> {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span>} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8320; <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8320; <span style="color: #b58900; font-style: italic;">&#119967;</span>
 <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #268bd2;">=</span> record { ver <span style="color: #268bd2;">=</span> obj <span style="color: #b58900; font-style: italic;">F</span> ; edge <span style="color: #268bd2;">=</span> mor <span style="color: #b58900; font-style: italic;">F</span> }
</pre>
</div>
<p>
This says that <code>𝒰₁</code> turns <code>ver, edge</code> into <code>obj , mor</code>
--<code>𝒰₁ ⨾ ver  ≡ obj</code> and <code>𝒰₁ ⨾ edge ≡ mor</code>&#x2013; reassuring us that <code>𝒰₁</code> acts
as a bridge between the graph structures: <code>ver , edge</code> of graphs and
<code>obj , mor</code> of categories.
</p>

<p>
Putting this together, we obtain a functor.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Underlying/forgetful functor: Every category is a graph</span>
 <span style="color: #b58900; font-style: italic;">&#119984;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span> <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span>
 <span style="color: #b58900; font-style: italic;">&#119984;</span> <span style="color: #268bd2;">=</span> record { obj <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8320; ; mor <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; ; id <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl ; comp <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl }
</pre>
</div>
<p>
We forget about the extra algebraic structure of a category and of a functor to
arrive at a graph and graph-map, clearly --<code>≡-refl</code>&#x2013; such ‘forgetfullness’ preserves identities
and composition since it does not affect them at all!
</p>

<p>
Those familiar with category theory may exclaim that just as I have mentioned
the names ‘underlying functor’ and ‘forgetful functor’ I ought to mention
‘stripping functor’ as it is just as valid since it brings about connotations of
‘stripping away’ extra structure.
I’m assuming the latter is less popular due to its usage for
poor mathematical jokes and puns.
</p>

<p>
Before we move on, the curious might wonder if ‘‘categories are graphs’’
then what is the analgoue to ‘‘\(X\) are hypergraphs’’,
it is <a href="http://arxiv.org/PS_cache/math/pdf/0305/0305049v1.pdf#page=178">multicategories</a>.
</p>

<p>
Now the remainder of these notes is to build-up the material
needed to realise the notion of ‘free’ which is, in some sense,
<i>the best-possible approximate inverse</i> to ‘forgetful’
&#x2013;however, forgetting is clearly not invertible since it can easily
confuse two categories as the same graph!
</p>
</div>
</div>
</div>

<div id="outline-container-org6256803" class="outline-2">
<h2 id="How-natural-is-naturality"><i>How natural is naturality?</i></h2>
<div class="outline-text-2" id="text-How-natural-is-naturality">
<p>
Recall, that a natural transformation \(η : F \natTo G\) is a family
\(∀ \{X \,:\, \Obj 𝒞\} \,→\, F\, X ⟶ G\, X\) that satisfies the naturality condition:
\(∀ \{A \; B\} \{f \,:\, A ⟶ B\} \,→\, F f ⨾ η {B} \;≡\; η {A} ⨾ G f\).
</p>

<ul class="org-ul">
<li>In the type of η, note that the first <i>show</i> arrow ‘→’ acts as a separator from the
the ∀-quantified variable \(X\), whereas the second <i>longer</i> arrow ‘⟶’ denotes the
morphism type in the category 𝒞.</li>

<li>We will freely interchange the informal mathematical rendition \((η_x : F\, X → G\, X)_{x ∈ \Obj 𝒞}\)
with the aforementioned formal Agda forms <code>∀{X : Obj 𝒞} → F X → G → X</code> and invocation <code>η {X}</code>.</li>
</ul>

<div class="org-center">
<p>
\(\require{AMScd}\)
</p>
\begin{CD}
\color{navy}{F\, A} @>\color{fuchsia}{η_A}>>      \color{teal}{G\, A}    \\
@V\color{navy}{F\, f}VV    \!=                    @VV\color{teal}{G\, f}V \\
\color{navy}{F\, B} @>>\color{fuchsia}{η_B}>      \color{teal}{G\, B}
\end{CD}
</div>
<p>
Let us look at this from a few different
angles; in particular, <a href="http://mathoverflow.net/questions/56938/what-does-the-adjective-natural-actually-mean/56956">what does the adjective ‘natural’ actually mean?</a>
It’s been discussed on many forums and we collect a few of the key points here.
</p>
</div>

<div id="outline-container-org4559df9" class="outline-3">
<h3 id="Identification-of-possible-paths-contraction-of-choices">Identification of possible paths &#x2014;contraction of choices</h3>
<div class="outline-text-3" id="text-Identification-of-possible-paths-contraction-of-choices">
<p>
Given two functors \(F , G\), for any object \(~x\) we obtain two objects \(F\, x\, , \, G\, x\) and so a morphism
from \(F\) to \(G\) ought to map such \(F\,x\) to \(G\, x\). That is, a morphsim of functors is a family  <br>
\(η \,:\, ∀ \{x : \Obj 𝒞\} \,→\, F \,x ⟶ G \,x\). Now for any \(f : a → b\) there are two ways to form a morphism
\(F\, a → G\, b\): \(F f ⨾ η \{b\}\) and \(η \{a\} ⨾ G\, f\). Rather than make a choice each time we want such
a morphism, we eliminate the choice all together by insisting that they are identical.
This is the naturality condition.
</p>

<p>
This is similar to when we are given three morphisms \(f : a → b , g : b → c , h : c → d\),
then there are two ways to form a morphism \(a → d\); namely \((f ⨾ g) ⨾ h\) and \(f ⨾ (g ⨾ h)\).
Rather than make a choice each time we want such a morphism, we eliminate the choice all together
by insisting that they are identical. This is the associativity condition for categories.
</p>

<p>
Notice that if there’s no morphism \(F\, x ⟶ G\, x\) for some \(x\), they by definition there’s no
possible natural transformation \(F \natTo G\).
</p>
</div>
</div>

<div id="outline-container-org12572c4" class="outline-3">
<h3 id="No-Choice-free-will-is-only-an-illusion">No Choice &#x2013;free will is only an illusion</h3>
<div class="outline-text-3" id="text-No-Choice-free-will-is-only-an-illusion">
\begin{align*}
     & \quad\text{the natural $X$}
\\ = & \quad\text{the $X$ which requires no arbitrary choices}
\\ = & \quad\text{the canonical/standard $X$}
\end{align*}

<p>
That is,
</p>
\begin{align*}
     & \quad \text{it is a natural construction/choice}
\\ = & \quad \text{distinct people would arrive at the same construction;}
\\   & \quad \text{ (no arbitrary choice or cleverness needed) }
\\ = & \quad \text{ there is actually no choice, i.e., only one possiility, }
\\   & \quad \text{ and so two people are expected to arrive at the same ‘choice’}
\end{align*}

<p>
Thus, if a construction every involves having to decide between distinct routes, then chances are
the result is not formally natural.
Sometimes this ‘inution’ is developed from working in a field for some time;
sometimes it just “feel”" natural.
</p>

<p>
<a href="http://math.stackexchange.com/questions/939404/do-natural-transformations-make-god-given-precise?rq=1">Some would even say</a>: <i>Natural = God-given</i>.
</p>
</div>
</div>

<div id="outline-container-org60f32ca" class="outline-3">
<h3 id="Natural-means-polymorphic-without-type-inspection">Natural means polymorphic without type inspection</h3>
<div class="outline-text-3" id="text-Natural-means-polymorphic-without-type-inspection">
<p>
A natural transformation can be thought of as a polymorphic function
<code>∀ {X} → F X ⟶ G X</code> <i>where</i> we restrict ourselves to avoid inspecting any <code>X</code>.
</p>

<ul class="org-ul">
<li>Recall that a <code>mono</code>-morphic operation makes no use of type variables in its signature,
whereas a <code>poly</code>-morphic operation uses type variables in its signature.</li>

<li>For example, in C# one can ask if one type <code>is</code> a subclass of another thereby
obtaining specific information, whereas there is no such mechanism in Haskell.</li>
</ul>

<p>
Inspecting type parameters or not leads to the distinction of ad hoc plymorphism vs. parametric
polymorphism &#x2014;the later is the kind of polymorphism employed in functional language like Haskell
and friends and so such functions are natural transformations by default!
<a href="http://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf">Theorems for free!</a>
</p>

<p>
For example,
</p>
<pre class="example">
-- Let 𝒦 x y ≔ Id {x} for morphisms, and 𝒦 x y ≔ x for objects.

size : ∀ {X} → List X → 𝒦 ℕ X
size [x₁, …, xₙ] = n
</pre>
<p>
is a polymorphic function and so naturality follows and is easily shown &#x2013;show it dear reader!
So we have always have
\[List\; f \;⨾\; size \quad=\quad size\]
Since <code>𝒦 ℕ f = Id</code>, then by extensionality: <code>size : List ⟶̇ 𝒦</code>.
</p>
<p>
On the other hand, the polymorphic function
</p>
<pre class="example">
whyme : ∀ {X} → List X → 𝒦 Int X
whyme {X} [x₁,…,xₙ] = If X = ℕ then 1729 else n
</pre>
<p>
is not natural: The needed equation <code>F f ⨾ η {B} = η {A} ⨾ G f</code>
for any <code>f : A → B</code> breaks as witnessed by
<code>f = (λ x → 0) : ℝ → ℕ</code> and any list with length <code>n ≠ 1729</code>,
and this is easily shown &#x2013;do so!
</p>
<p>
One might exclaim, <i>hey! this only works ’cuz you’re using Ramanujan’s taxi-cab number!</i>
<i>1729 is the smallest number expressible as a sum of 2 cubes in 2 ways:</i>
<i>\(1729 = 12³ + 1³ = 10³ + 9 ³\).</i> I assure you that this is not the reason that naturality breaks,
and I commend you on your keen observation.
</p>

<p>
Notice that it is natural if we exclude the type inspected, ℕ.
That is, if we only consider \(f : A → B\) with \(A ≠ ℕ ≠ B\).
In general, is it the case that a transformation can be made natural by excluding
the types that were inspected?
</p>

<p>
Before we move on, observe that a solution in \(h\) to the absorptive-equation \(F f ⨾ h = h\)
is precisely a natural transformation from \(F\) to the aforementioned ‘diagonal functor’:
\[F f ⨾ h \;=\; h \qquad⇔\qquad ∃ X : Obj \;•\; h ∈ F \overset{.}{⟶} 𝒦 X ~\]
</p>

<p>
In particular, due to the constant-fusion property \(g \,⨾\, 𝒦\, e \;=\; 𝒦\, e\), we have that
\[∀ \{F\} \{X\} \{e \,:\, X\} \;→\; (𝒦\, e) \,∈\, F \overset{.}{⟶} 𝒦\, X \]
Is the converse also true? If \(h ∈ F ⟶̇ 𝒦 X\) then \(h \,=\, 𝒦\, e\) for some \(e\)?
</p>
</div>
</div>

<div id="outline-container-org9ebe71a" class="outline-3">
<h3 id="Natural-means-no-reference-to-types">Natural means no reference to types</h3>
<div class="outline-text-3" id="text-Natural-means-no-reference-to-types">
<p>
The idea that a natural transformation cannot make reference to the type variable at all can be
seen by yet another example.
</p>

<pre class="example">
  data 𝟙 : Set where ★ : 𝟙

  -- Choice function: For any type X, it yields an argument of that type.
  postulate ε : (X : Set) → X

  nay : ∀ {X} → X → X
  nay {X} _ = ε X
</pre>

<p>
Now naturality \(\Id \, f ⨾ nay_B \;=\; nay_A ⨾ \Id \, f\) breaks as witnessed by
\(f \;=\; (λ _ → εℕ + 1) \;:\; 𝟙 → ℕ\) &#x2013;and provided \(εℕ ≠ 0\), otherwise
we could use an \(f\) with no fix points.
</p>

<p>
From this we may hazard the following:
If we have natural transformations \(ηᵢ \,:\, ∀ {X : Objᵢ} →\, F X \overset{.}{⟶} G X\)
where the \(Objᵢ\) partition the objects available &#x2014; i.e., \(Obj \;=\; Σ i \,•\, Objᵢ\) &#x2014;
then the transformation \(η_{(i, X)} \;=\; ηᵢ\) is generally unnatural since it clearly makes choices,
for each partition.
</p>
</div>
</div>

<div id="outline-container-orgc996d29" class="outline-3">
<h3 id="Natural-means-uniformly-and-simultaneously-defined">Natural means uniformly and simultaneously defined</h3>
<div class="outline-text-3" id="text-Natural-means-uniformly-and-simultaneously-defined">
<p>
A family of morphisms is <i>natural in x</i> precisely when it is defined
<i>simultaneously</i> for all <i>x</i> &#x2014;there is no inspection of some particular <i>x</i> here and there,
no, it is uniform! With this view, the naturality condition is thought of as a ‘simultaneity’
condition. <a href="https://www.google.ca/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8&amp;client=ubuntu#q=general%20theory%20of%20natural%20equivalences">Rephrasing GToNE</a>.
</p>

<p>
The idea of naturality as uniformly-definable is pursued by <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.107.2336&amp;rep=rep1&amp;type=pdf">Hodges and Shelah</a>.
</p>
</div>
</div>

<div id="outline-container-org1be2b0a" class="outline-3">
<h3 id="Naturality-is-restructure-modify-commutativity">Naturality is restructure-modify commutativity</h3>
<div class="outline-text-3" id="text-Naturality-is-restructure-modify-commutativity">
<p>
Recall that a functor can be thought of as endowing an object with structure.
Then a transformation can be thought of as a restructuring operation and naturality means
that it doesn’t matter whether we restructure or modify first, as long as we do both.
</p>
</div>
</div>

<div id="outline-container-org82df0f6" class="outline-3">
<h3 id="Natural-means-obvious">Natural means obvious</h3>
<div class="outline-text-3" id="text-Natural-means-obvious">
<p>
It may help to think of <i>there’s a natural transformation from F to G</i> to mean
<i>there’s an obvious/standard/canconical way to transform F structure into G structure</i>.
</p>

<p>
Likewise, <i>F is naturally isomorphic to G</i> may be read <i>F is obviously isomorphic to G</i>.
For example, <b>TODO</b> seq-pair or pair-seq ;-)
</p>

<p>
Sometimes we can show ‘‘F X is isomorphic to G X, if we make a choice dependent on X’’
and so the isomorphism is not obvious, since a choice must be made.
</p>
</div>
</div>

<div id="outline-container-org3461c18" class="outline-3">
<h3 id="Naturality-is-promotion">Naturality is promotion</h3>
<div class="outline-text-3" id="text-Naturality-is-promotion">
<ul class="org-ul">
<li>I think Richard Bird refers to the naturality condition as a promotion law where the functors
involved are thought of as (list) constructions.</li>

<li>The nomenclature is used <a href="https://www.cs.ox.ac.uk/files/3378/PRG56.pdf">to express the idea than operation on a compound structure
can be ‘promoted’ into its components.</a></li>

<li>Reading <code>F f ⨾ η {B} = η {A} ⨾ G f</code> from left to right:
Mapping \(f\) over a complicated structure then handling the result
<i>is the same as</i>
handling the complex datum then mapping \(f\) over the result.

<ul class="org-ul">
<li>`Handling' can be thought of as `processing' or as `reshaping'.</li>
</ul></li>
</ul>

<p>
Lists give many examples of natural transformations by considering
<a href="https://link.springer.com/chapter/10.1007/3-540-51305-1_24">a categorical approach to the theory of lists.</a>
</p>
</div>
</div>

<div id="outline-container-orgd94143b" class="outline-3">
<h3 id="Naturality-as-a-rewrite-rule">Naturality as a rewrite rule</h3>
<div class="outline-text-3" id="text-Naturality-as-a-rewrite-rule">
<p>
The naturality condition can be seen as a rewrite rule that let’s us replace a complicated or
inefficient side with a simplier or more efficient yet equivalent expression.
I think I first learned this view of equations at the insistence of
<a href="https://www.amazon.com/Algebra-Programming-Prentice-hall-International-Computer/dp/013507245X">Richard Bird and Oege de Moor</a>
&#x2013;whose text can be found <a href="http://themattchan.com/docs/algprog.pdf">here</a>, albeit the legitimacy of the link may be suspect.
</p>

<p>
For example, recall the 𝒦onstant functor now construed only as a polymorphic binary operation:
</p>
<pre class="example">
_⟪_    :  ∀{A B : Set} → A → B → A
a ⟪ b  =  a
</pre>

<p>
The above is a constant time operation, whereas the next two are linear time operations; i.e.,
they take <code>n</code> steps to compute, where <code>n</code> is the length of the given list.
</p>

<pre class="example">
-- This' map for List's; i.e., the mor of the List functor
map    : ∀ {A B : Set} (f : A → B) → List A → List B
map f []         =  []
map f (x ∷ xs)  =  f x ∷ map f xs

-- Interpret syntax `x₀∷⋯∷xₙ₋₁` semantically as `x₀ ⊕ ⋯ ⊕ xₙ₋₁`, where ⊕ = cons.
fold  : ∀ {A B : Set} (cons : A → B → B) (nil : B) → List A → B
fold cons nil [] = nil
fold cons nil (x ∷ xs) = cons x (fold cons nil xs)
</pre>

<p>
By <i>Theorems for Free</i>, or a simple proof, we have that <code>fold</code> is a natural
transformation \(List \overset{.}{→} \Id\):
\[ List\; f \;⨾\; fold \; cons_B \; nil_B \qquad=\qquad fold \; cons_A \; nil_A \;⨾\; f \]
Note that here we are ranging over objects \(X\) equipped with \(nil_X : X, \; cons_X : X → X → X\);
as such the equation is not valid when this is not the case.
</p>

<p>
Now we map compute,
</p>
<pre class="example">
postulate A B : Set
postulate nil-B : B
postulate f : A → B -- possibly expensive operation

head  :  List B → B
head  =  fold _⟪_ nil-B

compute  :  List A → B
compute  =  map f  ⨾  head
</pre>

<p>
That is,
</p>
<pre class="example">
  compute [x₀, …, xₙ₋₁]
= head (map f [x₀, …, xₙ₋₁])
= head [f x₀, …, f xₙ₋₁]
= f x₀  ⟪  f x₁ ⟪ ⋯ ⟪ ⋯ f xₙ₋₁ ⟪ nil-B
= f x₀
</pre>

<p>
However this approach performs the potentially expensive operation \(f\) a total of
\(n = \text{“length of input”}\) times! In spite of that, it only needs the first element of
the list and performs the operation only once! Indeed, by the naturality of <code>fold</code> we have
an equivalent, and more efficient, formulation:
</p>
<pre class="example">
compute  =  head  ⨾  f
</pre>

<p>
This operation only performs the potentially costly <code>f</code> once!
</p>

<p>
A more concrete and realistic example is to produce an efficient version of the function
that produces the <code>average xs = div (sum xs, length xs)</code> of a list of numbers: This operation
traverses the input list twice, yet we can keep track of the length as we sum-along the list
to obtain an implementation that traverses the list only once!
</p>

<p>
<a href="https://scss.tcd.ie/publications/tech-reports/reports.99/TCD-CS-1999-74.pdf">Indeed</a>,
</p>
<pre class="example">
div : ℕ × ℕ → ℕ
div (0, 0) = 0
div (m, n) = m ÷ n

average     :  List ℕ → ℕ
average xs  =  div (fold _⊕_ 𝟘 xs)
  where  𝟘 = (0 , 0)
         _⊕_  : ℕ → (ℕ × ℕ) → ℕ
         a ⊕ (b , n) = (a + b , n + 1)
</pre>
</div>
</div>

<div id="outline-container-orga90281d" class="outline-3">
<h3 id="Naturality-is-just-model-morphism">Naturality is just model morphism</h3>
<div class="outline-text-3" id="text-Naturality-is-just-model-morphism">
<p>
Given two functors \(F , G : 𝒞 ⟶ 𝒟\) let us construe them as only graph homomorphisms.
Then each is a model of the graph \(𝒰₀ \; 𝒞\) &#x2014;each intereprets the nodes and edges of <code>𝒰₀ 𝒞</code> as
actual objects and morphisms of 𝒟&#x2014; and a natrual transformation is then nothing
more than a morphism of models.
</p>
</div>
</div>

<div id="outline-container-orge6cbf68" class="outline-3">
<h3 id="Naturality-yields-pattern-matching">Naturality yields pattern matching</h3>
<div class="outline-text-3" id="text-Naturality-yields-pattern-matching">
<p>
In the setting of types and functions, <code>η : F ⟶̇ G</code> means we have <code>η (F f x) = G f (η x)</code>
which when read left-to-right says that <code>η</code> is defined by pattern-matching on its argument
to obtain something of the form <code>F f x</code> then it is defined recursively by examining <code>x</code> and then
applying <code>G f</code> to the result &#x2014;of course there’s some base case <code>F</code> definitions as well.
</p>

<p>
Alternatively, the input to <code>η</code> is of the form <code>F …</code> and its
output is of the form <code>G …</code> &#x2013;mind blown!
</p>

<p>
For example, I want to define a transformation \(\mathsf{List} ⟶̇ \mathsf{List}\).
</p>
<ol class="org-ol">
<li>So let me suppose the input is of the shape \(\List \, f\, x\), more concretely
it is of the shape
 <br> <code>[f x₀, f x₁, …, f xₙ₋₁]</code> &#x2013;for arbitrary \(f : A → B\).</li>
<li>Then the output shape must be \(\List \, f\, (η \, x)\), more concretely
it is of the shape  <br> <code>[f y₀, f y₁, …, f yₘ₋₁]</code> where \(y \,=\, η\,x\).</li>
<li><p>
So my <i>only</i> choices are \(y : \List A\) and \(m : ℕ\)
</p>

<p>
Here are some possibilities and the resulting η:
</p>
<dl class="org-dl">
<dt>\(y, m = x, n\)</dt><dd>Identity function</dd>
<dt>\(y, m = x, 0\)</dt><dd>Constantly empty list <code>[]</code> function</dd>
<dt>\(y, m = x, 1\)</dt><dd>The first element, ‘head’, function</dd>
<dt>\(y, m = x, k\)</dt><dd>The first \(k < n\) elements function</dd>
<dt>\(m = n\) with \(yᵢ = xₙ₋ᵢ\)</dt><dd>List reversal function</dd>
<dt>\(y, m = \mathsf{reverse}(x), k\)</dt><dd>The last \(k < n\) elements, in reverse, function
<ul class="org-ul">
<li>Here we applied an already known natural transformation
and indeed the composition of naturally transformation is itself natural.</li>
</ul></dd>
</dl></li>
</ol>
</div>
</div>

<div id="outline-container-org76b170b" class="outline-3">
<h3 id="Naturality-Examples">Examples</h3>
<div class="outline-text-3" id="text-Naturality-Examples">
<dl class="org-dl">
<dt>Pointwise Monotonicity</dt><dd>A functor among poset categories is an order-preserving function and a natural transformation
\(f \natTo g\) is a proof that \(f \overset{.}{≤} g\) pointwise: \(∀ x \,•\, f\, x \;≤\; g\, x\)
&#x2014;all the other pieces for a natural
transformation are automatic from the definition of begin a poset category.</dd>

<dt>conjugation</dt><dd><p>
A functor among monoids &#x2013;construed as categories&#x2013; is just a monoid homomorphism:
</p>
\begin{align*}
           & (M, ⊕, e) ⟶ (N, ⊗, d)
{{{newline}}} ≅ \quad & Σ h ∶ M → N • ∀ \{x \, y \} •\; h(x ⊕ y) = h x ⊗ h y \lands h e = d
\end{align*}
<p>
A natural transformation <code>(f, prf) ⟶ (g, prf’)</code> is a point \(n : N\) with
\(∀ x ∶ M \;•\; f x ⊗ n \,=\, n ⊗ g x\), a so-called ‘conjugation’ by \(n\) that takes \(f\) to \(g\).
</p></dd>

<dt>fold</dt><dd><p>
Recall from the introduction \(𝒰(S, ⊕, e) \;=\; S\) was the underlying functor from monoids to sets.
</p>

<p>
Let \(𝒰 × 𝒰\) be the functor that for objects \(M \;↦\; 𝒰\, M \,×\, 𝒰\, M\) and for morphisms
\(h \;↦\; λ (x,y) → (h\, x, h\, y)\). Then the monoid multiplication (of each monoid) is a natural
transformation \(𝒰 × 𝒰 \natTo 𝒰\), where naturality says that for any monoid homomorphism \(h\), the
application of \(𝒰\, h\) to the (monoid) multiplication of two elements is the same as the
(monoid) multiplication of the \(𝒰\, h\) images of the two elements,
and this is evident from the homomorphism condition.
</p>

<p>
Extending to finite products, \(ℒ \;≔\; (Σ n ∶ ℕ • ∏ i ∶ 1..n • 𝒰)\), the natural transformation
\(ℒ \natTo 𝒰\) is usually called <i>fold, reduce, or cata</i> and <code>ℒ</code> is known as the
<i>free monoid functor</i> with notations \(A* \;=\; \List A \;=\; ℒ\, A\).
</p>

<p>
Loosely put,
</p>
<pre class="example">
    ℒ₀    :  Monoid → Set
    ℒ₀ M  =  Σ n ∶ ℕ • ∏ i : 1..n • 𝒰 M   -- finite sequences of elements from M

    ℒ₁ : ∀ {M N : Monoid} → (M ⟶ N) → ℒ₀ M → ℒ₀ N
    ℒ₁ (h , prf) = λ (n , x₁, …, xₙ) → (n , h x₁ , … , h xₙ)

    fold : ∀ {M : Monoid} → ℒ₀ M → 𝒰₀ M
    fold {(M, ⊕, e)} = λ (n , x₁, …, xₙ) → x₁ ⊕ ⋯ ⊕ xₙ
</pre>

<p>
&#x2013;The reader would pause to consider implementing this formally using Agda's <code>Data.Fin</code> and <code>Data.Vec</code> ;-)&#x2013;
</p>

<p>
Now for any monoid homomorphism <code>h</code>, applying induction, yields
</p>
<pre class="example">
    h₀(x₁ ⊕ ⋯ ⊕ xₙ)  =  h₀ x₁ ⊕ ⋯ ⊕ h₀ xₙ  where  h₀ = 𝒰 (h₀, prf) = 𝒰 h
</pre>
<p>
Which is easily seen to be just naturality &#x2013; if we use backwards composition \(f ⨾ g \;=\; g ∘ f\) &#x2013;
</p>
<pre class="example">
    𝒰 h ∘ fold {M}  =  fold {N} ∘ ℒ h
</pre>
<p>
Woah!
</p></dd>

<dt>Every operation in any multisorted algebraic structure gives a natural transformation</dt><dd><p>
This is mentioned in the <a href="http://www.math.mcgill.ca/triples/Barr-Wells-ctcs.pdf">Barr and Wells' <i>Category Theory for Computing Science</i> text</a>, citing
Linton, 1969a-b.
</p>

<p>
For example, <code>src, tgt</code> &#x2014;from the graph signature&#x2014; give natural transformations
\(V \natTo E\) from the vertex functor to the edge functor &#x2026; keep reading ;)
</p></dd>

<dt>Representability</dt><dd><p>
Recall that \(V(G)\) is essentially \(ℙ₀ ⟶ G\) where
\(ℙₙ\) is the graph of \(n\) edges on \(n+1\) vertices named \(0..n\) with typing \(i \,:\, i-1 ⟶ i\),
which I like to call <i>the path graph of length n</i>; and in particular \(ℙ₀\) is the graph of
just one dot, called 0, and no edges. &#x2014;Earlier I used the notation <code>[n]</code>, but I’m using \(ℙ\) since
I like the view point of ℙaths.
</p>

<p>
What does it mean to say that <i>V(G) is essentially ℙ₀ ⟶ G</i>?
</p>

<p>
It means that the vertices functor
&#x2013; \(𝒱 \;:\; 𝒢𝓇𝒶𝓅𝒽 ⟶ 𝒮ℯ𝓉\) that takes objects \(G ↦ V(G)\) and morphisms \(h ↦ \mathsf{ver}\, h\) &#x2013;
can be ‘represented’ as the Hom functor \((ℙ₀ ⟶ \_{})\), that is to say
\[𝒱 \quad≅\quad (ℙ₀ ⟶ \_{}) \;\mathsf{within \; Func} \; 𝒢𝓇𝒶𝓅𝒽 \; 𝒮ℯ𝓉\]
--<code>Func</code>-tor categories will be defined in the next section!&#x2013;
</p>

<p>
Notice that we arrived at this expression by
‘eta-reducing’ the phrase <i>V(G) is essentially ℙ₀ ⟶ G</i>! ;)
</p>

<p>
More generally, we have the functor \(ℙₙ ⟶ \_{}\) which yields all paths of length \(n\)
for a given graph.
</p>

<p>
Observe &#x2013;i.e., show&#x2013; that we also have an edges functor.
</p></dd>
</dl>
</div>
</div>
</div>
<div id="outline-container-orgec6d96c" class="outline-2">
<h2 id="Functor-Categories"><i>Functor Categories</i></h2>
<div class="outline-text-2" id="text-Functor-Categories">
<p>
With a notion of morphisms between functors, one is led inexorably to ask
whether functors as objects and natural transformations as morphisms constitute
a category?
They do!
However, we leave their definition to the reader &#x2014;as usual, if the reader is ever so desperate
for solutions, they can be found as comments in the unruliness that is the source file.
</p>
<pre class="example">
 instance
  Func       :  ∀ {i j i’ j’} (𝒞 : Category {i} {j}) (𝒟 : Category {i’} {j’}) → Category _
  Func 𝒞 𝒟  =  {! exercise !}
</pre>

<ul class="org-ul">
<li>A hint: The identity natural transformation is the obvious way to get from \(F\, X\) to \(F\, X\),
for any \(X\) given \(F\) &#x2014;well the only way to do so, without assuming anything else about the
functor \(F\), is simply \(\Id_{F X}\). This is the ‘natural’ choice, any other choice would be
‘unnatural’ as it would require some ‘cleverness’.</li>

<li>Another hint: The obvious way to define \(η ⨾ γ\) to get \(F\, X ⟶ H\, X\) from
\(F\, X ⟶ G\, X ⟶ H\, X\) is composition of morphisms in the category!
That is, pointwise composition. Nothing ‘clever’, just using the obvious candidates!</li>
</ul>

<p>
This is a good exercise as it will show you that there is an identity functor and that composition of functors
is again a functor. Consequently, functors are in abundance: Given any two, we can form [possibly] new ones by composition.
</p>

<p>
It is a common construction that when a type \(Y\) is endowed with some structure, then we can endow
the function space \(X → Y\), where \(X\) is any type, with the same structure and we do so
‘pointwise’. This idea is formalised by functor categories.
Alternatively, one can say we have ‘categorified’ the idea; where
<i>categorification</i> is the process of replacing types and functions with categories and
functors and possibly adding some coherence laws.
</p>

<p>
There are people who like to make a show about how ‘big’ 𝒞𝒶𝓉 or <code>Func 𝒞 𝓓</code> are;
these people adhere to something called ‘set theory’ which is essentialy type theory but
ignoring types, loosely put they work only with the datatype
</p>
<pre class="example">
data SET : Set where
  Elem : ∀ {A : Set} → A → SET
</pre>
<p>
Such heathens delegate types-of-types into ‘classes’ of ‘small’ and ‘big’ sets and it’s not
uniform enough for me.
Anyhow, such people would say that functor categories ‘‘cannot be constructed (as sets)’’ unless
one of the categories involved is ‘‘small’’. Such shenanigans is ignored due to the hierarchy of
types we are using :-)
</p>

<p>
We must admit that at times the usage of a single type, a ‘uni-typed theory’ if you will can be
used when one wants to relise types in an extrinsic fashion rather than think of data as
intrinsically typed &#x2013;E.g., graphs with <code>src, tgt</code> <i>then</i> deriving a notion of ‘type’ with <code>_⟶_</code>.
Everything has its place &#x2026; nonetheless, I prefer (multi)typed settings!
</p>
</div>

<div id="outline-container-org9914bee" class="outline-3">
<h3 id="FunctorCats-Examples">Examples</h3>
<div class="outline-text-3" id="text-FunctorCats-Examples">
</div>

<div id="outline-container-org5710b4f" class="outline-4">
<h4 id="All-Categories-are-Functor-Categories">All Categories are Functor Categories</h4>
<div class="outline-text-4" id="text-All-Categories-are-Functor-Categories">
<p>
Let <code>𝟙 ≔ [ • ]</code> be the discrete category of one object (and only the identity arrow on it).
</p>

<p>
Then <code>𝒞 ≅ Func 𝟙 𝒞</code>.
</p>
</div>
</div>

<div id="outline-container-org09e74c1" class="outline-4">
<h4 id="Powers-of-Categories-are-Functor-Categories">Powers of Categories are Functor Categories</h4>
<div class="outline-text-4" id="text-Powers-of-Categories-are-Functor-Categories">
<p>
Let <code>𝟚₀ ≔ [• •]</code> be the discrete category of two objects.
  Then the <i>𝒞-squared</i> category can be defined <code>𝒞 ⊗ 𝒞 ∶≅ Func 𝟚₀ 𝒞</code>:
  This category essentially consists of pairs of 𝒞-objects with pairs of 𝒞-arrows
  between them.
</p>

<p>
The subscript 0 is commonly used for matters associated with objects and
the name <code>𝟚₀</code> is suggestive of the category of 2 objects only.
</p>

<p>
More generally, if 𝒩 is the discrete category of \(n\) objects, then
the <i>n</i>-fold product category is defined by
<code>(∏ i ∶ 1..n • 𝒞) ∶≅ Func 𝒩 𝒞</code>.
</p>

<p>
These are also commonly denoted \(𝒞^2\) and \(𝒞^𝒩\) since they are essentially
products, and more generally <code>Func 𝒳 𝒴</code> is also denoted 𝒴<sup>𝒳</sup> and referred.
</p>
</div>
</div>

<div id="outline-container-org1850dbb" class="outline-4">
<h4 id="Arrow-Categories">Arrow Categories</h4>
<div class="outline-text-4" id="text-Arrow-Categories">
<p>
We can add an arrow to <code>𝟚₀</code> to obtain another category&#x2026;
</p>

<p>
Let <code>𝟚 ≔ • ⟶ •</code> be the category of two objects, call them 0 and 1, with one arrow between them.
  Then a functor <code>𝟚 ⟶ 𝒞</code> is precisely a morphism of 𝒞 and a natural transformation
<code>f ⟶ g</code> boils down to just a pair of morphisms <code>(h,k)</code> with <code>h ⨾ g = f ⨾ k</code>.
</p>

<p>
Hence, the <i>arrow category of 𝒞</i> is \(𝒞^𝟚 \;≅\; 𝒞^→ \;≅\; \mathsf{Func}\, 𝟚 𝒞\);
which is essentially the category with objects being 𝒞-morphisms and morphisms being <i>commutative squares</i>.
</p>

<p>
Notice that a functor can be used to
</p>
<ul class="org-ul">
<li><i>select</i> two arbitrary 𝒞 objects &#x2013;if it's source is 𝟚₀</li>
<li><i>select</i> two arbitrary 𝒞 objects with a 𝒞 arrow between them &#x2013;if it's source is 𝟚</li>
<li><i>select</i> an arbitrary 𝒞 arrow &#x2013;if it's source is 𝟚</li>
</ul>

<p>
Likewise, a natural transformation can be used to <i>select</i> a commutative diagram.
</p>
</div>
</div>

<div id="outline-container-org0f42bf1" class="outline-4">
<h4 id="Understand-𝒞-by-looking-at-Functor-Categories">Understand 𝒞 by looking at Functor Categories</h4>
<div class="outline-text-4" id="text-Understand-𝒞-by-looking-at-Functor-Categories">
<p>
It is a common heuristic that when one suspects the <i>possibility</i> of a category <code>𝒞</code>, then one
can make <i>probes</i> to discover its structure. The objects are just functors <code>𝟙 ⟶ 𝒞</code> and the
morphisms are just functors <code>𝟚 ⟶ 𝒞</code>.
</p>
</div>
</div>

<div id="outline-container-org7108144" class="outline-4">
<h4 id="Presheaves-delegating-work-to-𝒮ℯ𝓉">Presheaves &#x2013; delegating work to 𝒮ℯ𝓉</h4>
<div class="outline-text-4" id="text-Presheaves-delegating-work-to-𝒮ℯ𝓉">
<p>
The <i>category of presheaves of 𝒞</i> is the category <code>PSh 𝒞 ≔ Func (𝒞 ᵒᵖ) 𝒮e𝓉</code>.
</p>

<p>
This is a pretty awesome category since it allows nearly all constructions in 𝒮ℯ𝓉 to be
realised! Such as subsets, truth values, and even powersets! All these extra goodies make it
a ‘topos’ aka ‘power allegory’ &#x2014;the first is a category that has all finite limits and
a notion of powerset while the second, besides the power part, looks like a totally different beast;
the exhilaration!
</p>
</div>
</div>

<div id="outline-container-orgb5fb3fd" class="outline-4">
<h4 id="Slice-Categories">Slice Categories</h4>
<div class="outline-text-4" id="text-Slice-Categories">
<p>
The <i>slice category of 𝒞 over B : Obj 𝒞</i> is the category <code>𝒞 / B ≔ Σ F ∶ Func 𝟚 𝒞 • (F 1 = B)</code>.
</p>

<p>
Essentially it is the category of objects being 𝒞-morphisms with target \(B\)
and morphisms \(f ⟶ g\) being \((h,k)\) with \(h ⨾ g = f ⨾ k\) but a natural choice for
\(k : B ⟶ B\) is \(\Id_B\) and so we can use morphism type
\((f ⟶’ g) \;≔\; Σ h : \src f ⟶ \src g \;•\; h ⨾ g = f\).
</p>

<p>
This is seen by the observation \[(h, k) \;∈\; f ⟶ g \qquad⇔\qquad h \;∈\; (f ⨾ k) ⟶’ g\]
Of course a formal justification is obtained by showing
\[\_{}⟶\_{} \quad≅\quad \_{}⟶’\_{} \quad \mathsf{within \; Func }\; (𝒞 ᵒᵖ ⊗ 𝒞) 𝒮e𝓉 \]
&#x2026;which I have not done and so may be spouting gibberish!
</p>

<p>
Just as the type <code>Σ x ∶ X • P x</code> can be included in the type <code>X</code>, by forgetting the second
component, so too the category <code>Σ F ∶ 𝟚 ⟶ 𝒞 • F 1 ≈ B</code> can be included into the category
𝒞 and we say it is a <i>subcategory</i> of 𝒞.
</p>

<p>
The notation <code>Σ o ∶ Obj 𝒞 • P o</code> defines the subcategory of 𝒞 obtained by deleting
all objects not satisfying predicate <code>P</code> and deleting all morphisms incident to such objects; i.e.,
it is the category 𝒟 with
\[ \Obj 𝒟 \quad≡\quad Σ o ∶ \Obj 𝒞 \,•\, P o
   \qquad\text{ and }\qquad
   (o , prf) ⟶_𝒟 (o' , prf') \quad≡\quad o ⟶_𝒞 o'
\]
This is the largest/best/universal subcategory of 𝒞 whose objects satisfy \(P\).
 <br> Formalise this via a universal property ;)
</p>
</div>
</div>

<div id="outline-container-org402f4da" class="outline-4">
<h4 id="Slices-of-𝒮e𝓉-are-Functor-Categories">Slices of <code>𝒮e𝓉</code> are Functor Categories</h4>
<div class="outline-text-4" id="text-Slices-of-𝒮e𝓉-are-Functor-Categories">
<p>
\[ \Func \; S \; 𝒮e𝓉  \qquad≅\qquad  𝒮e𝓉 / S \]
Where S in the left is construed as a discrete category and in the right
is construed as an object of 𝒮e𝓉.
</p>

<p>
This is because a functor from a discrete category need only be a function of objects since
there are no non-identity morphisms. That is, a functor \(f : S ⟶ 𝒮ℯ𝓉\)
is determined by giving a set \(f\,s\) for each element \(s ∈ S\) &#x2014;since there are no non-identity morphisms.
Indeed a functor \(f : S ⟶ Set\) yields an <i>S</i>-targeted
function
\[ (Σ s ∶ S \,•\, f\, s) → S  \quad:\quad λ (s , fs) → s \]
Conversely a function \(g : X → S\) yields a functor by sending elements to their pre-image sets:
\[ S ⟶ Set \quad:\quad λ s → (Σ x ∶ X \,•\, g\, x ≡ s)\]
</p>

<p>
Because of this example, <code>𝒞 / B</code> can be thought of as ‘𝒞-objects indexed by B’
&#x2013;extending this idea further leads to <i>fibred categories</i>.
</p>
</div>
</div>

<div id="outline-container-org659e4bb" class="outline-4">
<h4 id="Natural-transformations-as-functor-categories">Natural transformations as functor categories</h4>
<div class="outline-text-4" id="text-Natural-transformations-as-functor-categories">
<p>
In a similar spirit, we can identify natural transformations as functors!
\[\Func \, 𝒞 \, (𝒟 ^ 𝟚) \quad≅\quad (Σ F , G ∶ 𝒞 ⟶ 𝒟 \;•\; \mathsf{NatTrans}\, F\, G)\]
</p>

<p>
A functor \(N : 𝒞 ⟶ 𝒟 ^ 𝟚\) gives, for each object \(C : \Obj 𝒞\) an object in \(𝒟 ^ 𝟚\) which
is precisely an arrow in \(𝒟\), rewrite it as \(N_C : F\,C ⟶ G\,C\) where \(F\,C \,≔\, N\, C\, 0\)
and \(G\, C \,≔\, N\, C\, 1\).
</p>

<p>
Likewise, for each arrow \(f : A ⟶ B\) in 𝒞 we obtain an arrow \(N\, f \,:\, N\, A ⟶ N\, B\)
in \(𝒟 ^ 𝟚\) which is precisely a commutative square in 𝒟;
that is, a pair of 𝒟-arrows \((F\,f , G\,f) ≔ N\,f\)
with \(N_A ⨾ G\,f \;=\; F\,f ⨾ N_B\).
</p>

<p>
Notice that we have implicitly defined two functors \(F, G : 𝒞 ⟶ 𝒟\).
Their object and morphism mappings are clear, but what about functoriality?
We prove it for both \(F, G\) together.
</p>

<p>
<span class="underline">Identity:</span>
</p>
\begin{calc}
     (F \,\Id \, , \, G\, \Id)
\step{ definition of $F$ and $G$ }
     N \, \Id
\step{ $N$ is a functor }
     \Id \,∶\, 𝒟 ^ 𝟚
\step{ identity in arrow categories }
     (\Id , \Id)
\end{calc}

<p>
<span class="underline">Composition:</span>
</p>
\begin{calc}
     ( F (f ⨾ g) , G (f ⨾ g) )
   \step{ definition of $F$ and $G$ }
     N\, (f ⨾ g)
   \step{ $N$ is a functor }
     N\, f  ⨾  N\, g
   \step{ definition of $F$ and $G$ }
     (F\, f, G\, f) ⨾ (F\,g , G\,g)
   \step{ composition in arrow categories }
     (F\,f ⨾ F\,g , G\,f ⨾ G\,g)
\end{calc}

<p>
Sweet!
</p>

<p>
Conversely, given a natural transformation \(η : F \overset{.}{⟶} G\)
we define a functor \(N : 𝒞 ⟶ 𝒟 ^ 𝟚\) by sending objects \(C\) to \(η_C : F\, C ⟶ G\, C\),
which is an object is \(𝒟 ^ 𝟚\), and sending morphisms \(f : A ⟶ B\) to pairs \((G f , F f)\),
which is a morphism in \(𝒟 ^ 𝟚\) due to naturality of η; namely
\(η_A ⨾ G\, f \;=\; F\, f ⨾ η_B\).
It remains to show that \(N\) preserves identities and composition &#x2013;Exercise!
</p>

<p>
Now it remains to show that these two processes are inverses
and the isomorphism claim is complete. Woah!
</p>

<p>
Similarly, to show
\[ \Func\, (𝟚 ⊗ 𝒞) \, 𝒟 \qquad≅\qquad (Σ F₀ , F₁ ∶ 𝒞 ⟶ 𝒟 • \mathsf{NatTrans}\, F₁ \, F₂)\]
</p>

<p>
By setting \(H\, i \;=\; Fᵢ\) on objects and likewise for morphisms
but with \(H(\Id, 1) \;=\; η\) where \(1 : 0 ⟶ 1\) is the non-identity arrow of <code>𝟚</code>.
</p>

<p>
(Spoilers! Alternatively: <code>Arr (Func 𝒞 𝒟) ≅ 𝟚 ⟶ 𝒞 ^ 𝒟 ≅ 𝒞 × 𝟚 ⟶ 𝒟</code> since <code>𝒞𝒶𝓉</code> has exponentials,
   and so the objects are isomorphic; i.e., natural transformations correspond to functors <code>𝒞×𝟚⟶𝒟</code>)
</p>

<p>
Why are we mentioning this alternative statement? Trivia knowledge of-course!
</p>

<p>
On a less relevant note, if you’re familiar with the theory of stretching-without-tearing,
formally known as topology which is pretty awesome, then you might’ve heard of paths and
deformations of paths are known as homotopies which are just continuous functions
\(H : X × I ⟶ Y\) for topological spaces $X, Y,$ and \(I \,=\, [0,1]\) being the unit interval in ℝ.
Letting \(𝒥 = 𝟚\) be the ‘categorical interval’ we have that functors \(𝒞 × 𝒥 ⟶ 𝒟\)
are, by the trivia-relevant result, the same as natural transformations.
That is, <i>natural transformations extend the notion of homotopies, or path-deformations.</i>
</p>

<p>
On <a href="http://mathoverflow.net/a/75686/42716">mathoverflow</a>, the above is recast succinctly as:
   A natural transformation from \(F\) to \(G\) is a functor,
   targeting an arrow category, whose ‘source’
   is \(F\) and whose ‘target’ is \(G\).
   \[
       \hspace{-2em} F \overset{.}{⟶} G : 𝒞 ⟶ 𝒟 \quad≅\quad
       Σ η ∶ 𝒞 ⟶ \mathsf{Arr}\, 𝒟 •\; \mathsf{Src} ∘ η = F \;\;∧\;\; \mathsf{Tgt} ∘ η = G
   \]
   Where, the projection functors
</p>
\begin{align*}
   \mathsf{Src}&                              &:& \mathsf{Arr}\, 𝒟 ⟶ 𝒟
\\ \mathsf{Src}& (A₁ , A₂ , f)                &=& A₁
\\ \mathsf{Src}& (f  , g  , h₁ , h₂ , proofs) &=& h₁
\end{align*}
<p>
with \(\mathsf{Tgt}\) returning the other indexed items.
</p>
</div>
</div>
</div>

<div id="outline-container-org4816151" class="outline-3">
<h3 id="Graphs-as-functors">Graphs as functors</h3>
<div class="outline-text-3" id="text-Graphs-as-functors">
<p>
We give an example of a functor by building on our existing graphs setup.
After showing that graphs correspond to certain functors, we then
mention that the notion of graph-map is nothing more than the associated
natural transformations!
</p>

<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #859900; font-weight: bold;">module</span> graphs<span style="color: #268bd2;">-</span>as<span style="color: #268bd2;">-</span>functors <span style="color: #859900; font-weight: bold;">where</span>
</pre>
</div>

<p>
Let us construct our formal graph category, which contains the ingredients for
a graph and a category and nothing more than the equations needed of a category.
The main ingredients of a two-sorted graph are two sort-symbols <code>E, V</code>, along with
two function-symbols <code>s, t</code> from <code>E</code> to <code>V</code> &#x2014;this is also called ‘the signature
of graphs’. To make this into a category, we need function-symbols <code>id</code> and a composition
for which it is a unit.
</p>
<div class="org-src-container">
<pre class="src src-haskell">  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">formal objects</span>
  <span style="color: #859900; font-weight: bold;">data</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8320; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span> <span style="color: #b58900; font-style: italic;">E</span> <span style="color: #b58900; font-style: italic;">V</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8320;

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">formal arrows</span>
  <span style="color: #859900; font-weight: bold;">data</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8321; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8320; <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8320; <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
     s t <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8321; <span style="color: #b58900; font-style: italic;">E</span> <span style="color: #b58900; font-style: italic;">V</span>
     id  <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {o} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8321; o o

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">(forward) composition</span>
  fcmp <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {a b c} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8321; a b <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8321; b c <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8321; a c
  fcmp f id <span style="color: #268bd2;">=</span> f
  fcmp id f <span style="color: #268bd2;">=</span> f
</pre>
</div>

<p>
Putting it all together,
</p>
<div class="org-src-container">
<pre class="src src-haskell">  <span style="color: #859900; font-weight: bold;">instance</span>
   <span style="color: #b58900; font-style: italic;">&#119970;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span>
   <span style="color: #b58900; font-style: italic;">&#119970;</span> <span style="color: #268bd2;">=</span> record
        { <span style="color: #b58900; font-style: italic;">Obj</span>     <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8320;
        ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span>     <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8321;
        ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span>     <span style="color: #268bd2;">=</span> fcmp
        ; assoc   <span style="color: #268bd2;">=</span> &#955; {a b c d f g h} <span style="color: #268bd2;">&#8594;</span> fcmp<span style="color: #268bd2;">-</span>assoc f g h
        ; <span style="color: #b58900; font-style: italic;">Id</span>      <span style="color: #268bd2;">=</span> id
        ; leftId  <span style="color: #268bd2;">=</span> left<span style="color: #268bd2;">-</span>id
        ; rightId <span style="color: #268bd2;">=</span> right<span style="color: #268bd2;">-</span>id
        }
    <span style="color: #859900; font-weight: bold;">where</span>
       <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">exercises: prove associativity, left and right unit laws</span>
</pre>
</div>

<p>
Now we can show that every graph <code>G</code> gives rise to a functor: A semantics of <code>𝒢</code> in <code>𝒮e𝓉</code>.
</p>
<div class="org-src-container">
<pre class="src src-haskell">  toFunc <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119970;</span> <span style="color: #b58900; font-style: italic;">&#119982;e&#120009;</span>
  toFunc <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">=</span> record
    { obj  <span style="color: #268bd2;">=</span> &#10214;<span style="color: #859900; font-weight: bold;">_</span>&#10215;&#8320;
    ; mor  <span style="color: #268bd2;">=</span> &#10214;<span style="color: #859900; font-weight: bold;">_</span>&#10215;&#8321;
    ; id   <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
    ; comp <span style="color: #268bd2;">=</span> &#955; {x y z f g} <span style="color: #268bd2;">&#8594;</span> fcmp<span style="color: #268bd2;">-&#10814;</span> {x} {y} {z} {f} {g}
    }
    <span style="color: #859900; font-weight: bold;">where</span>
      &#10214;<span style="color: #859900; font-weight: bold;">_</span>&#10215;&#8320; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119970;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119982;e&#120009;</span>
      &#10214; <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8320;<span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">V</span> &#10215;&#8320; <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Graph.V</span> <span style="color: #b58900; font-style: italic;">G</span>
      &#10214; <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8320;<span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">E</span> &#10215;&#8320; <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#931;</span> x <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">Graph.V</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#8226;</span> <span style="color: #b58900; font-style: italic;">&#931;</span> y <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">Graph.V</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#8226;</span> Graph._<span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">G</span> x y

      &#10214;<span style="color: #859900; font-weight: bold;">_</span>&#10215;&#8321; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>} <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#10230;</span> y <span style="color: #268bd2;">&#8594;</span> (&#10214; x &#10215;&#8320; <span style="color: #268bd2;">&#8594;</span> &#10214; y &#10215;&#8320;)
      &#10214; s &#10215;&#8321; (src , tgt , edg) <span style="color: #268bd2;">=</span> src
      &#10214; t &#10215;&#8321; (src , tgt , edg) <span style="color: #268bd2;">=</span> tgt
      &#10214; id &#10215;&#8321; x <span style="color: #268bd2;">=</span> x

      <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Exercise: fcmp is realised as functional composition</span>
      fcmp<span style="color: #268bd2;">-&#10814;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x y z} {f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8321; x y} {g <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8321; y z} <span style="color: #268bd2;">&#8594;</span> &#10214; fcmp f g &#10215;&#8321; <span style="color: #268bd2;">&#8801;</span> &#10214; f &#10215;&#8321; <span style="color: #268bd2;">&#10814;</span> &#10214; g &#10215;&#8321;
</pre>
</div>
<p>
Conversely, every such functor gives a graph whose vertices and edges are the sets
associated with the sort-symbols <code>V</code> and <code>E</code>, respectively.
</p>
<div class="org-src-container">
<pre class="src src-haskell">  fromFunc <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119970;</span> <span style="color: #b58900; font-style: italic;">&#119982;e&#120009;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Graph</span>
  fromFunc <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #268bd2;">=</span> record {
      <span style="color: #b58900; font-style: italic;">V</span>      <span style="color: #268bd2;">=</span> obj <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8320;<span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">V</span>
    ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span>    <span style="color: #268bd2;">=</span> &#955; x y <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#931;</span> e <span style="color: #268bd2;">&#8758;</span> obj <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8320;<span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">E</span> <span style="color: #268bd2;">&#8226;</span> src e <span style="color: #268bd2;">&#8801;</span> x <span style="color: #268bd2;">&#215;</span> tgt e <span style="color: #268bd2;">&#8801;</span> y
             <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">the type of edges whose source is x and target is y</span>
    }
    <span style="color: #859900; font-weight: bold;">where</span> tgt src <span style="color: #b58900; font-style: italic;">:</span> obj <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8320;<span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">E</span> <span style="color: #268bd2;">&#8594;</span> obj <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8320;<span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">V</span>
          src <span style="color: #268bd2;">=</span> mor <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8321;<span style="color: #268bd2;">.</span>s
          tgt <span style="color: #268bd2;">=</span> mor <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">&#119970;</span>&#8321;<span style="color: #268bd2;">.</span>t
</pre>
</div>

<p>
It is to be noted that we can define ‘‘graphs over 𝒞’’ to be the category <code>Func 𝒢 𝒞</code>.
Some consequences are as follows: Notion of graph in any category, the notion of graph-map
is the specialisation of natural transformation (!), and most importantly, all the power of functor categories
is avaiable for the study of graphs.
</p>

<p>
In some circles, you may hear people saying an ‘algebra over the signature of graphs’ is an interpretation
domain (<code>𝒞</code>) and an operation (<code>Functor 𝒢 𝒞</code>) interpreting the symbols. <i>Nice!</i>
</p>
</div>
</div>
</div>
<div id="outline-container-orgfb16ac7" class="outline-2">
<h2 id="A-few-categorical-constructions">A few categorical constructions</h2>
<div class="outline-text-2" id="text-A-few-categorical-constructions">
<p>
We briefly take a pause to look at the theory of category theory.
In particular, we show a pair of constructions to get new categories from old ones,
interpret these constructions from the view of previously mentioned categories, and
discuss how to define the morphism type <code>_⟶_</code> on morphisms themselves, thereby
yielding a functor.
</p>
</div>

<div id="outline-container-orgf300093" class="outline-3">
<h3 id="Opposite">Opposite</h3>
<div class="outline-text-3" id="text-Opposite">
<p>
The ‘dual’ or ‘opposite’ category 𝒞ᵒᵖ is the category constructed from 𝒞 by
reversing arrows: \((A ⟶_{𝒞ᵒᵖ} B) \;≔\; (B ⟶_𝒞 A)\), then necessarily
\((f ⨾_{𝒞ᵒᵖ} g) \;≔\; g ⨾_𝒞 f\).
A ‘contravariant functor’, or ‘cofunctor’, is a functor F from an opposite category and so
there is a reversal of compositions: \(F(f \,⨾\, g) \;=\; F g \,⨾\, F f\).
</p>
<pre class="example">
 _ᵒᵖ : ∀ {i j} → Category {i} {j} → Category
 𝒞 ᵒᵖ = {! exercise !}
</pre>
<p>
Notice that \((𝒞 ᵒᵖ) ᵒᵖ \;=\; 𝒞\) and \(𝒞 ᵒᵖ \;≅\; 𝒞\)
&#x2013;one may have an intuitive idea of what this isomorphsim means,
but formally it is only meaningful in the context of an ambient category; keep reading ;)
</p>

<p>
We must admit that for categories, the notion of isomorphism is considered less useful
than that of equivalence which weakens the condition of the to-from functors being
inverses to just being naturally isomorphic to identities; C.f., ‘evil’ above.
</p>

<p>
Some interpretations:
</p>

<ul class="org-ul">
<li><p>
𝒮e𝓉ᵒᵖ is usual sets and functions but with ‘backwards composition’:
</p>
<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #859900; font-weight: bold;">infix</span> 10 <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8728;</span><span style="color: #859900; font-weight: bold;">_</span>
 <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8728;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j } &#10627; <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j}&#10628; {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #268bd2;">&#8594;</span>  <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">C</span>
 f <span style="color: #268bd2;">&#8728;</span> g <span style="color: #268bd2;">=</span> g <span style="color: #268bd2;">&#10814;</span> f
</pre>
</div>
<p>
Indeed, we have <code>g ⨾ f within 𝒞  =  f ∘ g within 𝒞 ᵒᵖ</code>; which is how these composition operators
 are usually related in informal mathematics (without mention of the ambient categories of course).
</p>

<p>
On a more serious note, the opposite of 𝒮e𝓉 is clearly 𝓉ℯ𝒮 haha
&#x2014;technically for the purposes of this pun we identify the words ‘opposite’ and ‘reverse’.
</p></li>

<li>For a discrete category, its opposite is itself.</li>

<li>For a monoid (viewed as a category), its opposite is itself if the monoid operation is commutative, otherwise
it is the ‘dual monoid’.</li>

<li><p>
For a poset (viewed as a category), its opposite is the ‘dual poset’: \((P, ⊑)ᵒᵖ \;=\; (P, ⊒)\).
</p>

<p>
In particular, the ‘least upper bound’, or ‘supremum’ in \((P, ⊑)\) of two elements
\(x,y\) is an element \(s\) with the ‘universal property’: \(∀ z •\; x ⊑ z ∧ y ⊑ z \;≡\; s ⊑ z\).
However, switching ⊑ with ⊒ gives us the notion of ‘infimum’, ‘greatest upper bound’!
So any theorems about supremums automatically hold for infimums since the infifum is nothing
more than the supremum in the dual category of the poset.
</p>

<p>
It is not difficult to see that this idea of “2 for the price of 1” for theorems holds for all
categories.
</p></li>

<li><b>Stone Duality:</b>
<code>FinBoolAlg ≃ FinSets ᵒᵖ</code> , witnessed by considering the collection of
atoms of a Boolean Algebra in one direction and the power set in the other.
Finiteness can be removed at the cost of completeness and atomicitiy,
<code>CompleteAtomicBoolAlg ≃ 𝒮ℯ𝓉 ᵒᵖ</code>.</li>

<li>What about the category of functors and natural transformations?</li>
</ul>

<p>
Speaking of functors, we can change the type of a functor by <code>ᵒᵖ</code>-ing its source and target,
while leaving it alone,
</p>
<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">this only changes type</span>
 opify <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j i&#8217; j&#8217;} {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j}} {<span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i&#8217;} {j&#8217;}}
      <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> (<span style="color: #b58900; font-style: italic;">&#119966;</span> &#7506;&#7510;) (<span style="color: #b58900; font-style: italic;">&#119967;</span> &#7506;&#7510;)
 opify <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #268bd2;">=</span> record { obj   <span style="color: #268bd2;">=</span>  obj <span style="color: #b58900; font-style: italic;">F</span>
                  ; mor   <span style="color: #268bd2;">=</span>  mor <span style="color: #b58900; font-style: italic;">F</span>
                  ; id    <span style="color: #268bd2;">=</span>  Functor.id <span style="color: #b58900; font-style: italic;">F</span>
                  ; comp  <span style="color: #268bd2;">=</span>  Functor.comp <span style="color: #b58900; font-style: italic;">F</span>
                  }
</pre>
</div>

<blockquote>
<p>
Category Theory is the ‘op’ium of the people!
</p>

<p>
&#x2014; Karl Marx might say it had cats existed in his time
</p>
</blockquote>

<p>
This two definitions seem to indicate that we have some form of opposite-functor … ;)
&#x2014;keep reading!
</p>

<p>
<code>opify</code> seems to show that <code>Functor 𝒞 𝒟 ≡ Functor (𝒞 ᵒᵖ) (𝒟 ᵒᵖ)</code>, or alternatively a
functor can have ‘two different types’ &#x2014;this is akin to using the integers as reals
without writing out the inclusion formally, leaving it implicit; however, in the Agda mechanization
everything must be made explicit &#x2014;the type system doesn’t let you get away with such things.
Professor Maarten Fokkinga has informed me that
the formalization allowing multiple-types is called a
<a href="http://maartenfokkinga.github.io/utwente/mmf92b.pdf">pre-category</a>.
</p>
</div>

<div id="outline-container-org407e1b8" class="outline-4">
<h4 id="ah-yeah-and-dagger-categories">ah-yeah: ∂ and dagger categories</h4>
<div class="outline-text-4" id="text-ah-yeah-and-dagger-categories">
<p>
With <code>𝒞𝒶𝓉</code> in-hand, we can formalise the opposite, or ∂ual, functor:
</p>
<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #268bd2;">&#8706;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> (<span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span> {i} {j}) <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span>
 <span style="color: #268bd2;">&#8706;</span> <span style="color: #268bd2;">=</span> record { obj <span style="color: #268bd2;">=</span> _&#7506;&#7510; ; mor <span style="color: #268bd2;">=</span> opify ; id <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl ; comp <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl }
</pre>
</div>

<p>
Conjecture: Assuming categories are equipped with a contravariant involutionary functor
that is identity on objects, we can show that the identity functor is naturally isomorphic
to the opposite functor.
</p>

<div class="org-src-container">
<pre class="src src-haskell"> ah<span style="color: #268bd2;">-</span>yeah <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j} (<span style="color: #859900; font-weight: bold;">let</span> <span style="color: #b58900; font-style: italic;">Cat</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Obj</span> (<span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span> {i} {j}))
     <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">identity on objects cofunctor, sometimes denoted _&#728;</span>
     <span style="color: #268bd2;">&#8594;</span> (dual <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> (<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Cat</span>) {x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>}  <span style="color: #268bd2;">&#8594;</span>  x <span style="color: #268bd2;">&#10230;</span> y <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>  <span style="color: #268bd2;">&#8594;</span>  y <span style="color: #268bd2;">&#10230;</span> x <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>)
     <span style="color: #268bd2;">&#8594;</span> (<span style="color: #b58900; font-style: italic;">Id</span><span style="color: #268bd2;">&#728;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> &#10627; <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Cat</span> &#10628; {x <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} <span style="color: #268bd2;">&#8594;</span> dual <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">Id</span>  <span style="color: #268bd2;">&#8801;</span>  <span style="color: #b58900; font-style: italic;">Id</span> {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">=</span> x})
     <span style="color: #268bd2;">&#8594;</span> (<span style="color: #268bd2;">&#10814;-&#728;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> &#10627; <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Cat</span> &#10628; {x y z <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} {f <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#10230;</span> y} {g <span style="color: #b58900; font-style: italic;">:</span> y <span style="color: #268bd2;">&#10230;</span> z}
            <span style="color: #268bd2;">&#8594;</span> dual <span style="color: #b58900; font-style: italic;">&#119966;</span> (f <span style="color: #268bd2;">&#10814;</span> g <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>)  <span style="color: #268bd2;">&#8801;</span>  (dual <span style="color: #b58900; font-style: italic;">&#119966;</span> g) <span style="color: #268bd2;">&#10814;</span> (dual <span style="color: #b58900; font-style: italic;">&#119966;</span> f) <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>)
     <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">which is involutionary</span>
     <span style="color: #268bd2;">&#8594;</span> (<span style="color: #268bd2;">&#728;&#728;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> &#10627; <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Cat</span> &#10628; {x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} {f <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#10230;</span> y} <span style="color: #268bd2;">&#8594;</span> dual <span style="color: #b58900; font-style: italic;">&#119966;</span> (dual <span style="color: #b58900; font-style: italic;">&#119966;</span> f) <span style="color: #268bd2;">&#8801;</span> f)
     <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">which is respected by other functors</span>
     <span style="color: #268bd2;">&#8594;</span> (respect <span style="color: #b58900; font-style: italic;">:</span> &#10627; <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Cat</span> &#10628; {<span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>} {x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} {f <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#10230;</span> y}
                <span style="color: #268bd2;">&#8594;</span> mor <span style="color: #b58900; font-style: italic;">F</span> (dual <span style="color: #b58900; font-style: italic;">&#119966;</span> f) <span style="color: #268bd2;">&#8801;</span> dual <span style="color: #b58900; font-style: italic;">&#119967;</span> (mor <span style="color: #b58900; font-style: italic;">F</span> f))
     <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">then</span>
     <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">&#8706;</span> <span style="color: #268bd2;">&#8773;</span> <span style="color: #b58900; font-style: italic;">Id</span> within <span style="color: #b58900; font-style: italic;">Func</span> (<span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span> {i} {j}) <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span>
</pre>
</div>
<pre class="example">
 ah-yeah = {! exercise !}
</pre>
<p>
Some things to note.
</p>

<ul class="org-ul">
<li><p>
Categories whose morphisms are all isomorphisms are called ‘groupoids’ &#x2014;groups are just one-object groupoids.
Consequently, restricted to groupoids the opposite functor is naturally isomorphic to the identity functor!
</p>

<p>
In fact, the group case was the motivator for me to conjecture the theorem, which took a while to prove since I hadn’t
a clue what I needed to assume. Here we’d use <code>a ˘ ≔ a ⁻¹</code>.
</p></li>

<li><p>
Consider the category <code>Rel</code> whose objects are sets and whose morphisms are ‘typed-relations’ \((S, R, T)\),
where \(R\) is a relation from set \(S\) to set \(T\), and
composition is just relational composition
&#x2014;the notion of ‘untyped’, or multi-typed, morphisms is formalized as pre-categories;
see <a href="http://maartenfokkinga.github.io/utwente/mmf92b.pdf">Fokkinga</a>.
Then we can define an endofunctor by taking <code>-˘</code> to be relational converse: \(x \,(R ˘)\, y \;≡\; y \,R\, x\).
Consequently, restricted to the category <code>Rel</code> we have that the opposite functor is naturally isomorphic to the identity functor.
</p></li>
</ul>

<p>
The above items are instance of a more general concept, of course.
</p>

<p>
A category with an involutionary contravariant endofunctor that is the identity on objects
is known as <i>a dagger category, an involutive/star category, or a category with converse</i>
&#x2014;and the functor is denoted as a superscript suffix by <code>†, *, ˘</code>, respectively.
The dagger notation probably comes from
the Hilbert space setting while the converse notation comes from the relation algebra setting.
As far as I know, the first two names are more widely known.
A dagger category bridges the gap between arbitrary categories and groupoids.
</p>

<p>
Just as matrices with matrix multiplication do not form a monoid but rather a category, we have
that not all matrices are invertible but they all admit transposition and so we have a dagger
category. In the same vein, relations admit converse and so give rise to a category with converse.
</p>

<p>
Besides relations and groupoids, other examples include:
</p>
<ul class="org-ul">
<li>discrete categories with the dagger being the identity functor</li>
<li>every monoid with an anti-involution is trivially a dagger category; e.g.,
lists with involution being reverse.</li>
<li>commutative monoids are anti-involutive monoids with anti-involution being identity</li>
</ul>

<p>
Spoilers!! Just as the category of categories is carestian closed, so too is the category of dagger
categories and dagger preserving functors &#x2013;c.f.,the <code>respect</code> premise above.
</p>
</div>
</div>
</div>

<div id="outline-container-org22d4684" class="outline-3">
<h3 id="Products">Products</h3>
<div class="outline-text-3" id="text-Products">
<p>
For any two categories 𝒞 and 𝒟 we can construct their ‘product’ category
\(𝒞 ⊗ 𝒟\) whose objects and morphisms are pairs with components from 𝒞 and 𝒟:
\(\Obj\, (𝒞 ⊗ 𝒟) \;\;=\;\; \Obj\, 𝒞 \,×\, \Obj\, 𝒟\) and
\((A , X) ⟶_{𝒞 ⊗ 𝒟} (B , Y) \;\;=\;\; (A ⟶_𝒞 B) \,×\, (X ⟶_𝒟 Y)\).
</p>
<pre class="example">
 -- we cannot overload symbols in Agda and so using ‘⊗’ in-place of more common ‘×’.
 _⊗_ : ∀ {i j i’ j’} → Category {i} {j} → Category {i’} {j’} → Category
 𝒞 ⊗ 𝒟 = {! exercise !}
</pre>
<p>
Observe that in weaker languages, a category is specified by its objects, morphisms, and composition
&#x2014;the proof obligations are delegated to comments, if they are realized at all.
In such settings, one would need to prove that this construction actually produces a full-fledged
category. Even worse, this proof may be a distance away in some documentation.
With dependent types, our proof obligation is nothing more than another component of the program,
a piece of the category type.
</p>

<p>
In a similar fashion we can show that the sum of two categories is again a category and in general
we have the same for quantified variants: <code>Π 𝒞 ∶ Family • 𝒞</code>, likewise for ‘Σ’.
For the empty family, the empty sum yields the category <code>𝟘</code> with no objects and
the empty product yields the category <code>𝟙</code> of one object.
One can then show the usual ‘laws of arithmetic’ &#x2014;i.e., ×,+ form a commutative monoid, up to isomorphism&#x2014;
hold in this setting: Letting <code>★ ∈ {+,×}</code>, we have
associtivity <code>A ★ (B ★ C) ≅ (A ★ B) ★ C</code>, symmetry <code>A ★ B ≅ B ★ A</code>,
unit <code>𝟙 × A ≅ 𝟘 + A ≅ A</code>, and zero <code>𝟘 × A ≅ 𝟘</code>.
These notions can be defined for any category though the objects may or may not exist
&#x2014; in <code>𝒮e𝓉</code> and <code>𝒢𝓇𝒶𝓅𝒽</code>, for example, they do exist ;) &#x2014;and these associated arithmetical
laws also hold.
</p>

<p>
<i>Question!</i> What of the distributivity law,
<code>A × (B + C) ≅ (A × B) + (A × C)</code>, does it hold in the mentioned cases?
Let <code>𝒫𝒮e𝓉</code> be the category of sets with a distinguished point, i.e.,  <code>Σ S : Obj 𝒮e𝓉 • S</code>, and
functions that preserve the ‘point’, one can then show &#x2014;if he or she so desires, and is not
lazy&#x2014; that this category has notions of product and sum but distributivity fails.
</p>

<p>
Some interpretations:
</p>
<ul class="org-ul">
<li>For discrete categories, this is the usual Cartesian product.</li>
<li>For monoid (or poset) categories, this says that the product of two monoids (or posets) is again
a monoid (respectively poset. This follows since the product does not affect the number of
objects and so the product is again a one-object category, i.e., a monoid (poset respectively).</li>
<li>Interestingly, the <i>sum</i> of two monoids is <b>not</b> formed by their disjoint union: Instead
it is the set of all alternating lists of elements from the two given monoids.
Exercise: Find the associated operation ;-)</li>
</ul>

<p>
As expected, we have projections,
</p>
<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #b58900; font-style: italic;">Fst</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j i&#8217; j&#8217;} {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j}} {<span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i&#8217;} {j&#8217;}}
     <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> (<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">&#8855;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>) <span style="color: #b58900; font-style: italic;">&#119966;</span>
 <span style="color: #b58900; font-style: italic;">Fst</span> <span style="color: #268bd2;">=</span> record { obj <span style="color: #268bd2;">=</span> proj&#8321; ; mor <span style="color: #268bd2;">=</span> proj&#8321; ; id <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl ; comp <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl }

 <span style="color: #b58900; font-style: italic;">Snd</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j i&#8217; j&#8217;} {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j}} {<span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i&#8217;} {j&#8217;}}
     <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> (<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">&#8855;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>) <span style="color: #b58900; font-style: italic;">&#119967;</span>
 <span style="color: #b58900; font-style: italic;">Snd</span> <span style="color: #268bd2;">=</span> record { obj <span style="color: #268bd2;">=</span> proj&#8322; ; mor <span style="color: #268bd2;">=</span> proj&#8322; ; id <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl ; comp <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl }
</pre>
</div>
</div>

<div id="outline-container-orgae174fe" class="outline-4">
<h4 id="Currying">Currying</h4>
<div class="outline-text-4" id="text-Currying">
<p>
For types we have \[ (𝒳 × 𝒴 ⟶ 𝒵) \quad≅\quad (𝒳 ⟶ 𝒵 ^ 𝒴) \quad≅\quad (𝒴 ⟶ 𝒵 ^ 𝒳)\]
Since categories are essentially types endowed with nifty structure,
we expect it to hold in that context as well.
</p>
<pre class="example">
  -- Everyone usually proves currying in the first argument,
  -- let’s rebel and do so for the second argument
 curry₂ : ∀ {ix jx iy jy iz jz}
          {𝒳 : Category {ix} {jx}} {𝒴 : Category {iy} {jy}} {𝒵 : Category {iz} {jz}}
        → Functor (𝒳 ⊗ 𝒴) 𝒵 → Functor 𝒴 (Func 𝒳 𝒵)
 curry₂ = {! exercise !}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgff554b0" class="outline-3">
<h3 id="Pointwise-extensions-and-the-hom-functor">Pointwise extensions and the hom functor</h3>
<div class="outline-text-3" id="text-Pointwise-extensions-and-the-hom-functor">
<p>
Just as addition can be extended to number-valued functions pointwise, \(f + g \;≔\; λ x → f x + g x\),
we can do the same thing with functors.
</p>
<pre class="example">
 -- For bifunctor ‘⊕’ and functors ‘F, G’, we have a functor ‘λ x → F x ⊕ G x’
 pointwise : ∀ {ic jc id jd ix jx iy jy}
   {𝒞 : Category {ic} {jc}} {𝒟 : Category {id} {jd}} {𝒳 : Category {ix} {jx}} {𝒴 : Category {iy} {jy}}
   → Functor (𝒳 ⊗ 𝒴) 𝒟 → Functor 𝒞 𝒳 → Functor 𝒞 𝒴
   → Functor 𝒞 𝒟
 pointwise = {! exercise !}
</pre>
<p>
By ‘extensionality’ <code>p ≡ (proj₁ p , proj₂ p)</code>, we have that the pointwise extension along the projections
is the orginal operation.
</p>
<div class="org-src-container">
<pre class="src src-haskell"> exempli<span style="color: #268bd2;">-</span>gratia <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">&#119987;</span> <span style="color: #b58900; font-style: italic;">&#119988;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {&#8467;&#8320;} {&#8467;&#8320;}} (<span style="color: #268bd2;">&#8853;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Functor</span> (<span style="color: #b58900; font-style: italic;">&#119987;</span> <span style="color: #268bd2;">&#8855;</span> <span style="color: #b58900; font-style: italic;">&#119988;</span>) <span style="color: #b58900; font-style: italic;">&#119967;</span>)
                <span style="color: #268bd2;">&#8594;</span> <span style="color: #859900; font-weight: bold;">let</span> <span style="color: #859900; font-weight: bold;">_</span>&#10216;<span style="color: #268bd2;">&#8853;</span>&#10217;<span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> pointwise <span style="color: #268bd2;">&#8853;</span>
                   <span style="color: #859900; font-weight: bold;">in</span>
                      <span style="color: #b58900; font-style: italic;">Fst</span> &#10216;<span style="color: #268bd2;">&#8853;</span>&#10217; <span style="color: #b58900; font-style: italic;">Snd</span> <span style="color: #268bd2;">&#8801;</span> <span style="color: #268bd2;">&#8853;</span>
 exempli<span style="color: #268bd2;">-</span>gratia <span style="color: #b58900; font-style: italic;">Bi</span> <span style="color: #268bd2;">=</span> funcext (<span style="color: #268bd2;">&#8801;-</span>cong (obj <span style="color: #b58900; font-style: italic;">Bi</span>) <span style="color: #268bd2;">&#8801;-</span>refl) (<span style="color: #268bd2;">&#8801;-</span>cong (mor <span style="color: #b58900; font-style: italic;">Bi</span>) <span style="color: #268bd2;">&#8801;-</span>refl)
</pre>
</div>

<p>
An example bifunctor is obtained by extending the ‘⟶’ to morphisms:
Given <code>f : A ⟶ B , g : C ⟶ D</code> we define <code>(f ⟶ g) : (B ⟶ C) → (A ⟶ C)</code> by
<code>λ h → f ⨾ h ⨾ g</code> as this is the only way to define it so as to meet the type requirements.
</p>
<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #b58900; font-style: italic;">Hom</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j} {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j} } <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> (<span style="color: #b58900; font-style: italic;">&#119966;</span> &#7506;&#7510; <span style="color: #268bd2;">&#8855;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>) (<span style="color: #b58900; font-style: italic;">&#119982;e&#120009;</span> {j})
   <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">hence contravariant in &#8216;first arg&#8217; and covaraint in &#8216;second arg&#8217;</span>
 <span style="color: #b58900; font-style: italic;">Hom</span> {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} <span style="color: #268bd2;">=</span>
   <span style="color: #859900; font-weight: bold;">let</span>
     <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>
     <span style="color: #859900; font-weight: bold;">instance</span> <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> ; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>
     <span style="color: #268bd2;">&#10814;-</span>cong&#8322; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} {f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10230;</span> <span style="color: #b58900; font-style: italic;">B</span>} {g g&#8217; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10230;</span> <span style="color: #b58900; font-style: italic;">C</span>}
             <span style="color: #268bd2;">&#8594;</span> g <span style="color: #268bd2;">&#8801;</span> g&#8217; <span style="color: #268bd2;">&#8594;</span> f <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> g <span style="color: #268bd2;">&#8801;</span> f <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> g&#8217;
     <span style="color: #268bd2;">&#10814;-</span>cong&#8322;  q  <span style="color: #268bd2;">=</span>  <span style="color: #268bd2;">&#8801;-</span>cong&#8322; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.</span><span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">&#8801;-</span>refl q
   <span style="color: #859900; font-weight: bold;">in</span> record {
     obj <span style="color: #268bd2;">=</span> &#955;{ (<span style="color: #b58900; font-style: italic;">A</span> , <span style="color: #b58900; font-style: italic;">B</span>) <span style="color: #268bd2;">&#8594;</span>  <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">B</span> }
   ; mor <span style="color: #268bd2;">=</span> &#955;{ (f , g) <span style="color: #268bd2;">&#8594;</span> &#955; h <span style="color: #268bd2;">&#8594;</span> f <span style="color: #268bd2;">&#10814;</span> h <span style="color: #268bd2;">&#10814;</span> g }
   ; id <span style="color: #268bd2;">=</span> extensionality (&#955; {h} <span style="color: #268bd2;">&#8594;</span> begin
        <span style="color: #b58900; font-style: italic;">Id</span> <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> h <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">Id</span>
      <span style="color: #268bd2;">&#8801;</span>&#10216; leftId &#10217;
        h <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">Id</span>
      <span style="color: #268bd2;">&#8801;</span>&#10216; rightId &#10217;
        h
      <span style="color: #268bd2;">&#8718;</span>)
   ; comp <span style="color: #268bd2;">=</span>  &#955; {x y z fg fg&#8217;} <span style="color: #268bd2;">&#8594;</span>
       <span style="color: #859900; font-weight: bold;">let</span> (f , g) <span style="color: #268bd2;">=</span> fg ; (f&#8217; , g&#8217;) <span style="color: #268bd2;">=</span> fg&#8217; <span style="color: #859900; font-weight: bold;">in</span> extensionality (&#955; {h} <span style="color: #268bd2;">&#8594;</span> begin
            (f&#8217; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> f) <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> h <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> (g <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> g&#8217;)
          <span style="color: #268bd2;">&#8801;</span>&#10216; assoc &#10217;
            f&#8217; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> (f <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> (h <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> (g <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> g&#8217;)))
          <span style="color: #268bd2;">&#8801;</span>&#10216; <span style="color: #268bd2;">&#10814;-</span>cong&#8322; (<span style="color: #268bd2;">&#8801;-</span>sym assoc) &#10217;
            f&#8217; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> ((f <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> h) <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> (g <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> g&#8217;))
          <span style="color: #268bd2;">&#8801;</span>&#10216; <span style="color: #268bd2;">&#10814;-</span>cong&#8322; (<span style="color: #268bd2;">&#8801;-</span>sym assoc) &#10217;
            f&#8217; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> ((f <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> h) <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> g) <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> g&#8217;
          <span style="color: #268bd2;">&#8801;</span>&#10216; <span style="color: #268bd2;">&#10814;-</span>cong&#8322; (<span style="color: #268bd2;">&#8801;-</span>cong&#8322; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.</span><span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> assoc <span style="color: #268bd2;">&#8801;-</span>refl) &#10217;
            f&#8217; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> (f <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> h <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> g) <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> g&#8217;
          <span style="color: #268bd2;">&#8718;</span>)
     }
</pre>
</div>
<p>
The naming probably comes from the algebra/monoid case where the functors are
monoid <code>hom</code>-omorphisms. Some prefer to use the name <code>Mor</code>, short for <code>mor</code>-phisms,
and that’s cool too. While Haskell programmers might call this the <code>Reader</code> functor.
</p>

<p>
Usual notation for this functor is <code>Hom</code>, but I like Fokkinga’s much better.
He uses <code>(_⟶_)</code> and writes <code>(f ⟶ g) = λ h • f ⨾ h ⨾ g</code>
&#x2014;the first argument of Hom is the first argument of the composition and the last
argument to Hom is the last argument of the resulting composition :-)
</p>
</div>
</div>
</div>
<div id="outline-container-orgff09a24" class="outline-2">
<h2 id="𝒮implicity-𝒰nderlies-𝒞omplexity">𝒮implicity 𝒰nderlies 𝒞omplexity</h2>
<div class="outline-text-2" id="text-𝒮implicity-𝒰nderlies-𝒞omplexity">
<blockquote>
<p>
One way is to make it so 𝒮imple that there are obviously no deficiencies, and the other way is to
make it so 𝒞omplicated that there are no obvious deficiencies. The first method is far more
difficult. It demands the same skill, devotion, insight, and even inspiration as the discovery of
the simple physical laws which 𝒰nderlie the complex phenomena of nature.
</p>

<p>
─<a href="https://en.wikiquote.org/wiki/C._A._R._Hoare">C.A.R. Hoare</a>
</p>
</blockquote>

<small>
<div class="org-center">
<p>
( The 𝒞omplex philosophy behinds games such as Chess and
<a href="http://playgo.to/iwtg/en/">Go</a> arise from some 𝒮imple board game rules.
)
</p>
</div>
</small>

<p>
In this section we discuss what it means to be a ‘forgetful functor’?
&#x2013;Also called an `𝒰nderlying functor'.
</p>

<p>
The modifier ‘forgetful’ is meaningful when there’s a notion of extra structure.
Indeed any functor <i>F : 𝒞 ⟶ 𝒮</i> can be thought of as forgetful by construing the objects of
𝒞 as objects of 𝒮 with extra structure.
Mostly: <i>You know it (to be forgetful) when you see it!</i>
</p>
</div>

<div id="outline-container-orgeecdce6" class="outline-3">
<h3 id="Being-forgetful-from-injections-to-faithful-functors">Being forgetful: from injections to faithful functors</h3>
<div class="outline-text-3" id="text-Being-forgetful-from-injections-to-faithful-functors">
<p>
A common example from set theory is the ‘inclusion’ of a subset \(A\) of \(B\), the injection
\(ι : A ↪ B : a ↦ a\) &#x2014;it is essentially a form of ‘type casting’: \(a ∈ A\) and \(ι a \;=\; a ∈ B\).
Such injections ‘forget’ the property that the argument is actually a member of a specified
subset. Indeed, construing sets as categories then functions becomes functors and inclusions
are then forgetful functors!
</p>

<p>
Since a functor <i>F</i> consists of two maps <i>(F₀, F₁) ≔ (obj F, mor F)</i> and some properties, we can speak about properties of the
functor and about properties of either of its maps.
The common definitions are a functor \(F\) is:
</p>
<dl class="org-dl">
<dt>faithful</dt><dd>If its operation on morphisms is <i>injective</i>, and it is</dd>
<dt>full    </dt><dd>If morphisms starting and ending at <i>F</i> are a result of applying \(F\);  <br>
i.e., <i>F₁</i> is surjective <i>on</i> the image of <i>F₀</i>:  <br>
\(∀ x,y ∶ Obj \;•\; ∀ g ∶ F₀ x ⟶ F₀ y \;•\; ∃ f ∶ x ⟶ y \;•\; F₁ f = g\).</dd>
</dl>

<p>
Now we can generalize the previous example.
Every faithful functor <i>F : 𝒞 ⟶ 𝒟</i> can be construed as forgetful:
The 𝒞-maps can be embedded into the 𝒟-maps, since F is faithful, and so can be thought of
as a special sub-collection of the 𝒟-maps; then \(F\) ‘forgets’ the property of being in this
special sub-collection.
</p>

<p>
Are faithful functors in abundance? Well any functor forgetting only axioms
(and/or structure) is faithful:
</p>

<ol class="org-ol">
<li>Suppose 𝒞 consists of 𝒟 objects satisfying some axioms and 𝒟 maps preserving this structure.</li>
<li>That is, 𝒞 has pairs of 𝒟 objects/morphisms with a proof that it satisfies the axioms/preserves-structure.</li>
<li>Then “\(F : 𝒞 ⟶ 𝒟\) forgets only axioms” means \(F\, (f, \mathsf{proof}) \;=\; f\).</li>
<li><p>
Now given, \(F (f , prf) = F (g , prf) \;⇔\; f = g \;⇔\; (f , prf) = (g , prf)\)
&#x2013; equality does not (extensionally) depend on proof components.
</p>

<p>
Hence, faithful :-)
</p>

<p>
(Likewise for forgetting extra structure).
</p></li>
</ol>

<p>
Of course we’re not saying all forgetful functors are necessarily faithful.
A simple counterexample is the absolute value function:
Given a real number \(x\) it’s absolute value \(∣x∣\) is obtained by totally ignoring its sign
&#x2014;of course \(x\) and \(∣x∣\) are equidistant from 0, the relation equidistant-from-0 is an equivalence
relation &#x2013;Exercise!&#x2013;, and so the the two are isomorphic in some sense.
</p>

<p>
Motivated by this, given a set \(S\) it’s size is denoted \(∣ S ∣\) which totally forgets about the
elements of the set &#x2014;of course it can be shown that two sets are isomorphic precisely if they are
equinumerous.
</p>

<p>
I assume it is with these as motivators, some people write \(∣·∣\) for a forgetful functor.
</p>

<p>
( Exercise: A functor <code>F : 𝒞 ≃ 𝒟</code> is (part of) an equivalence iff it is full,
faithful, and ‘‘essentially surjective on objects’’:
 <code>∀ D : Obj 𝒟 • Σ C : Obj 𝒞 • F C ≅ D</code> &#x2014;note the iso. )
</p>
</div>
</div>

<div id="outline-container-org32d8fd1" class="outline-3">
<h3 id="Of-basis-vectors">Of basis vectors</h3>
<div class="outline-text-3" id="text-Of-basis-vectors">
<p>
If you’ve ever studied abstract algebra &#x2014;the math with vector spaces&#x2014; then you may recall that
a collection of vectors ℬ is called a ‘basis’ if every vector can be written as a linear
combination of these vectors: For any vector \(v\), there are scalars \(c₁, …, cₙ\) and vectors
\(b₁, …, bₙ\) in ℬ with \(v \;=\; c₁·b₁ + ⋯ + cₙ·bₙ\). That is, a basis is a collection of ‘building
blocks’ for the vector space. Then any function \(f\) between basis sets immediately lifts to a
linear transformation (think vector space morphism) \(F\) as follows: Given a vector \(v\), since we
have a basis, we can express it as \(c₁·b₁ + ⋯ + cₙ·bₙ\), now define
\(F v \;≔\; c₁·(f\, b₁) + ⋯ + cₙ·(f\, bₙ)\).
</p>

<p>
Sweet!
</p>

<p>
Thus, to define a complicated linear transformation of vector
spaces, it more than suffices to define a plain old simple function of basis sets.
Moreover, by definition, such \(F\) maps basis vectors to basis vectors: \(f \;=\; ι ⨾ F\) where
\(ι : ℬ ↪ 𝒱\) is the inclusion that realises basis vectors as just usual vectors in the vector
space 𝒱.  <b>Slogan:</b>
<i>Vector space maps are determined by where they send their basis, and basis-vectors
are preserved.</i>
</p>

<p>
In the case of <code>(List A, ++, [])</code> we may consider <code>A</code> to be a ‘basis’ of the monoid &#x2014;indeed,
every list can be written as a linear combination of elements of <code>A</code>, given list
<code>[x₁, …, xₙ] : List A</code> we have <code>[x₁, …, xₙ] = x₁ + ⋯ + xₙ</code> where <code>x + y ≔ [x] ++ [y]</code>.
Reasoning similarly as above, or if you have familiarity with <code>foldr , reduce</code>, we have a <b>slogan:</b>
<i>Monoid homomorphisms from lists are determined by where they send their basis and basis-vectors are preserved.</i>
</p>

<p>
Now the general case: <i>\(F ⊣ U\) is a (free-forgetful) ‘adjunction’</i> means
for functors ‘forget’ \(U : 𝒞 ⟶ 𝒮\) and ‘free’ \(F : 𝒮 → 𝒞\), we have that
for a given 𝒮imple-object \(S\) there’s 𝒮imple-map \(ι : S ⟶_𝒮 U\,(F\, S)\) &#x2014;a way to realise ‘basis
vectors’&#x2014; such that for any 𝒞omplicated-object \(C\) and 𝒮imple-maps \(φ : S ⟶_𝒮 U\, C\), there is a
unique 𝒞omplicated-map \(Φ : F\, S ⟶_𝒞 C\) that preserves the basis vectors: \(φ = ι ⨾ U Φ\).
</p>

<p>
By analogy to the previous two cases, we may
consider \(U\, X\) to be a ‘basis’, and make the <b>slogan</b>:
𝒞omplicated-maps from free objects are
determined by where they send their basis and ‘basis vectors’ are preserved.
</p>

<p>
[ In more categorical lingo, one says \(ι\) is the ‘insertion of generators’.
</p>

<p>
  Question: Does the way we took \(ι\) in the previous graph show that it is a natural
  transformation \(ι : \Id ⟶ F ⨾ U\)?
  &#x2014;The naturality just says that a ‘homomorphism’ \(F f\) on the free object is
  completely determined by what \(f\) does to the generators ;-)
]
</p>
</div>
</div>

<div id="outline-container-org9e118fa" class="outline-3">
<h3 id="Of-adjunctions">Of adjunctions</h3>
<div class="outline-text-3" id="text-Of-adjunctions">
<p>
An adjunction \(L ⊣ U\), where the <code>L</code>-ower adjoint is from 𝒮 to 𝒞 and the <code>U</code>-pper adjoint is in
the opposite direction, lends itself to an elemntary interpretation if we consider 𝒞
to be some universe of 𝒞omplicated items of study, while 𝒮 to be a universe of 𝒮imple
items of study. Then adjointness implies that given a simple-object \(S\) and a complicated-object
\(C\), a simple-map \(X ⟶ U\, C\) corresponds to a complicated-map \(L\, S ⟶ C\). To work with
complicated-maps it is more than enough to work with simple-maps!
</p>

<p>
Formally this correspondence, saying \(F : 𝒞 ⟶ 𝒟\) is adjoint to \(G : 𝒟 ⟶ 𝒞\), written \(F ⊣ G\),
holds precisely when \((F ∘ X ⟶ Y) \;≅\; (X ⟶ G ∘ Y)\) in a functor category:
</p>

<div class="org-src-container">
<pre class="src src-haskell"> <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8867;</span>&#8320;<span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j} {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j}} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> (i <span style="color: #268bd2;">&#8845;</span> j)
 <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8867;</span>&#8320;<span style="color: #859900; font-weight: bold;">_</span> {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} {<span style="color: #b58900; font-style: italic;">&#119967;</span>} <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">G</span>
    <span style="color: #268bd2;">=</span>
      (<span style="color: #b58900; font-style: italic;">F</span> <span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">&#8728;</span> <span style="color: #b58900; font-style: italic;">X</span>  <span style="color: #268bd2;">&#10230;</span>&#8345;&#8336;&#8348; <span style="color: #b58900; font-style: italic;">Y</span>)  <span style="color: #268bd2;">&#8773;</span>  (<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#10230;</span>&#8345;&#8336;&#8348; <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#8728;</span> <span style="color: #b58900; font-style: italic;">Y</span>)  within  <span style="color: #b58900; font-style: italic;">Func</span> (<span style="color: #b58900; font-style: italic;">&#119966;</span> &#7506;&#7510; <span style="color: #268bd2;">&#8855;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>) <span style="color: #b58900; font-style: italic;">&#119982;e&#120009;</span>
   <span style="color: #859900; font-weight: bold;">where</span>
     <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Fst</span> ; <span style="color: #b58900; font-style: italic;">Y</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Snd</span> ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">=</span> opify <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">only changes types</span>

     <span style="color: #859900; font-weight: bold;">infix</span> 5 <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span>&#8345;&#8336;&#8348;_
     <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span>&#8345;&#8336;&#8348;_ <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {i j} {<span style="color: #b58900; font-style: italic;">&#119964;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j}} <span style="color: #268bd2;">&#8594;</span>
            <span style="color: #b58900; font-style: italic;">Functor</span> (<span style="color: #b58900; font-style: italic;">&#119966;</span> &#7506;&#7510; <span style="color: #268bd2;">&#8855;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>) (<span style="color: #b58900; font-style: italic;">&#119964;</span> &#7506;&#7510;) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> (<span style="color: #b58900; font-style: italic;">&#119966;</span> &#7506;&#7510; <span style="color: #268bd2;">&#8855;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>) <span style="color: #b58900; font-style: italic;">&#119964;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> (<span style="color: #b58900; font-style: italic;">&#119966;</span> &#7506;&#7510; <span style="color: #268bd2;">&#8855;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>) <span style="color: #b58900; font-style: italic;">&#119982;e&#120009;</span>
     <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span>&#8345;&#8336;&#8348;_ {i} {j} {<span style="color: #b58900; font-style: italic;">&#119964;</span>} <span style="color: #268bd2;">=</span> pointwise (<span style="color: #b58900; font-style: italic;">Hom</span> {i} {j} {<span style="color: #b58900; font-style: italic;">&#119964;</span>})
</pre>
</div>
<p>
Note that if we use Agda's built-in rewrite mechanism to add the rule,
</p>
<pre class="example">
{𝒞 𝒟 : Category {ℓ₀} {ℓ₀}} → Functor (𝒞 ᵒᵖ) (𝒟 ᵒᵖ) ≡ Functor 𝒞 𝒟
</pre>
<p>
then we might be able to get away without using <code>opify</code>.
</p>

<p>
Anyhow, this says for any objects \(X\) and \(Y\), the collection of morphisms \((F\, A ⟶ B)\)
is isomorphic to the collection \((A ⟶ G\, B)\) and naturally so in \(A\) and \(B\).
</p>

<p>
Unfolding it, we have
</p>
<div class="org-src-container">
<pre class="src src-haskell"> record <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8867;</span><span style="color: #859900; font-weight: bold;">_</span> {i j i&#8217; j&#8217;} {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i} {j}} {<span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {i&#8217;} {j&#8217;}}
        (<span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>) (<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>)
        <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> (j&#8217; <span style="color: #268bd2;">&#8845;</span> i&#8217; <span style="color: #268bd2;">&#8845;</span> j <span style="color: #268bd2;">&#8845;</span> i) <span style="color: #859900; font-weight: bold;">where</span>

   open <span style="color: #b58900; font-style: italic;">Category</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> renaming (<span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> to <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span>&#8322;<span style="color: #859900; font-weight: bold;">_</span>)
   open <span style="color: #b58900; font-style: italic;">Category</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> renaming (<span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> to <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span>&#8321;<span style="color: #859900; font-weight: bold;">_</span>)
   field
     <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8216;left-adjunct&#8217;  L &#8776; &#8970;  and  &#8216;right-adjunct&#8217;  r &#8776; &#8968;</span>
     &#8970;<span style="color: #859900; font-weight: bold;">_</span>&#8971; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">Y</span>} <span style="color: #268bd2;">&#8594;</span>   obj <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">Y</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>   <span style="color: #268bd2;">&#8594;</span>   <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#10230;</span> obj <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">Y</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>
     &#8968;<span style="color: #859900; font-weight: bold;">_</span>&#8969; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">Y</span>} <span style="color: #268bd2;">&#8594;</span>   <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#10230;</span> obj <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">Y</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>   <span style="color: #268bd2;">&#8594;</span>   obj <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">Y</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>

     <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Adjuncts are inverse operations</span>
     lid <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">Y</span>} {d <span style="color: #b58900; font-style: italic;">:</span> obj <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">Y</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>} <span style="color: #268bd2;">&#8594;</span> &#8968; &#8970; d &#8971; &#8969; <span style="color: #268bd2;">&#8801;</span> d
     rid <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">Y</span>} {c <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#10230;</span> obj <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">Y</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} <span style="color: #268bd2;">&#8594;</span> &#8970; &#8968; c &#8969; &#8971; <span style="color: #268bd2;">&#8801;</span> c

     <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">That for a fixed argument, are natural transformations between Hom functors</span>
     lfusion <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #b58900; font-style: italic;">D</span>} {f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} {&#968; <span style="color: #b58900; font-style: italic;">:</span> obj <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>} {g <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">D</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>}
             <span style="color: #268bd2;">&#8594;</span>  &#8970; mor <span style="color: #b58900; font-style: italic;">F</span> f <span style="color: #268bd2;">&#10814;</span>&#8322; &#968; <span style="color: #268bd2;">&#10814;</span>&#8322; g &#8971;  <span style="color: #268bd2;">&#8801;</span>  f <span style="color: #268bd2;">&#10814;</span>&#8321; &#8970; &#968; &#8971; <span style="color: #268bd2;">&#10814;</span>&#8321; mor <span style="color: #b58900; font-style: italic;">G</span> g
     rfusion <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #b58900; font-style: italic;">D</span>} {f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} {&#968; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#10230;</span> obj <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} {g <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">C</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">D</span> <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>}
             <span style="color: #268bd2;">&#8594;</span>  &#8968; f <span style="color: #268bd2;">&#10814;</span>&#8321; &#968; <span style="color: #268bd2;">&#10814;</span>&#8321; mor <span style="color: #b58900; font-style: italic;">G</span> g &#8969;  <span style="color: #268bd2;">&#8801;</span>  mor <span style="color: #b58900; font-style: italic;">F</span> f <span style="color: #268bd2;">&#10814;</span>&#8322; &#8968; &#968; &#8969; <span style="color: #268bd2;">&#10814;</span>&#8322; g
</pre>
</div>

<p>
This is easier for verifying an adjunction, while the former is easier for remembering and understanding what an adjunction actually is.
</p>

<p>
As the slogan goes ‘adjunctions are everywhere’.
They can be said to capture the notions of optimization and efficiency, but also that of simplicity.
</p>

<p>
For example, the supremum of a function is defined to be an upper bound of its image set and the least such bound.
Formally, this definition carries a few quantifiers and so a bit lengthy.
More elegantly, we can say the supremum operation is left-adjoint to the constant function: \[ \mathsf{sup} ⊣ 𝒦 \]
which means \[ ∀ z •\qquad \mathsf{sup}\, f \,≤\, z \quad⇔\quad f \overset{.}{≤} 𝒦\, z\]
Where \(𝒦\, x\, y \,=\, x\) and the \(\overset{.}{≤}\) on the right is the point-wise ordering on functions.
This formulation of supremum is not only shorter to write but easier to use in calculational proofs.
</p>

<p>
For the efficiency bit, recall that it is efficient to specify a 𝒮imple-map, then use the adjuction, to obtain
a 𝒞omplicated-map. Recall in the last paragraph how we define the super complicated notion of supremum of a function
in terms of the most elementary constant function!
</p>

<p>
Adjunctions over poset categories are called ‘Galois connections’ and a good wealth of
material on them can be found in nearly any writing by <a href="http://www.cs.nott.ac.uk/~psarb2/papers/papers.html">Backhouse et. al.</a>,
while a very accessible introduction is by <a href="http://www.cs.nott.ac.uk/~psarb2/MPC/galois.ps.gz">Aarts</a>,
and there is also an Agda mechanisation by <a href="http://relmics.mcmaster.ca/RATH-Agda/AContext-2.1.pdf">Kahl &amp; Al-hassy</a>.
</p>

<p>
Regarding forgetful functors:
Generally, but not always, forgetful functors are faithful and have left adjoints
&#x2014;because the notion of ‘forget’ ought to have a corresponding notion of ‘free’.
An exception to this is the category of fields, which has a forgetful functor to the
category of sets with no left adjoint.
</p>
</div>
</div>

<div id="outline-container-orgdbc5e6e" class="outline-3">
<h3 id="Adjunctions-and-Representable-Functors">Adjunctions and Representable Functors</h3>
<div class="outline-text-3" id="text-Adjunctions-and-Representable-Functors">
<p>
Another awesome thing about adjunctions <code>L ⊣ U</code> is that they give us ‘representable functors’,
  a.k.a. ‘the best kind of functors’, when terminal objects exist.
</p>

<ul class="org-ul">
<li>An object <code>𝟙</code> is ‘terminal’ if for any object <code>A</code> there is a unique morphism <code>! {A} : A ⟶ 𝟙</code>.
In 𝒮ℯ𝓉 we have <code>(A ⟶ 𝟙) ≅ 𝟙</code> and <code>(𝟙 ⟶ A) ≅ A</code>.</li>

<li>Specialising the adjunction, where <code>U : 𝒞 ⟶ 𝒮e𝓉</code>, to
a given set <code>A</code> and <code>𝟙</code> we obtain <code>(L 𝟙 ⟶ A) ≅ (𝟙 ⟶ U A) ≅ U A</code> and so one says
‘ <code>U</code> is represented by <code>L 𝟙</code> ’.</li>

<li>In particular, if 𝒞 is built on 𝒮ℯ𝓉 by adding some structure
and we are interested in utilising the elements of an object <code>A</code>
then it suffices to utilise the maps <code>L 𝟙 ⟶ A</code>.</li>
</ul>

<p>
In the case of a free-forgetful adjunction, this says that
  <i>a forgetful functor is represented by the free object with generator <code>𝟙</code>.</i>
</p>

<p>
For example, for monoids the one-point monoid is the terminal object: <code>𝟙 ≔ ({*}, ⊕, *)</code> with <code>x ⊕ y ≔ ⋆</code>.
Then every monoid-homomorphism from <code>𝟙</code> just picks out an element of the carrier of a monoid and so
<code>(𝟙 ⟶ M) ≅ 𝒰 M</code> where <code>𝒰</code> is the forgetful functor for monoids mentioned in the introduction.
</p>
</div>
</div>

<div id="outline-container-orgf1936a9" class="outline-3">
<h3 id="Concluding-remarks">Concluding remarks</h3>
<div class="outline-text-3" id="text-Concluding-remarks">
<p>
A final note about ‘free objects’ &#x2014;arising from an adjoint to a forgetful functor.
</p>

<p>
<b>‘‘The free object is generic’’</b>: The only truths provable for the free
object are precisely those that hold for every complicated-object.
</p>

<p>
(Begin squinting eyes)
 <br>
This follows from the
definition of adjunction which says we can construct a unique morphism between complicated-objects
from a simple-map and by naturality we may transport any proof for the free object to any
complicated object.
 <br>
(Feel ‘free’ to stop squinting your eyes)
</p>


<p>
For futher reading consider reading the adjoint article at <a href="http://www.comicbooklibrary.org/articles/Left_adjoint">the comic book library</a>
and for more on the adjective ‘forgetful’ see <a href="https://ncatlab.org/nlab/show/forgetful+functor">ncatlab</a> or <a href="http://mathworld.wolfram.com/ForgetfulFunctor.html">mathworld</a>
A nice list of common free objects can be found on <a href="https://en.wikipedia.org/wiki/Free_object#List_of_free_objects">wikipedia</a>.
</p>

<p>
You might be asking,
 <i>musa, when am I ever going to encounter this in daily life? In a popular setting?</i>
This concept is everywhere, even inclusions as mentioned earlier are an
instance. For the second question, enjoy listening to
<a href="https://www.youtube.com/watch?v=BipvGD-LCjU">this lovely musical group</a> &#x2013;they use the words ‘forgetful functors’ ;)
</p>

<p>
The remainder of this document can be seen as one fully-worked out example of constructing a
free functor for the forgetful 𝒰 defined above from 𝒞𝒶𝓉 to 𝒢𝓇𝒶𝓅𝒽.
</p>
</div>
</div>
</div>

<div id="outline-container-org1451e0d" class="outline-2">
<h2 id="Designing-Paths">Designing Paths</h2>
<div class="outline-text-2" id="text-Designing-Paths">
<div class="org-center">
<p>
<i>The “right” definition is hard to obtain!</i>
</p>
</div>
<p>
We can now define a ‘path’ of length <code>n</code> in a graph <code>G</code> to be a graph-map
<code>[ n ] ⟶ G</code>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">Path</span>&#8320; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#8469;</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Graph</span>&#8320; <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> (&#8467;suc &#8467;&#8320;)
<span style="color: #b58900; font-style: italic;">Path</span>&#8320; n <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">=</span> [ n ]&#8320; <span style="color: #b58900; font-style: italic;">&#119970;</span><span style="color: #268bd2;">&#10230;</span>&#8320; <span style="color: #b58900; font-style: italic;">G</span>
</pre>
</div>

<p>
Unfolding the definition of graph-morphisms, this just says that a path of length <code>n</code>
consists of a sequence <code>[v₀, v₁, v₂,  …, vₙ]</code> of vertices of <code>G</code> and a sequence <code>[e₀, e₁, …, eₙ₋₁]</code>
of edges of <code>G</code> with typing <code>eᵢ : vᵢ ⟶ vᵢ₊₁</code>.
</p>

<p>
The definition is pretty slick! However, as the name suggests, perhaps we can concatenate paths
and it’s not at all clear how to do this for the vertex- and edge- morphisms of the graph-maps
involved, whereas it’s immediately clear how to do this with sequences: We just concatenate the
sequences and ensure the result is coherent.
</p>

<p>
Since the vertices can be obtained from the edges via <code>src</code> and <code>tgt</code>, we can dispense with them
and use the definition as outlined above.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900;">open</span> <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Data.Vec</span> using (<span style="color: #b58900; font-style: italic;">Vec</span> ; lookup)

<span style="color: #b58900;">record</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8321; (n <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#8469;</span>) (<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span>&#8320;) <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> (&#8467;suc &#8467;&#8320;) <span style="color: #859900; font-weight: bold;">where</span>
  open <span style="color: #b58900; font-style: italic;">Graph</span>&#8320;
  field
    edges     <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Vec</span> (<span style="color: #b58900; font-style: italic;">E</span> <span style="color: #b58900; font-style: italic;">G</span>) (suc n)
    coherency <span style="color: #b58900; font-style: italic;">:</span> {i <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Fin</span> n} <span style="color: #268bd2;">&#8594;</span> tgt <span style="color: #b58900; font-style: italic;">G</span> (lookup (` i) edges) <span style="color: #268bd2;">&#8801;</span> src <span style="color: #b58900; font-style: italic;">G</span> (lookup (fsuc i) edges)
</pre>
</div>
<p>
That is, edges <code>[e₀, …, eₙ]</code> with coherency <code>tgt eᵢ ≡ src eᵢ₊₁</code>.
</p>

<p>
Great, we’ve cut the definition of <code>Path₀</code> in half but that fact that we get a raw list of edges
and then need coherency to ensure that it is a well-formed path is still not terribly lovely.
After all, we’re in Agda, we’re among kings, we should be able to form the list in such a way that
the end result is a path. Let’s do that!
</p>

<p>
Enough of this repetition, let us fix a graph <code>G</code>,
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">Path</span><span style="color: #268bd2;">-</span>definition<span style="color: #268bd2;">-</span>2 (<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span>&#8320;) <span style="color: #859900; font-weight: bold;">where</span>
  open <span style="color: #b58900; font-style: italic;">Graph</span>&#8320; <span style="color: #b58900; font-style: italic;">G</span>

  mutual
    <span style="color: #859900; font-weight: bold;">data</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8322; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
      <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">!</span>   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8322;
      cons <span style="color: #b58900; font-style: italic;">:</span> (v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span>) (e <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">E</span>) (ps <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8322;) (s <span style="color: #b58900; font-style: italic;">:</span> v <span style="color: #268bd2;">&#8801;</span> src e) (t <span style="color: #b58900; font-style: italic;">:</span> tgt e <span style="color: #268bd2;">&#8801;</span> head&#8322; ps) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8322;

    head&#8322; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8322; <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">V</span>
    head&#8322; (v <span style="color: #268bd2;">!</span>) <span style="color: #268bd2;">=</span> v
    head&#8322; (cons v e p s t) <span style="color: #268bd2;">=</span> v
</pre>
</div>

<p>
Defining paths for the parallel-pair approach to graphs leaves us with the need to carry
proofs around, and this is a tad too clunky in this case. Let's try yet again.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">Path</span><span style="color: #268bd2;">-</span>definition<span style="color: #268bd2;">-</span>3 (<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span>) <span style="color: #859900; font-weight: bold;">where</span>

  open <span style="color: #b58900; font-style: italic;">Graph</span> <span style="color: #b58900; font-style: italic;">G</span>

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">handy dandy syntax</span>
  <span style="color: #859900; font-weight: bold;">infixr</span> 5 cons
  syntax cons v ps e <span style="color: #268bd2;">=</span> v <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">v goes, by e, onto path ps</span>

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">we want well-formed paths</span>
  mutual
    <span style="color: #859900; font-weight: bold;">data</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8323; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
      <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">!</span>   <span style="color: #b58900; font-style: italic;">:</span> (v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span>) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8323;
      cons <span style="color: #b58900; font-style: italic;">:</span> (v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span>) (ps <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8323;) (e <span style="color: #b58900; font-style: italic;">:</span> v <span style="color: #268bd2;">&#10230;</span> head&#8323; ps) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8323;

    head&#8323; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8323; <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">V</span>
    head&#8323; (v <span style="color: #268bd2;">!</span>) <span style="color: #268bd2;">=</span> v
    head&#8323; (v <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps) <span style="color: #268bd2;">=</span> v

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">motivation for the syntax declaration above</span>
  example <span style="color: #b58900; font-style: italic;">:</span> (v&#8321; v&#8322; v&#8323; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span>) (e&#8321; <span style="color: #b58900; font-style: italic;">:</span> v&#8321; <span style="color: #268bd2;">&#10230;</span> v&#8322;) (e&#8322; <span style="color: #b58900; font-style: italic;">:</span> v&#8322; <span style="color: #268bd2;">&#10230;</span> v&#8323;) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8323;
  example v&#8321; v&#8322; v&#8323; e&#8321; e&#8322; <span style="color: #268bd2;">=</span> v&#8321; <span style="color: #268bd2;">&#10230;</span>[ e&#8321; ]<span style="color: #268bd2;">&#10230;</span> v&#8322; <span style="color: #268bd2;">&#10230;</span>[ e&#8322; ]<span style="color: #268bd2;">&#10230;</span> v&#8323; <span style="color: #268bd2;">!</span>

  end&#8323; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8323; <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">V</span>
  end&#8323; (v <span style="color: #268bd2;">!</span>) <span style="color: #268bd2;">=</span> v
  end&#8323; (v <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps) <span style="color: #268bd2;">=</span> end&#8323; ps

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">typed paths; squigarrowright</span>
  record <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8669;</span><span style="color: #859900; font-weight: bold;">_</span> (x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span>) <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
    field
      path   <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Path</span>&#8323;
      start  <span style="color: #b58900; font-style: italic;">:</span> head&#8323; path <span style="color: #268bd2;">&#8801;</span> x
      finish <span style="color: #b58900; font-style: italic;">:</span> end&#8323; path  <span style="color: #268bd2;">&#8801;</span> y
</pre>
</div>
<p>
This seems great, but there’s always room for improvement:
</p>


<ul class="org-ul">
<li><p>
Since the <code>cons</code> constructor's third argument depends on its first, we must
use a syntax declaration to get the desired look. Such aesthetic is not only
pleasing but reminiscent of diagrammatic paths;
moreover, it’s guaranteed to be an actual path and not just an
alternating lists of vertices and edges.
Using the clunky <code>Path₂</code>, we’d write
</p>
<pre class="example">
  v₁ ⟶[ v₁≈se₁ , e₁ , te₁≈v₂ ]⟶ v₂ ⟶[ v₂≈se₂ , e₂ , te₂≈v₃ ]⟶ v₃ !
  where
  syntax cons v e ps s t = v ⟶[ s , e , t ]⟶ ps
</pre>
<p>
yuck!
</p>

<p>
Finally, the syntax-declaration does not make the emacs agda-mode auto-case using
the syntax, and so I have to write it out by hand, each time I want to use the syntax.
</p></li>

<li>Again since <code>cons</code>'s third argument depends on the second argument, we need a mutual
definition to extract the item of the dependence. Perhaps if we embed this item at
the type level we may avoid the need of an auxiliary mutually-defined function.</li>

<li>By defining what the start and finish of a path are, we can assign types to it.
However, this approach is reminiscent of the parallel-pair approach to graphs,
as in <code>Graph₀</code>, which we argued is less preferable to the typed-approach to graphs.
Perhaps defining paths with types by default, we can reap the benefits and simplicity
of the typed-approach to graphs.</li>
</ul>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">TypedPaths</span> (<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span>) <span style="color: #859900; font-weight: bold;">where</span>

  open <span style="color: #b58900; font-style: italic;">Graph</span> <span style="color: #b58900; font-style: italic;">G</span> hiding(<span style="color: #b58900; font-style: italic;">V</span>)
  open <span style="color: #b58900; font-style: italic;">Graph</span>   using (<span style="color: #b58900; font-style: italic;">V</span>)

  <span style="color: #859900; font-weight: bold;">data</span> <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8669;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">V</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Set</span> <span style="color: #859900; font-weight: bold;">where</span>
    <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">!</span>      <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#8669;</span> x
    <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span>[<span style="color: #859900; font-weight: bold;">_</span>]<span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x {y &#969;} (e <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#10230;</span> y) (ps <span style="color: #b58900; font-style: italic;">:</span> y <span style="color: #268bd2;">&#8669;</span> &#969;) <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#8669;</span> &#969;
</pre>
</div>

<p>
One might think that since we can write
</p>
<pre class="example">
  src : {x y : V G} (e : x ⟶ y) → V G
  src {x} {y} e = x
</pre>
<p>
we can again ignore vertices and it suffices to just keep a coherent list of edges.
Then what is an empty path at a vertex? This’ enough to keep vertices around
&#x2014;moreover, the ensuing terms look like diagrammatic paths! Cool!
</p>

<div class="org-center">
<p>
Finding this definitional <i>form</i> was a major hurdle in this endeavour.
</p>
</div>
</div>

<div id="outline-container-org8a9444b" class="outline-3">
<h3 id="Aside-An-Adjunction-between-𝒮ℯ𝓉-and-𝒞𝒶𝓉">Aside: An Adjunction between 𝒮ℯ𝓉 and 𝒞𝒶𝓉</h3>
<div class="outline-text-3" id="text-Aside-An-Adjunction-between-𝒮ℯ𝓉-and-𝒞𝒶𝓉">
<p>
With paths in hand, we can now consider a neat sequence of <a href="https://math.stackexchange.com/questions/1640298/coforgetful-functors">exercises</a> :-)
</p>

<ol class="org-ol">
<li><p>
Show that graphmaps preserve paths: <code>(f : G ⟶ H)  → x ⇝ y → fᵥ x ⇝ fᵥ y</code>;
this is nothing more than type-preservation for <code>f</code> to be a functor <code>𝒫G ⟶ 𝒫H</code> ;)
</p>

<p>
Hint: This is <code>lift</code> from the next section.
</p></li>

<li><p>
Define
</p>
<pre class="example">
a connected b  ≡  (a ⇝ b) ⊎ (b ⇝ a)  --  path “between” a and b; not ‘from a to b’.
</pre></li>

<li>This is an equivalence relation whose equivalence classes are called <i>the connected components of G</i>;
denote them by <code>𝒦G</code>.</li>

<li>For any category <code>𝒞</code>, define <code>𝒦 𝒞 ≔ 𝒦 (𝒰₀ 𝒞)</code> which is a subcategory of <code>𝒞</code>.</li>

<li>Phrase the connected components subcategory using a universal property,
thereby avoiding the need for quotient types.</li>

<li>Since graphmaps preserve paths, every graph map can be extended to connected components,
<code>𝒦f : 𝒦G ⟶ 𝒦H : (connected component of x) ↦ (connected component of fᵥ x)</code>.</li>

<li>Hence, we have a functor <code>𝒦 : Graph ⟶ Set</code>.</li>

<li><p>
Then there is a natural transformation <code>𝒱 ⟶ 𝒦</code>, where 𝒱 is the vertices functor.
</p>

<p>
Hint: Such a transformation means we can realise vertices as connected components and this suggests
taking assigning a vertex to the connected-component block that contains it.
</p>

<p>
yeah!
</p></li>
</ol>

<p>
Finally, if we let <code>𝒟 : 𝒮ℯ𝓉 → 𝒞𝒶𝓉</code> be the free category functor that associates each set with
the discrete category over it, then we have <code>𝒦</code> is the associated forgetful functor.
</p>
</div>
</div>

<div id="outline-container-org8f42427" class="outline-3">
<h3 id="Equality-Combinators-for-Paths">Equality Combinators for Paths</h3>
<div class="outline-text-3" id="text-Equality-Combinators-for-Paths">
<p>
Here's a handy-dandy combinator for forming certain equality proofs of paths.
</p>
<div class="org-src-container">
<pre class="src src-haskell">  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Preprend preserves path equality</span>
  <span style="color: #268bd2;">&#10230;-&#8801;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x y &#969;} {e <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#10230;</span> y} {ps qs <span style="color: #b58900; font-style: italic;">:</span> y <span style="color: #268bd2;">&#8669;</span> &#969;}
      <span style="color: #268bd2;">&#8594;</span> ps <span style="color: #268bd2;">&#8801;</span> qs <span style="color: #268bd2;">&#8594;</span> (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps) <span style="color: #268bd2;">&#8801;</span> (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> qs)
  <span style="color: #268bd2;">&#10230;-&#8801;</span> {x} {y} {&#969;} {e} {ps} {qs} eq <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>cong (&#955; r <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> r) eq
</pre>
</div>
<p>
Less usefully, we leave as exercises:
</p>
<pre class="example">
  edges : ∀ {x ω} (p : x ⇝ ω) → List (Σ s ∶ V G • Σ t ∶ V G • s ⟶ t)
  edges = {! exercise !}

  path-eq : ∀ {x y} {p q : x ⇝ y} → edges p ≡ edges q → p ≡ q
  path-eq = {! exercise !}
</pre>
<p>
Given time, <code>path-eq</code> could be rewritten so as to be more easily applicable.
For now, two path equality proofs occur in the document and both are realised by
quick-and-easy induction.
</p>
</div>
</div>

<div id="outline-container-org32eca0e" class="outline-3">
<h3 id="Category-of-paths-over-a-graph">Category of paths over a graph</h3>
<div class="outline-text-3" id="text-Category-of-paths-over-a-graph">
<p>
Now we turn back to the problem of <a href="https://english.stackexchange.com/a/125659/327685">catenating</a> two paths.
</p>
<div class="org-src-container">
<pre class="src src-haskell">  <span style="color: #859900; font-weight: bold;">infixr</span> 5 <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">++</span><span style="color: #859900; font-weight: bold;">_</span>

  <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">++</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x y z} <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#8669;</span> y <span style="color: #268bd2;">&#8594;</span> y <span style="color: #268bd2;">&#8669;</span> z <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#8669;</span> z
  x <span style="color: #268bd2;">!</span> <span style="color: #268bd2;">++</span> q           <span style="color: #268bd2;">=</span> q                         <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">left unit</span>
  (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> p) <span style="color: #268bd2;">++</span> q <span style="color: #268bd2;">=</span> x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> (p <span style="color: #268bd2;">++</span> q)     <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">mutual-associativity</span>
</pre>
</div>
<p>
Notice that the the base case indicate that <code>!</code> forms a left-unit for <code>++</code>,
while the inductive case says that path-formation associates with path catenation.
Both observations also hold for the definition of list catenation ;-)
</p>

<p>
If we had not typed our paths, as in <code>Path₂</code>, we would need to carry around a
proof that paths are compatible for concatenation:
</p>
<pre class="example">
  catenate : (p q : Path) (coh : end p ≡ head q) → Path
  syntax catenate p q compatibility = p ++[ compatibility ] q
</pre>
<p>
Even worse, to show <code>p ++[ coh ] q ≡ p ++[ coh’ ] q</code> we need to invoke proof-irrelevance of
identity proofs to obtain <code>coh ≡ coh’</code>, each time we want such an equality! Moving the proof
obligation to the type level removes this need.
</p>

<p>
As can be seen, being type-less is a terrible ordeal.
</p>

<p>
Just as the first clause of <code>_++_</code> indicates <code>_!</code> is a left unit,
</p>
<div class="org-src-container">
<pre class="src src-haskell">  leftId <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {x y} {p <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#8669;</span> y} <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">!</span> <span style="color: #268bd2;">++</span> p <span style="color: #268bd2;">&#8801;</span> p
  leftId <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
</pre>
</div>
<p>
Is it also a right identity?
</p>
<div class="org-src-container">
<pre class="src src-haskell">  rightId <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {x y} {p <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#8669;</span> y} <span style="color: #268bd2;">&#8594;</span> p <span style="color: #268bd2;">++</span> y <span style="color: #268bd2;">!</span> <span style="color: #268bd2;">&#8801;</span> p
  rightId {x} {<span style="color: #268bd2;">.</span>x} {<span style="color: #268bd2;">.</span>x <span style="color: #268bd2;">!</span>} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
  rightId {x} {y } {<span style="color: #268bd2;">.</span>x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>cong (&#955; q <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> q) rightId
</pre>
</div>

<p>
Is this operation associative?
</p>
<div class="org-src-container">
<pre class="src src-haskell">  assoc <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x y z &#969;} {p <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#8669;</span> y} {q <span style="color: #b58900; font-style: italic;">:</span> y <span style="color: #268bd2;">&#8669;</span> z} {r <span style="color: #b58900; font-style: italic;">:</span> z <span style="color: #268bd2;">&#8669;</span> &#969;}
        <span style="color: #268bd2;">&#8594;</span> (p <span style="color: #268bd2;">++</span> q) <span style="color: #268bd2;">++</span> r <span style="color: #268bd2;">&#8801;</span> p <span style="color: #268bd2;">++</span> (q <span style="color: #268bd2;">++</span> r)
  assoc {x} {p <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">.</span>x <span style="color: #268bd2;">!</span>} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
  assoc {x} {p <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">.</span>x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps} {q} {r} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>cong (&#955; s <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> s) (assoc {p <span style="color: #268bd2;">=</span> ps})
</pre>
</div>

<p>
Hence, we’ve shown that the paths over a graph <code>G</code> constitute a category! Let’s call it <code>𝒫 G</code>.
</p>
</div>
</div>

<div id="outline-container-orgc341582" class="outline-3">
<h3 id="The-𝒫ath-to-freedom">The 𝒫ath to freedom</h3>
<div class="outline-text-3" id="text-The-𝒫ath-to-freedom">
<p>
In the last section, we showed that the paths over a graph make a category,
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">&#119979;</span>&#8320; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Category</span>
<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8320; <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">=</span> <span style="color: #859900; font-weight: bold;">let</span> open <span style="color: #b58900; font-style: italic;">TypedPaths</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #859900; font-weight: bold;">in</span>
    record
      { <span style="color: #b58900; font-style: italic;">Obj</span>     <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Graph.V</span> <span style="color: #b58900; font-style: italic;">G</span>
      ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span>     <span style="color: #268bd2;">=</span> <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8669;</span><span style="color: #859900; font-weight: bold;">_</span>
      ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span>     <span style="color: #268bd2;">=</span> <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">++</span><span style="color: #859900; font-weight: bold;">_</span>
      ; assoc   <span style="color: #268bd2;">=</span> &#955; {x y z &#969; p q r} <span style="color: #268bd2;">&#8594;</span> assoc {p <span style="color: #268bd2;">=</span> p}
      ; <span style="color: #b58900; font-style: italic;">Id</span>      <span style="color: #268bd2;">=</span> &#955; {x} <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">!</span>
      ; leftId  <span style="color: #268bd2;">=</span> leftId
      ; rightId <span style="color: #268bd2;">=</span> rightId
      }
</pre>
</div>

<p>
Can we make <code>𝒫</code> into a functor by defining it on morphisms?
That is, to lift graph-maps to category-maps, i.e., functors.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span>} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">GraphMap</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">Functor</span> (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8320; <span style="color: #b58900; font-style: italic;">G</span>) (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8320; <span style="color: #b58900; font-style: italic;">H</span>)
<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; {<span style="color: #b58900; font-style: italic;">G</span>} {<span style="color: #b58900; font-style: italic;">H</span>} f <span style="color: #268bd2;">=</span> record
    { obj  <span style="color: #268bd2;">=</span> ver f
    ; mor  <span style="color: #268bd2;">=</span> amore
    ; id   <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
    ; comp <span style="color: #268bd2;">=</span> &#955; {x} {y} {z} {p} <span style="color: #268bd2;">&#8594;</span> comp {p <span style="color: #268bd2;">=</span> p}
    }
    <span style="color: #859900; font-weight: bold;">where</span>
      open <span style="color: #b58900; font-style: italic;">TypedPaths</span> &#10627;<span style="color: #268bd2;">...</span>&#10628; public
      <span style="color: #859900; font-weight: bold;">instance</span> <span style="color: #b58900; font-style: italic;">G'</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span> ; <span style="color: #b58900; font-style: italic;">G'</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">G</span>
               <span style="color: #b58900; font-style: italic;">H'</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span> ; <span style="color: #b58900; font-style: italic;">H'</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">H</span>

      amore <span style="color: #b58900; font-style: italic;">:</span> {x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph.V</span> <span style="color: #b58900; font-style: italic;">G</span>} <span style="color: #268bd2;">&#8594;</span>  x <span style="color: #268bd2;">&#8669;</span> y <span style="color: #268bd2;">&#8594;</span> (ver f x) <span style="color: #268bd2;">&#8669;</span> (ver f y)
      amore (x <span style="color: #268bd2;">!</span>) <span style="color: #268bd2;">=</span> ver f x <span style="color: #268bd2;">!</span>
      amore (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> p) <span style="color: #268bd2;">=</span> ver f x <span style="color: #268bd2;">&#10230;</span>[ edge f e ]<span style="color: #268bd2;">&#10230;</span> amore p

      comp <span style="color: #b58900; font-style: italic;">:</span> {x y z <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph.V</span> <span style="color: #b58900; font-style: italic;">G</span>} {p <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#8669;</span> y} {q <span style="color: #b58900; font-style: italic;">:</span> y <span style="color: #268bd2;">&#8669;</span> z}
          <span style="color: #268bd2;">&#8594;</span>  amore (p <span style="color: #268bd2;">++</span> q)  <span style="color: #268bd2;">&#8801;</span>  amore p <span style="color: #268bd2;">++</span> amore q
      comp {x} {p <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">.</span>x <span style="color: #268bd2;">!</span>} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">since ! is left unit of ++</span>
      comp {x} {p <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">.</span>x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#10230;-&#8801;</span> (comp {p <span style="color: #268bd2;">=</span> ps})
</pre>
</div>
<p>
Sweet!
</p>

<p>
With these two together, we have that <code>𝒫</code> is a functor.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">&#119979;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span> <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span>
<span style="color: #b58900; font-style: italic;">&#119979;</span> <span style="color: #268bd2;">=</span> record { obj   <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119979;</span>&#8320;
            ; mor  <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321;
            ; id   <span style="color: #268bd2;">=</span> &#955; {<span style="color: #b58900; font-style: italic;">G</span>} <span style="color: #268bd2;">&#8594;</span> funcext <span style="color: #268bd2;">&#8801;-</span>refl (id &#10627; <span style="color: #b58900; font-style: italic;">G</span> &#10628;)
            ; comp <span style="color: #268bd2;">=</span> funcext <span style="color: #268bd2;">&#8801;-</span>refl comp
            }
    <span style="color: #859900; font-weight: bold;">where</span>
      open <span style="color: #b58900; font-style: italic;">TypedPaths</span> &#10627;<span style="color: #268bd2;">...</span>&#10628;
      open <span style="color: #b58900; font-style: italic;">Category</span>   &#10627;<span style="color: #268bd2;">...</span>&#10628;

      <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span>   <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span>
      <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span>

      id <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> &#10627; <span style="color: #b58900; font-style: italic;">G</span> &#10628; {x y} {p <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#8669;</span> y}
        <span style="color: #268bd2;">&#8594;</span>   mor (<span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">Id</span> {<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8320; <span style="color: #b58900; font-style: italic;">G</span>}) p  <span style="color: #268bd2;">&#8801;</span>  mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; (<span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">Id</span>)) p
      id {p <span style="color: #268bd2;">=</span> x <span style="color: #268bd2;">!</span>} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
      id {p <span style="color: #268bd2;">=</span> x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#10230;-&#8801;</span> (id {p <span style="color: #268bd2;">=</span> ps})

      comp <span style="color: #b58900; font-style: italic;">:</span> {<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span> <span style="color: #b58900; font-style: italic;">K</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span>} {f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">GraphMap</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span>} {g <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">GraphMap</span> <span style="color: #b58900; font-style: italic;">H</span> <span style="color: #b58900; font-style: italic;">K</span>}
           <span style="color: #268bd2;">&#8594;</span> {x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph.V</span> <span style="color: #b58900; font-style: italic;">G</span>} {p <span style="color: #b58900; font-style: italic;">:</span> TypedPaths._<span style="color: #268bd2;">&#8669;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">G</span> x y}
           <span style="color: #268bd2;">&#8594;</span>  mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; f <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g) p  <span style="color: #268bd2;">&#8801;</span>  mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; (f <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> g)) p
      comp {p <span style="color: #268bd2;">=</span> x <span style="color: #268bd2;">!</span>} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
      comp {p <span style="color: #268bd2;">=</span> x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#10230;-&#8801;</span> (comp {p <span style="color: #268bd2;">=</span> ps})
</pre>
</div>

<p>
It seemed prudent in this case to explicitly delimit where the compositions lives
&#x2014;this is for clarity, since Agda can quickly resolve the appropriate category instances.
</p>

<p>
Exercise: Show that we have a natural transformation <code>Id ⟶ 𝒰 ∘ 𝒫</code>.
</p>
</div>
</div>
</div>
<div id="outline-container-org493785c" class="outline-2">
<h2 id="Free-at-last">Free at last</h2>
<div class="outline-text-2" id="text-Free-at-last">
<blockquote>
<p>
Free at last, free at last, thank God almighty we are free at last.
</p>

<p>
&#x2013; Martin Luther King Jr.
</p>
</blockquote>

<p>
Recall why lists give the ‘free monoid’: We can embed a type \(A\) into \(\List A\) by the map \([\_{}]\),
and we can lift any map \(f : A ⟶ B\) to a monoid map
\[\foldr \; (λ a b → f\, a ⊕ b)\; e \;:\; (\List A ,\_{}++\_{} , []) \,⟶\, (B,\_{}⊕\_{} , e)\]
I.e., \([a₁, …, aₖ] \;↦\; f\, a₁ ⊕ ⋯ ⊕ f\, aₖ\). Moreover
this ‘preserves the basis’ \(A\)
&#x2013; i.e., \(∀ a •\; f\, a \,=\, \foldr \,f \,e \, [ a ]\) &#x2013;
and this lifted map is unique.
</p>

<p>
Likewise, let us show that \(𝒫G\) is the ‘free category’ over the graph \(G\).
This amounts to saying that there is a way, a graph-map, say \(ι\), that embeds \(G\) into \(𝒫G\),
and a way to lift any graph-map \(f \,:\, G \,𝒢⟶\, 𝒰₀ 𝒞\) to a functor \(\mathsf{lift}\, f : 𝒫G ⟶ 𝒞\)
that ‘preserves the basis’ \(f \;=\; ι ⨾ 𝒰₁ (\mathsf{lift}\, f)\) and uniquely so.
</p>

<p>
Let’s begin!
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">module</span> freedom (<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Obj</span> <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span>) {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {&#8467;&#8320;} {&#8467;&#8320;} } <span style="color: #859900; font-weight: bold;">where</span>

  open <span style="color: #b58900; font-style: italic;">TypedPaths</span> <span style="color: #b58900; font-style: italic;">G</span> using (<span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">!</span> ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span>[<span style="color: #859900; font-weight: bold;">_</span>]<span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> ;  <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8669;</span><span style="color: #859900; font-weight: bold;">_</span> ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">++</span><span style="color: #859900; font-weight: bold;">_</span>)
  open <span style="color: #b58900; font-style: italic;">Category</span> &#10627;<span style="color: #268bd2;">...</span>&#10628;

  <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span>
  <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> (<span style="color: #b58900; font-style: italic;">&#119982;e&#120009;</span> {&#8467;&#8320;})
  <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>
  <span style="color: #859900; font-weight: bold;">instance</span> <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> ; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>
</pre>
</div>
</div>

<div id="outline-container-org53f94c6" class="outline-3">
<h3 id="Defining-the-needed-operations">Defining the needed operations</h3>
<div class="outline-text-3" id="text-Defining-the-needed-operations">
<p>
The only obvious, and most natural, way to embed a graph into its ‘graph of paths’ is to send
vertices to vertices and edges to paths of length 1.
</p>

<div class="org-src-container">
<pre class="src src-haskell">  &#953; <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8320; (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8320; <span style="color: #b58900; font-style: italic;">G</span>)
  &#953; <span style="color: #268bd2;">=</span> record { ver <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Id</span> ; edge <span style="color: #268bd2;">=</span> &#955; {x} {y} e  <span style="color: #268bd2;">&#8594;</span>  x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> (y <span style="color: #268bd2;">!</span>) }
</pre>
</div>

<p>
Given a graph map \(f\), following the list-analagoue of \([a₁, …, aₖ] \;↦\; f\, a₁ ⊕ ⋯ ⊕ f\, aₖ\)
we attempt to lift the map onto paths by taking the edges \(e₁, …, eₖ\) of a path
to a morphism \(\edge\, f\, e₁ ⨾ ⋯ ⨾ \edge\, f\, eₖ\).
That is, a path of the form
\[x_0 \xrightarrow{e_1} x_1 \xrightarrow{e_2} x_2 \xrightarrow{e_3} ⋯ \xrightarrow{e_k} x_k \]
Is lifted to the composition of morphisms
\[\mathsf{ver}\, f\, x_0 \xrightarrow{\edge\, f\, e_1}
   \mathsf{ver}\, f\, x_1 \xrightarrow{\edge\, f\, e_2}
   \mathsf{ver}\, f\, x_2 \xrightarrow{\edge\, f\, e_3} ⋯ \xrightarrow{\edge\, f\, e_k}
   \mathsf{ver}\, f\, x_k \]
</p>

<p>
Of course, we then need to verify that this construction is indeed
functorial.
</p>

<div class="org-src-container">
<pre class="src src-haskell">  lift <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8320; <span style="color: #b58900; font-style: italic;">&#119966;</span>  <span style="color: #268bd2;">&#8594;</span>  <span style="color: #b58900; font-style: italic;">&#119979;</span>&#8320; <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>
  lift f <span style="color: #268bd2;">=</span> record
     { obj  <span style="color: #268bd2;">=</span> &#955; v <span style="color: #268bd2;">&#8594;</span> ver f v <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Only way to obtain an object of &#119966;; hope it works!</span>
     ; mor  <span style="color: #268bd2;">=</span> fmap
     ; id   <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
     ; comp <span style="color: #268bd2;">=</span> &#955; {x y z p q} <span style="color: #268bd2;">&#8594;</span> proof {x} {y} {z} {p} {q}
     }
     <span style="color: #859900; font-weight: bold;">where</span>
          fmap <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {x y} <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#8669;</span> y <span style="color: #268bd2;">&#8594;</span> ver f x <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10230;</span> ver f y
          fmap (y <span style="color: #268bd2;">!</span>) <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.</span><span style="color: #b58900; font-style: italic;">Id</span>
          fmap (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> p) <span style="color: #268bd2;">=</span> edge f e <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> fmap p

          <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">homomorphism property</span>
          proof <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x y z} {p <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#8669;</span> y} {q <span style="color: #b58900; font-style: italic;">:</span> y <span style="color: #268bd2;">&#8669;</span> z} <span style="color: #268bd2;">&#8594;</span> fmap (p <span style="color: #268bd2;">++</span> q) <span style="color: #268bd2;">&#8801;</span> fmap p <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> fmap q
          proof {p <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">.</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">!</span>} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>sym <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.</span>leftId
          proof {p <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">.</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps} <span style="color: #268bd2;">=</span>  <span style="color: #268bd2;">&#8801;-</span>cong (&#955; m <span style="color: #268bd2;">&#8594;</span> edge f e <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> m) (proof {p <span style="color: #268bd2;">=</span> ps})
                                     &#10216;<span style="color: #268bd2;">&#8801;&#8801;</span>&#10217; <span style="color: #268bd2;">&#8801;-</span>sym assoc
                                     <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Exercise: Rewrite this calculationally!</span>
</pre>
</div>

<p>
Now we have the embedding and the lifting, it remains to show that the aforementioned
‘preserves basis’ property holds as does uniqueness.
</p>
</div>
</div>

<div id="outline-container-orgbc349b2" class="outline-3">
<h3 id="Realising-the-proof-obligations">Realising the proof-obligations</h3>
<div class="outline-text-3" id="text-Realising-the-proof-obligations">
<p>
Let's begin with the ‘basis preservation’ property:
</p>

<div class="org-src-container">
<pre class="src src-haskell">  property <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8320; <span style="color: #b58900; font-style: italic;">&#119966;</span>}  <span style="color: #268bd2;">&#8594;</span>  f  <span style="color: #268bd2;">&#8801;</span>  (&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; (lift f))
  property {f} <span style="color: #268bd2;">=</span> graphmapext
    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Proving: &#8704; {v} &#8594; ver f v &#8801; ver (&#953; &#119966;.&#10814; &#119984;&#8321; (lift f)) v</span>
    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">by starting at the complicated side and simplifying</span>
    (&#955; {v} <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">&#8801;-</span>sym (begin
              ver (&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; (lift f)) v
            <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of ver on composition "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
              (ver &#953; <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> ver (<span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; (lift f))) v
            <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of &#119984;&#8321; says: ver (&#119984;&#8321; F) = obj F "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
              (ver &#953; <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> obj (lift f)) v
            <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of lift says: obj (lift f) = ver f "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
              (ver &#953; <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> ver f) v
            <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of &#953; on vertices is identity "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
              ver f v
            <span style="color: #268bd2;">&#8718;</span>))

    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Proving: edge (&#953; &#10814;g &#119984;&#8321; (lift f)) e &#8801; edge f e</span>
    (&#955; {x} {y} {e} <span style="color: #268bd2;">&#8594;</span> begin
               edge (&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; (lift f)) e
             <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of edge on composition "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
               (edge &#953; <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> edge (<span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; (lift f))) e
             <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of &#119984; says: edge (&#119984;&#8321; F) = mor F "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
               (edge &#953; <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> mor (lift f)) e
             <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition chasing gives: mor (lift f) (edge &#953; e) = edge f e &#10814; Id "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
               edge f e <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">Id</span>
             <span style="color: #268bd2;">&#8801;</span>&#10216; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.</span>rightId &#10217;
               edge f e
             <span style="color: #268bd2;">&#8718;</span>)
</pre>
</div>

<p>
Observe that we simply chased definitions and as such <code>graphmapext ≡-refl rightId</code> suffices as a proof,
but it’s not terribly clear why, for human consumption, and so we choose to elaborate with the
detail.
</p>

<p>
Finally, it remains to show that there is a unique way to preserve ‘basis’:
</p>

<div class="org-src-container">
<pre class="src src-haskell">  uniqueness <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8320; <span style="color: #b58900; font-style: italic;">&#119966;</span>} {<span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#119979;</span>&#8320; <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #268bd2;">&#10230;</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>} <span style="color: #268bd2;">&#8594;</span> f <span style="color: #268bd2;">&#8801;</span> (&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>) <span style="color: #268bd2;">&#8594;</span> lift f <span style="color: #268bd2;">&#8801;</span> <span style="color: #b58900; font-style: italic;">F</span>
  uniqueness {<span style="color: #268bd2;">.</span>(&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>)} {<span style="color: #b58900; font-style: italic;">F</span>} <span style="color: #268bd2;">&#8801;-</span>refl <span style="color: #268bd2;">=</span> funcext <span style="color: #268bd2;">&#8801;-</span>refl (<span style="color: #268bd2;">&#8801;-</span>sym pf)
    <span style="color: #859900; font-weight: bold;">where</span>
      pf <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x y} {p <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#8669;</span> y} <span style="color: #268bd2;">&#8594;</span>  mor (lift (&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>)) p  <span style="color: #268bd2;">&#8801;</span>  mor <span style="color: #b58900; font-style: italic;">F</span> p
      pf {x} {<span style="color: #268bd2;">.</span>x} {p <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">.</span>x <span style="color: #268bd2;">!</span>} <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>sym (Functor.id <span style="color: #b58900; font-style: italic;">F</span>)
      pf {x} {y} {p <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">.</span>x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps} <span style="color: #268bd2;">=</span> begin
         mor (lift (&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>)) (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps)
       <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of mor on lift, the inductive clause "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
         edge (&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>) e <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> mor (lift (&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>)) ps
       <span style="color: #268bd2;">&#8801;</span>&#10216; <span style="color: #268bd2;">&#8801;-</span>cong&#8322; <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.</span><span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">&#8801;-</span>refl (pf {p <span style="color: #268bd2;">=</span> ps}) &#10217; <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">inductive step</span>
         edge (&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>) e <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> mor <span style="color: #b58900; font-style: italic;">F</span> ps
       <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of edge says it preserves composition "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
         (edge &#953; <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> edge (<span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>)) e <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> mor <span style="color: #b58900; font-style: italic;">F</span> ps
       <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of &#119984; gives: edge (&#119984;&#8321; F) = mor F "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
         (edge &#953; <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> mor <span style="color: #b58900; font-style: italic;">F</span>) e <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> mor <span style="color: #b58900; font-style: italic;">F</span> ps
       <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of functional composition &#119982;&#8495;&#120009; "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
          mor <span style="color: #b58900; font-style: italic;">F</span> (edge &#953; e) <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> mor <span style="color: #b58900; font-style: italic;">F</span> ps
       <span style="color: #268bd2;">&#8801;</span>&#10216; <span style="color: #268bd2;">&#8801;-</span>sym (Functor.comp <span style="color: #b58900; font-style: italic;">F</span>) <span style="color: #96A7A9; font-style: italic;">{- </span><span style="color: #96A7A9; font-style: italic;">i.e., functors preserve composition -}</span> &#10217;
          mor <span style="color: #b58900; font-style: italic;">F</span> (edge &#953; e <span style="color: #268bd2;">++</span> ps)
       <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of embedding and concatenation "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
         mor <span style="color: #b58900; font-style: italic;">F</span> (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps)
       <span style="color: #268bd2;">&#8718;</span>
</pre>
</div>

<p>
Challenge:
Define graph-map equality ‘≈g’ by <i>extensionality</i> &#x2013;two graph maps are equal iff
their vertex <i>and</i> edge maps are extensionally equal. This is far more relaxed
than using propositional equality ‘≡’. Now show the stronger uniqueness claim:
</p>
<pre class="example">
∀{f : G ⟶ 𝒰₀ 𝒞} {F : 𝒫₀ G ⟶ 𝒞}   →   f  ≈g  (ι ⨾ 𝒰₁ F)   →   lift f  ≡  F
</pre>
</div>
</div>

<div id="outline-container-org55844ea" class="outline-3">
<h3 id="Another-freedom-proof">Another freedom proof</h3>
<div class="outline-text-3" id="text-Another-freedom-proof">
<p>
However, saying each graph-map gives rise to exactly one unique functor is tantamount to
saying the type <code>GraphMap G (𝒰₀ 𝒞)</code> is isomorphic to <code>Functor (𝒫₀ G) 𝒞</code>, that is
<code>(𝒫₀ G ⟶ 𝒞) ≅ (G ⟶ 𝒰₀ 𝒞)</code> &#x2014;observe that this says we can ‘move’ <code>𝒫₀</code> from the left to
the right of an arrow at the cost of it (and the arrow) changing.
</p>

<p>
A few healthy exercises,
</p>

<pre class="example">
  lift˘ : Functor 𝒫G 𝒞 → GraphMap G (𝒰₀ 𝒞)
  lift˘ F = ι ⨾g 𝒰₁ F  --  i.e., record {ver = obj F , edge = mor F ∘ edge ι}

  rid : ∀{f : GraphMap G (𝒰₀ 𝒞)} → ∀{x y} {e : x ⟶g y} → lift˘ (lift f) ≡ f
  rid = {! exercise !}

  lid : ∀{F : Functor 𝒫G 𝒞} → lift (lift˘ F) ≡ F
  lid = {! exercise !}
</pre>

<p>
One can of course obtain these proofs from the other ones without recourse to definitions,
however for comprehension one would do well to prove them from first principles.
The worked out solutions are available in the literate source file of this document.
</p>

<p>
We can then provide an alternative, and more succinct, proof of uniqueness for ‘basis preservation’:
</p>

<div class="org-src-container">
<pre class="src src-haskell">  uniqueness&#8217;  <span style="color: #b58900; font-style: italic;">:</span>  <span style="color: #268bd2;">&#8704;</span>{f h}   <span style="color: #268bd2;">&#8594;</span>    f  <span style="color: #268bd2;">&#8801;</span>  (&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; h)   <span style="color: #268bd2;">&#8594;</span>   lift f  <span style="color: #268bd2;">&#8801;</span>  h
  uniqueness&#8217; {f} {h} f<span style="color: #268bd2;">&#8776;</span>&#953;<span style="color: #268bd2;">&#10814;</span><span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321;h <span style="color: #268bd2;">=</span> begin
      lift f
    <span style="color: #268bd2;">&#8801;</span>&#10216; <span style="color: #268bd2;">&#8801;-</span>cong lift f<span style="color: #268bd2;">&#8776;</span>&#953;<span style="color: #268bd2;">&#10814;</span><span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321;h &#10217;
      lift (&#953; <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; h)
    <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" definition of lift&#728; "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
      lift (lift<span style="color: #268bd2;">&#728;</span> h)
    <span style="color: #268bd2;">&#8801;</span>&#10216; lid &#10217;
      h
    <span style="color: #268bd2;">&#8718;</span>
</pre>
</div>

<p>
The difference between this proof and the original one is akin
to the difference between heaven and earth! That or it's much more elegant ;-)
</p>
</div>
</div>

<div id="outline-container-org1af54d0" class="outline-3">
<h3 id="𝒫-𝒰"><code>𝒫 ⊣ 𝒰</code></h3>
<div class="outline-text-3" id="text-𝒫-𝒰">
<p>
Thus far, we have essentially shown
\[(𝒫₀\, G \,⟶\, 𝒞) \quad≅\quad (G \,⟶\, 𝒰₀\, 𝒞)\]
We did so by finding a pair of inverse maps:
</p>

<pre class="example">
lift   :  (    G ⟶ 𝒰₀ 𝒞)  →  (𝒫₀ G ⟶     𝒞)
lift˘  :  (𝒫₀ G  ⟶    𝒞)  →  (   G ⟶  𝒰₀ 𝒞)
</pre>

<p>
This is nearly <code>𝒫 ⊣ 𝒰</code> which implies <code>𝒫</code> is a ‘free-functor’ since it is left-adjoint to a forgetful-functor.
</p>

<p>
‘Nearly’ since we need to exhibit naturality:
For every graph map <code>g</code> and functors <code>F, k</code> we have
<code>lift˘ (𝒫 g ⨾ k ⨾ F) ≈ g ⨾ lift˘ k ⨾ 𝒰 F</code> in the category of graphs.
</p>

<p>
<a href="http://maartenfokkinga.github.io/utwente/mmf92b.pdf">Fokkinga (Theorem A.4)</a>, among others, would call these laws ‘fusion’
instead since they inform us how to compose, or ‘fuse’, a morphism with a
<code>lift˘</code>-ed morphism: Taking <code>F</code> to be the identity and remembering that functors preserve
identities, we have that <code>g ⨾ lift˘ K ≡ lift˘( 𝒫₁ g ⨾ K)</code> &#x2013;we can push a morphism into a <code>lift˘</code>
at the cost of introducing a <code>𝒫₁</code>; dually for <code>lift</code>-ed morphisms.
</p>

<p>
First the setup,
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">module</span> <span style="color: #859900; font-weight: bold;">_</span> {<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span> {&#8467;&#8320;} {&#8467;&#8320;}}
          (g <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">GraphMap</span> <span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span>) (<span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Functor</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>) <span style="color: #859900; font-weight: bold;">where</span>

  private
    lift<span style="color: #268bd2;">&#728;</span> <span style="color: #268bd2;">=</span> &#955; {<span style="color: #b58900; font-style: italic;">A</span>} {<span style="color: #b58900; font-style: italic;">C</span>} <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#8594;</span> freedom<span style="color: #268bd2;">.</span>lift<span style="color: #268bd2;">&#728;</span> <span style="color: #b58900; font-style: italic;">A</span> {<span style="color: #b58900; font-style: italic;">C</span>} <span style="color: #b58900; font-style: italic;">B</span>
    lift <span style="color: #268bd2;">=</span> &#955; {<span style="color: #b58900; font-style: italic;">A</span>} {<span style="color: #b58900; font-style: italic;">C</span>} <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#8594;</span> freedom<span style="color: #268bd2;">.</span>lift <span style="color: #b58900; font-style: italic;">A</span> {<span style="color: #b58900; font-style: italic;">C</span>} <span style="color: #b58900; font-style: italic;">B</span>
  open <span style="color: #b58900; font-style: italic;">Category</span> &#10627;<span style="color: #268bd2;">...</span>&#10628;

  <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>     <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> <span style="color: #b58900; font-style: italic;">&#119966;</span>
  <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>     <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> <span style="color: #b58900; font-style: italic;">&#119967;</span>
  <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span>
  <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span>   <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> (<span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span> {&#8467;&#8320;} {&#8467;&#8320;})
  <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span>   <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">Category</span> (<span style="color: #b58900; font-style: italic;">&#119982;e&#120009;</span> {&#8467;&#8320;})
</pre>
</div>

<p>
Just as we needed to prove two inverse laws for <code>lift</code> and <code>lift˘</code>,
we need two naturality proofs.
</p>

<div class="org-src-container">
<pre class="src src-haskell">  naturality<span style="color: #268bd2;">&#728;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">K</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Functor</span> (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8320; <span style="color: #b58900; font-style: italic;">H</span>) <span style="color: #b58900; font-style: italic;">&#119966;</span>}
              <span style="color: #268bd2;">&#8594;</span>  lift<span style="color: #268bd2;">&#728;</span> (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">K</span> <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">F</span>)  <span style="color: #268bd2;">&#8801;</span>  (g <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> lift<span style="color: #268bd2;">&#728;</span> <span style="color: #b58900; font-style: italic;">K</span> <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>)
  naturality<span style="color: #268bd2;">&#728;</span> <span style="color: #268bd2;">=</span> graphmapext <span style="color: #268bd2;">&#8801;-</span>refl <span style="color: #268bd2;">&#8801;-</span>refl
</pre>
</div>

<p>
That was easier than assumed!
Hahaha: Hard to formalise but so easy to prove lolz!
It says we can ‘shunt’ <code>lift˘</code> into certain compositions at the cost
of replacing functor instances.
</p>

<p>
Now for the other proof:
</p>
<div class="org-src-container">
<pre class="src src-haskell">  naturality <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {k <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">GraphMap</span> <span style="color: #b58900; font-style: italic;">H</span> (<span style="color: #b58900; font-style: italic;">&#119984;</span>&#8320; <span style="color: #b58900; font-style: italic;">&#119966;</span>)} <span style="color: #268bd2;">&#8594;</span>     lift (g <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> k <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>)
                                              <span style="color: #268bd2;">&#8801;</span>  (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> lift k <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">F</span>)
  naturality {k} <span style="color: #268bd2;">=</span> funcext <span style="color: #268bd2;">&#8801;-</span>refl (&#955; {x y p} <span style="color: #268bd2;">&#8594;</span> proof {x} {y} {p})
    <span style="color: #859900; font-weight: bold;">where</span>
      open <span style="color: #b58900; font-style: italic;">TypedPaths</span> &#10627;<span style="color: #268bd2;">...</span>&#10628;
      <span style="color: #859900; font-weight: bold;">instance</span> <span style="color: #b58900; font-style: italic;">G</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span> ; <span style="color: #b58900; font-style: italic;">G</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">G</span>
               <span style="color: #b58900; font-style: italic;">H</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span> ; <span style="color: #b58900; font-style: italic;">H</span><span style="color: #268bd2;">&#8242;</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">H</span>
      proof <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {x y <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph.V</span> <span style="color: #b58900; font-style: italic;">G</span>} {p <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#8669;</span> y}
            <span style="color: #268bd2;">&#8594;</span>    mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> lift {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} k <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">F</span>) p
               <span style="color: #268bd2;">&#8801;</span>  mor (lift {<span style="color: #b58900; font-style: italic;">G</span>} {<span style="color: #b58900; font-style: italic;">&#119967;</span>} (g <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> k <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>)) p
      proof {p <span style="color: #268bd2;">=</span> <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">!</span>} <span style="color: #268bd2;">=</span> functor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> lift {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} k <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">F</span>) preserves<span style="color: #268bd2;">-</span>identities
      proof {p <span style="color: #268bd2;">=</span> x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps} <span style="color: #268bd2;">=</span> begin
            mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> lift {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} k <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">F</span>) (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps)
         <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" By definition, &#8220;mor&#8221; distributes over composition "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
            (mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g) <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> mor (lift {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} k) <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> mor <span style="color: #b58900; font-style: italic;">F</span>) (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps)
         <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" Definitions of function composition and &#8220;&#119979;&#8321; &#10814; mor&#8221; "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
            mor <span style="color: #b58900; font-style: italic;">F</span> (mor (lift {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} k) (mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g) (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps)))
                                                  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">This explicit path is in G</span>
         <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" Lifting graph-map &#8220;g&#8221; onto a path "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
            mor <span style="color: #b58900; font-style: italic;">F</span> (mor (lift {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} k) (ver g x <span style="color: #268bd2;">&#10230;</span>[ edge g e ]<span style="color: #268bd2;">&#10230;</span> mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g) ps))
                                                  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">This explicit path is in H</span>
         <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" Definition of &#8220;lift &#10814; mor&#8221; on inductive case for paths "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
            mor <span style="color: #b58900; font-style: italic;">F</span> (edge k (edge g e) <span style="color: #b58900; font-style: italic;">&#119966;</span><span style="color: #268bd2;">.&#10814;</span> mor (lift {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} k) (mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g) ps))
         <span style="color: #268bd2;">&#8801;</span>&#10216; functor <span style="color: #b58900; font-style: italic;">F</span> preserves<span style="color: #268bd2;">-</span>composition &#10217;
                mor <span style="color: #b58900; font-style: italic;">F</span> (edge k (edge g e))
           <span style="color: #b58900; font-style: italic;">&#119967;</span><span style="color: #268bd2;">.&#10814;</span>  mor <span style="color: #b58900; font-style: italic;">F</span> (mor (lift {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} k) (mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g) ps))
         <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" Definition of function composition, for top part "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
               (edge g <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> edge k <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> mor <span style="color: #b58900; font-style: italic;">F</span>) e  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8776; mor F &#8728; edge k &#8728; edge g</span>
           <span style="color: #b58900; font-style: italic;">&#119967;</span><span style="color: #268bd2;">.&#10814;</span> (mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g) <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> mor (lift {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} k) <span style="color: #b58900; font-style: italic;">&#119982;&#8495;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> mor <span style="color: #b58900; font-style: italic;">F</span>) ps
         <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" &#8220;&#119984;&#8321; &#10814; edge = mor&#8221; and &#8220;edge&#8221; and &#8220;mor&#8221; are functorial by definition "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
                edge (g <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> k <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>) e
           <span style="color: #b58900; font-style: italic;">&#119967;</span><span style="color: #268bd2;">.&#10814;</span>  mor (<span style="color: #b58900; font-style: italic;">&#119979;</span>&#8321; g <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> lift {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} k <span style="color: #b58900; font-style: italic;">&#119966;&#119990;&#120009;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">F</span>) ps
         <span style="color: #268bd2;">&#8801;</span>&#10216; <span style="color: #96A7A9; font-style: italic;">{- </span><span style="color: #96A7A9; font-style: italic;">Inductive Hypothesis: -}</span> <span style="color: #268bd2;">&#8801;-</span>cong&#8322; <span style="color: #b58900; font-style: italic;">&#119967;</span><span style="color: #268bd2;">.</span><span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10814;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">&#8801;-</span>refl (proof {p <span style="color: #268bd2;">=</span> ps}) &#10217;
                edge (g <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> k <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>) e
           <span style="color: #b58900; font-style: italic;">&#119967;</span><span style="color: #268bd2;">.&#10814;</span>  mor (lift {<span style="color: #b58900; font-style: italic;">G</span>} {<span style="color: #b58900; font-style: italic;">&#119967;</span>} (g <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> k <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>)) ps
         <span style="color: #268bd2;">&#8801;</span>&#10216;<span style="color: #2aa198;">" Definition of &#8220;lift &#10814; mor&#8221; on inductive case for paths "</span>&#10217;<span style="color: #268bd2;">&#8242;</span>
            mor (lift {<span style="color: #b58900; font-style: italic;">G</span>} {<span style="color: #b58900; font-style: italic;">&#119967;</span>} (g <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> k <span style="color: #b58900; font-style: italic;">&#119970;&#120007;&#119990;&#120005;&#119997;</span><span style="color: #268bd2;">.&#10814;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>&#8321; <span style="color: #b58900; font-style: italic;">F</span>)) (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps)
         <span style="color: #268bd2;">&#8718;</span>
</pre>
</div>

<p>
Formally, we now have an adjunction:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #b58900; font-style: italic;">&#119979;</span><span style="color: #268bd2;">&#8867;</span><span style="color: #b58900; font-style: italic;">&#119984;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">&#119979;</span> <span style="color: #268bd2;">&#8867;</span> <span style="color: #b58900; font-style: italic;">&#119984;</span>
<span style="color: #b58900; font-style: italic;">&#119979;</span><span style="color: #268bd2;">&#8867;</span><span style="color: #b58900; font-style: italic;">&#119984;</span> <span style="color: #268bd2;">=</span> record{
    &#8970;<span style="color: #859900; font-weight: bold;">_</span>&#8971; <span style="color: #268bd2;">=</span> lift<span style="color: #268bd2;">&#728;</span>
  ; &#8968;<span style="color: #859900; font-weight: bold;">_</span>&#8969; <span style="color: #268bd2;">=</span> lift
  ; lid <span style="color: #268bd2;">=</span> lid
  ; rid <span style="color: #268bd2;">=</span> &#955; {<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> c} <span style="color: #268bd2;">&#8594;</span> rid {<span style="color: #b58900; font-style: italic;">G</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} {c}
  ; lfusion <span style="color: #268bd2;">=</span> &#955; {<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> f <span style="color: #b58900; font-style: italic;">F</span> <span style="color: #b58900; font-style: italic;">K</span>} <span style="color: #268bd2;">&#8594;</span> naturality<span style="color: #268bd2;">&#728;</span> {<span style="color: #b58900; font-style: italic;">G</span>} {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} {<span style="color: #b58900; font-style: italic;">&#119967;</span>} f <span style="color: #b58900; font-style: italic;">K</span> {<span style="color: #b58900; font-style: italic;">F</span>}
  ; rfusion <span style="color: #268bd2;">=</span> &#955; {<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">H</span> <span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">&#119967;</span> f k <span style="color: #b58900; font-style: italic;">F</span>} <span style="color: #268bd2;">&#8594;</span> naturality {<span style="color: #b58900; font-style: italic;">G</span>} {<span style="color: #b58900; font-style: italic;">H</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span>} {<span style="color: #b58900; font-style: italic;">&#119967;</span>} f <span style="color: #b58900; font-style: italic;">F</span> {k} }
  <span style="color: #859900; font-weight: bold;">where</span>
    <span style="color: #859900; font-weight: bold;">module</span> <span style="color: #859900; font-weight: bold;">_</span> {<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span>} {<span style="color: #b58900; font-style: italic;">&#119966;</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Category</span>} <span style="color: #859900; font-weight: bold;">where</span> open freedom <span style="color: #b58900; font-style: italic;">G</span> {<span style="color: #b58900; font-style: italic;">&#119966;</span>} public
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgbe4fcfe" class="outline-2">
<h2 id="Folds-Over-Paths">Folds Over Paths</h2>
<div class="outline-text-2" id="text-Folds-Over-Paths">
<p>
Observe that for the freedom proof we recalled
that ists determine a form of quantification, ‘folding’:
given an operation ⊕, we may form the operation <code>[x₁, …, xₖ] ↦ x₁ ⊕ ⋯ ⊕ xₖ</code>.
Then used that to define our operation <code>lift</code>, whose core was essentially,
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">module</span> folding (<span style="color: #b58900; font-style: italic;">G</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span>) <span style="color: #859900; font-weight: bold;">where</span>
  open <span style="color: #b58900; font-style: italic;">TypedPaths</span> <span style="color: #b58900; font-style: italic;">G</span>
  open <span style="color: #b58900; font-style: italic;">Graph</span> <span style="color: #b58900; font-style: italic;">G</span>
                                              <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Given:</span>
  fold <span style="color: #b58900; font-style: italic;">:</span> {<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>} (v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span>)               <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">realise G's vertices as X elements</span>
         (f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x {y} (e <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#10230;</span> y) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span>) <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">realise paths as X elements</span>
       <span style="color: #268bd2;">&#8594;</span> (<span style="color: #268bd2;">&#8704;</span> {a b} <span style="color: #268bd2;">&#8594;</span> a <span style="color: #268bd2;">&#8669;</span> b <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span>)            <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Then: Any path is an X value</span>
  fold v f (b <span style="color: #268bd2;">!</span>) <span style="color: #268bd2;">=</span> v b
  fold v f (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps) <span style="color: #268bd2;">=</span> f x e (fold v f ps)
</pre>
</div>

<p>
For example, what is the length of a path?
</p>
<div class="org-src-container">
<pre class="src src-haskell">  length <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x y} <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#8669;</span> y <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#8469;</span>
  length <span style="color: #268bd2;">=</span> fold (&#955; <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">&#8594;</span> 0)          <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">single walks are length 0.</span>
                (&#955; <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #859900; font-weight: bold;">_</span> n <span style="color: #268bd2;">&#8594;</span> 1 <span style="color: #268bd2;">+</span> n)  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">edges are one more than the</span>
                                    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">length of the remaining walk</span>
</pre>
</div>
<p>
Let’s verify that this is actually what we intend by the length of a path.
</p>
<div class="org-src-container">
<pre class="src src-haskell">  length<span style="color: #268bd2;">-!</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x} <span style="color: #268bd2;">&#8594;</span> length (x <span style="color: #268bd2;">!</span>) <span style="color: #268bd2;">&#8801;</span> 0
  length<span style="color: #268bd2;">-!</span> <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">True by definition of &#8220;length&#8221;: The first argument to the &#8220;fold&#8221;</span>

  length<span style="color: #268bd2;">-</span>ind <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {x y &#969;} {e <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#10230;</span> y} {ps <span style="color: #b58900; font-style: italic;">:</span> y <span style="color: #268bd2;">&#8669;</span> &#969;}
            <span style="color: #268bd2;">&#8594;</span>  length (x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps)  <span style="color: #268bd2;">&#8801;</span>  1 <span style="color: #268bd2;">+</span> length ps
  length<span style="color: #268bd2;">-</span>ind <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">&#8801;-</span>refl
  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">True by definition of &#8220;length&#8221;: The second-argument to the &#8220;fold&#8221;</span>
</pre>
</div>

<p>
Generalising on <code>length</code>, suppose we have a ‘cost function’ <code>c</code> that assigns a cost of traversing
an edge. Then we can ask what is the total cost of a path:
</p>
<div class="org-src-container">
<pre class="src src-haskell">  path<span style="color: #268bd2;">-</span>cost <span style="color: #b58900; font-style: italic;">:</span> (c <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x y}(e <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#10230;</span> y) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#8469;</span>) <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">&#8704;</span>{x y}(ps <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#8669;</span> y) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#8469;</span>
  path<span style="color: #268bd2;">-</span>cost c <span style="color: #268bd2;">=</span> fold (&#955; <span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">&#8594;</span> 0)           <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">No cost on an empty path.</span>
                     (&#955; x e n <span style="color: #268bd2;">&#8594;</span> c e <span style="color: #268bd2;">+</span> n) <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Cost of current edge plus</span>
                                          <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">cost of remainder of path.</span>
</pre>
</div>
<p>
Now, we have <code>length = path-cost (λ _ → 1)</code>: Length is just assigning a cost of 1 to each edge.
</p>

<p>
Under suitable conditions, list fold distributes over list catenation, can we find an analogue
for paths? Yes. Yes, we can:
</p>
<div class="org-src-container">
<pre class="src src-haskell">  fold<span style="color: #268bd2;">-++</span> <span style="color: #b58900; font-style: italic;">:</span>  <span style="color: #268bd2;">&#8704;</span>{<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>} {v <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span>} {g <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x {y} (e <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#10230;</span> y) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span>}
          <span style="color: #268bd2;">&#8594;</span> (<span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8853;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span>)
          <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">&#8704;</span>{x y z <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">V</span>} {p <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#8669;</span> y} {q <span style="color: #b58900; font-style: italic;">:</span> y <span style="color: #268bd2;">&#8669;</span> z}
          <span style="color: #268bd2;">&#8594;</span> (unitl <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{x y} <span style="color: #268bd2;">&#8594;</span> y <span style="color: #268bd2;">&#8801;</span> v x <span style="color: #268bd2;">&#8853;</span> y)        <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Image of &#8216;v&#8217; is left unit of &#8853;</span>
          <span style="color: #268bd2;">&#8594;</span> (assoc <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {x y z} <span style="color: #268bd2;">&#8594;</span> x <span style="color: #268bd2;">&#8853;</span> (y <span style="color: #268bd2;">&#8853;</span> z) <span style="color: #268bd2;">&#8801;</span> (x <span style="color: #268bd2;">&#8853;</span> y) <span style="color: #268bd2;">&#8853;</span> z )  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8853; is associative</span>
          <span style="color: #268bd2;">&#8594;</span> <span style="color: #859900; font-weight: bold;">let</span> f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> x {y} (e <span style="color: #b58900; font-style: italic;">:</span> x <span style="color: #268bd2;">&#10230;</span> y) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span>
                f <span style="color: #268bd2;">=</span> &#955; x e ps <span style="color: #268bd2;">&#8594;</span> g x e <span style="color: #268bd2;">&#8853;</span> ps
             <span style="color: #859900; font-weight: bold;">in</span>
               fold v f (p <span style="color: #268bd2;">++</span> q) <span style="color: #268bd2;">&#8801;</span> fold v f p <span style="color: #268bd2;">&#8853;</span> fold v f q
  fold<span style="color: #268bd2;">-++</span> {g <span style="color: #268bd2;">=</span> g} <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8853;</span><span style="color: #859900; font-weight: bold;">_</span> {x <span style="color: #268bd2;">=</span> x} {p <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">.</span>x <span style="color: #268bd2;">!</span>} unitl assoc <span style="color: #268bd2;">=</span>  unitl
  fold<span style="color: #268bd2;">-++</span> {g <span style="color: #268bd2;">=</span> g} <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8853;</span><span style="color: #859900; font-weight: bold;">_</span> {x <span style="color: #268bd2;">=</span> x} {p <span style="color: #268bd2;">=</span> <span style="color: #268bd2;">.</span>x <span style="color: #268bd2;">&#10230;</span>[ e ]<span style="color: #268bd2;">&#10230;</span> ps} unitl assoc <span style="color: #268bd2;">=</span>
    <span style="color: #268bd2;">&#8801;-</span>cong (&#955; exp <span style="color: #268bd2;">&#8594;</span> g x e <span style="color: #268bd2;">&#8853;</span> exp) (fold<span style="color: #268bd2;">-++</span> <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8853;</span><span style="color: #859900; font-weight: bold;">_</span> {p <span style="color: #268bd2;">=</span> ps} unitl assoc) &#10216;<span style="color: #268bd2;">&#8801;&#8801;</span>&#10217; assoc
</pre>
</div>

<p>
Compare this with the proof-obligation of <code>lift</code>.
</p>
</div>

<div id="outline-container-orgd7e6d82" class="outline-3">
<h3 id="Lists-are-special-kinds-of-paths">Lists are special kinds of paths</h3>
<div class="outline-text-3" id="text-Lists-are-special-kinds-of-paths">
<p>
We called our path catenation <code>_++_</code>, why the same symbol as that for
list catenation?
</p>

<p>
How do we interpret a list over \(A\) as a graph?
Well the vertices can be any element of \(A\)
and an edge \(x ⟶ y\) merely indicates that
‘‘the item after \(x\) in the list is the element \(y\)’’,
so we want it to be always true; or always inhabited
without distinction of the inhabitant:
So we might as well use a unit type.
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #859900; font-weight: bold;">module</span> lists (<span style="color: #b58900; font-style: italic;">A</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>) <span style="color: #859900; font-weight: bold;">where</span>

  open <span style="color: #859900; font-weight: bold;">import</span> <span style="color: #b58900; font-style: italic;">Data.Unit</span>

  listGraph <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Graph</span>
  listGraph <span style="color: #268bd2;">=</span> record { <span style="color: #b58900; font-style: italic;">V</span> <span style="color: #268bd2;">=</span> <span style="color: #b58900; font-style: italic;">A</span> ; <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#10230;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #268bd2;">=</span> &#955; a a&#8217; <span style="color: #268bd2;">&#8594;</span> <span style="color: #268bd2;">&#8868;</span> }
</pre>
</div>
<p>
I haven’t a clue if this works, you read my reasoning above.
</p>

<p>
The only thing we can do is test our hypothesis by looking at the
typed paths over this graph. In particular, we attempt to show every
non-empty list of \(A\)’s corresponds to a path. Since a typed path needs
a priori the start and end vertes, let us construe
<code>List A  ≅  Σ n ∶ ℕ • Fin n → A</code>
&#x2013;later note that <code>Path G  ≅  Σ n ∶ ℕ • [n] 𝒢⟶ G</code>.
</p>
<div class="org-src-container">
<pre class="src src-haskell">  open <span style="color: #b58900; font-style: italic;">TypedPaths</span> listGraph
  open folding listGraph

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Every non-empty list [x&#8320;, &#8230;, x&#8342;] of A&#8217;s corresonds to a path x&#8320; &#8669; x&#8342;.</span>
  toPath <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{n} (list <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Fin</span> (suc n) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">A</span>) <span style="color: #268bd2;">&#8594;</span>  list fzero <span style="color: #268bd2;">&#8669;</span> list (from&#8469; n)
  toPath {zero} list <span style="color: #268bd2;">=</span> list fzero <span style="color: #268bd2;">!</span>
  toPath {suc n} list <span style="color: #268bd2;">=</span> list fzero <span style="color: #268bd2;">&#10230;</span>[ tt ]<span style="color: #268bd2;">&#10230;</span> toPath {n} (&#955; i <span style="color: #268bd2;">&#8594;</span> list(fsuc i))
    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Note that in the inductive case, &#8220;list : Fin (suc (suc n)) &#8594; A&#8221;</span>
    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">whereas &#8220;suc &#10814; list : Fin (suc n) &#8594; A&#8221;.</span>
    <span style="color: #96A7A9; font-style: italic;">--</span>
    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">For example, if &#8220;list &#8776; [x , y , z]&#8221; yields</span>
    <span style="color: #96A7A9; font-style: italic;">--          </span><span style="color: #96A7A9; font-style: italic;">&#8220;fsuc &#10814; list &#8776; [y , z ]&#8221; and</span>
    <span style="color: #96A7A9; font-style: italic;">--   </span><span style="color: #96A7A9; font-style: italic;">&#8220;fsuc &#10814; fsuc &#10814; list &#8776; [z]&#8221;.</span>
</pre>
</div>
<p>
Hm! Look at that, first guess and it worked! Sweet.
</p>

<p>
Now let’s realize the list fold as an instance of path fold,
</p>
<div class="org-src-container">
<pre class="src src-haskell">  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">List type former</span>
  <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #268bd2;">=</span> &#955; (<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#931;</span> n <span style="color: #268bd2;">&#8758;</span> <span style="color: #b58900; font-style: italic;">&#8469;</span> <span style="color: #268bd2;">&#8226;</span> (<span style="color: #b58900; font-style: italic;">Fin</span> n <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span>)

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Usual list folding, but it's in terms of path folding.</span>
  foldr <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{<span style="color: #b58900; font-style: italic;">B</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>} (f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span>) (e <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">B</span>) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span>
  foldr f e (zero , l) <span style="color: #268bd2;">=</span> e
  foldr f e (suc n , l) <span style="color: #268bd2;">=</span> fold (&#955; a <span style="color: #268bd2;">&#8594;</span> f a e) (&#955; a <span style="color: #859900; font-weight: bold;">_</span> rem <span style="color: #268bd2;">&#8594;</span> f a rem) (toPath l)

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">example</span>
  listLength <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">&#8469;</span> <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">result should clearly be &#8220;proj&#8321;&#8221; of the list, anyhow:</span>
  listLength <span style="color: #268bd2;">=</span> foldr
    (&#955; a rem <span style="color: #268bd2;">&#8594;</span> 1 <span style="color: #268bd2;">+</span> rem) <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Non-empty list has length 1 more than the remainder.</span>
    0                    <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Empty list has length 0.</span>
</pre>
</div>

<p>
Let’s prepare for a more useful example
</p>
<div class="org-src-container">
<pre class="src src-haskell">  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Empty list</span>
  <span style="color: #b58900; font-style: italic;">[]</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #b58900; font-style: italic;">X</span>
  <span style="color: #b58900; font-style: italic;">[]</span> <span style="color: #268bd2;">=</span> 0 , &#955; <span style="color: #b58900; font-style: italic;">()</span>

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Cons for lists</span>
  <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8759;</span><span style="color: #859900; font-weight: bold;">_</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{<span style="color: #b58900; font-style: italic;">X</span> <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">Set</span>} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #b58900; font-style: italic;">X</span>
  <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8759;</span><span style="color: #859900; font-weight: bold;">_</span> {<span style="color: #b58900; font-style: italic;">X</span>} x (n , l) <span style="color: #268bd2;">=</span> 1 <span style="color: #268bd2;">+</span> n , cons x l
    <span style="color: #859900; font-weight: bold;">where</span>
      <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">&#8220;cons a l  &#8776;  &#955; i : Fin (1 + n) &#8594; if i &#8776; 0 then a else l i&#8221;</span>
      cons <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span>{n} <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span> <span style="color: #268bd2;">&#8594;</span> (<span style="color: #b58900; font-style: italic;">Fin</span> n <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span>) <span style="color: #268bd2;">&#8594;</span> (<span style="color: #b58900; font-style: italic;">Fin</span> (suc n) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">X</span>)
      cons x l fzero <span style="color: #268bd2;">=</span> x
      cons x l (fsuc i) <span style="color: #268bd2;">=</span> l i

  map <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #268bd2;">&#8704;</span> {<span style="color: #b58900; font-style: italic;">B</span>} (f <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">B</span>) <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #b58900; font-style: italic;">B</span>
  map f <span style="color: #268bd2;">=</span>  foldr (&#955; a rem <span style="color: #268bd2;">&#8594;</span> f a <span style="color: #268bd2;">&#8759;</span> rem) <span style="color: #b58900; font-style: italic;">[]</span>  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">looks like the usual map don&#8217;t it ;)</span>

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">list concatenation</span>
  <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">++</span>&#8467;_ <span style="color: #b58900; font-style: italic;">:</span> <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #b58900; font-style: italic;">A</span> <span style="color: #268bd2;">&#8594;</span> <span style="color: #b58900; font-style: italic;">List</span> <span style="color: #b58900; font-style: italic;">A</span>
  l <span style="color: #268bd2;">++</span>&#8467; r <span style="color: #268bd2;">=</span> foldr <span style="color: #859900; font-weight: bold;">_</span><span style="color: #268bd2;">&#8759;</span><span style="color: #859900; font-weight: bold;">_</span> r l <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">fold over &#8216;l&#8217; by consing its elements infront of &#8216;r&#8217;</span>

  <span style="color: #96A7A9; font-style: italic;">-- </span><span style="color: #96A7A9; font-style: italic;">Exercise: Write path catenation as a path-fold.</span>
</pre>
</div>

<p>
These few adventures would suggest that much of list theory can be
brought over to the world of paths. It looks promising, let me know
dear reader if you make progress on related explorations!
</p>
</div>
</div>
</div>
<div id="outline-container-orgd76300c" class="outline-2">
<h2 id="That-was-fun-Bye">That was fun; Bye!</h2>
<div class="outline-text-2" id="text-That-was-fun-Bye">
<p>
This note took longer to write than I had initally assumed; perhaps I should have taken into
account
</p>
<dl class="org-dl">
<dt>Hofstadter’s Law</dt><dd><p>
It always takes longer than you expect, even when you take into account Hofstadter’s Law.
</p>

<p>
─<a href="https://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach">Gödel, Escher, Bach: An Eternal Golden Braid</a>
</p></dd>
</dl>

<p>
Lessons learned:
</p>

<ul class="org-ul">
<li>In Agda, Use implicits when possible in-favour of instance variables
since the former can be inferred from the local context,
whereas the latter must be resolved using the entire global context
thereby incurring possibly more unification problems to solve
thereby costing more time.</li>

<li>If you really want to learn something, teach it to someone:
A proof assistant wont let you get away with skipping over anything!</li>

<li>Coming up with the right data representation for the tasks being tackled
is a matter of discovery!</li>
</ul>

<p>
The astute reader may have noticed that the tone of writing sometimes
changes drastically. This is because some of this article was written
by me in March 2016 and I wished to preserve interesting writing style
I then had &#x2013;if anything to contrast with my now somewhat semi-formal style.
</p>

<p>
This article was motivated while I was reading <a href="https://www.amazon.ca/Conceptual-Mathematics-First-Introduction-Categories/dp/052171916X">Conceptual Mathematics</a>
for fun. One of the problems was to show that paths over a graph form
a category and do so freely. It took me about 20 minutes on paper and pencil,
but this resulting mechanisation took much more time &#x2013;but it was also
much more fun!
</p>

<p>
I had fun writing this up &amp; I hope you enjoy it too :-)
</p>

<dl class="org-dl">
<dt>Highly Recommended Read</dt><dd>The diligent reader may be interested to know that Maarten Fokkinga has written a very
accessible and <a href="http://maartenfokkinga.github.io/utwente/mmf92b.pdf">gentle introduction to category theory using the calculational approach</a>.</dd>
</dl>

<small>
<div class="org-center">
<p>
( This article is not yet ‘done’, but good enough for now. )
</p>
</div>
</small>
</div>
</div>
<div class="taglist"><a href="https://alhassy.github.io/tags.html">Tags</a>: <a href="https://alhassy.github.io/tag-category-theory.html">category-theory</a> <a href="https://alhassy.github.io/tag-agda.html">agda</a> <a href="https://alhassy.github.io/tag-types.html">types</a> </div><div id="archive">
<a href="https://alhassy.github.io/archive.html">Other posts</a>
</div>
</div>
<div id="postamble" class="status"><div id="archive">
  <a href="https://alhassy.github.io/archive.html">Other posts</a>
</div>
<center><a rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a><br /><span xmlns:dct="https://purl.org/dc/terms/" href="https://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">Life and Computing Science</span> by <a xmlns:cc="https://creativecommons.org/ns#" href="https://alhassy.github.io/" property="cc:attributionName" rel="cc:attributionURL">Musa Al-hassy</a> is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.</center>

<div id="archive"><a href="archive.html">Other posts</a></div>
              <div id="disqus_thread"></div>
              <script type="text/javascript">
              /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
              var disqus_shortname = 'life-and-computing-science';
              /* * * DON'T EDIT BELOW THIS LINE * * */
              (function() {
                var dsq = document.createElement('script');
                dsq.type = 'text/javascript';
                dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                  })();
              </script>
              <noscript>Please enable JavaScript to view the
                  <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
              <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></div>
</body>
</html>
