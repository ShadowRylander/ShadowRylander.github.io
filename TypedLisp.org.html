<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.56 in css mode. -->
<html>
  <head>
    <title>TypedLisp.org</title>
    <style type="text/css">
    <!--
      body {
        color: #556b72;
        background-color: #FDF6E3;
      }
      .bold {
        /* bold */
        font-weight: bold;
      }
      .builtin {
        /* font-lock-builtin-face */
        color: #d33682;
        font-style: italic;
      }
      .comment {
        /* font-lock-comment-face */
        color: #96A7A9;
        font-style: italic;
      }
      .comment-delimiter {
        /* font-lock-comment-delimiter-face */
        color: #96A7A9;
        font-style: italic;
      }
      .constant {
        /* font-lock-constant-face */
        color: #6c71c4;
        font-weight: bold;
      }
      .doc {
        /* font-lock-doc-face */
        color: #35a69c;
        font-style: italic;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #b58900;
      }
      .haskell-constructor {
        /* haskell-constructor-face */
        color: #b58900;
        font-style: italic;
      }
      .haskell-definition {
        /* haskell-definition-face */
        color: #b58900;
      }
      .haskell-keyword {
        /* haskell-keyword-face */
        color: #859900;
        font-weight: bold;
      }
      .haskell-operator {
        /* haskell-operator-face */
        color: #268bd2;
      }
      .haskell-type {
        /* haskell-type-face */
        color: #b58900;
        font-style: italic;
      }
      .highlight-defined-builtin-function-name {
        /* highlight-defined-builtin-function-name-face */
        color: #b58900;
      }
      .highlight-defined-function-name {
        /* highlight-defined-function-name-face */
        color: #b58900;
      }
      .highlight-defined-macro-name {
        /* highlight-defined-macro-name-face */
        color: #b58900;
      }
      .highlight-defined-special-form-name {
        /* highlight-defined-special-form-name-face */
        color: #b58900;
      }
      .highlight-defined-variable-name {
        /* highlight-defined-variable-name-face */
        color: #268bd2;
      }
      .italic {
        /* italic */
        font-style: italic;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #859900;
        font-weight: bold;
      }
      .org-block {
        /* org-block */
        background-color: #faf1d9;
      }
      .org-block-begin-line {
        /* org-block-begin-line */
        background-color: #f7edd0;
      }
      .org-block-end-line {
        /* org-block-end-line */
        background-color: #f7edd0;
      }
      .org-code {
        /* org-code */
        color: #cb4b16;
      }
      .org-document-info {
        /* org-document-info */
        color: #d33682;
      }
      .org-document-info-keyword {
        /* org-document-info-keyword */
        color: #D6D6D6;
      }
      .org-document-title {
        /* org-document-title */
        color: #d33682;
        font-weight: bold;
      }
      .org-drawer {
        /* org-drawer */
        color: #0000ff;
      }
      .org-hide {
        /* org-hide */
        color: #FDF6E3;
      }
      .org-latex-and-related {
        /* org-latex-and-related */
        color: #626C6C;
        font-weight: bold;
      }
      .org-level-1 {
        /* org-level-1 */
        color: #268bd2;
        font-weight: bold;
      }
      .org-level-2 {
        /* org-level-2 */
        color: #d33682;
        font-weight: bold;
      }
      .org-link {
        /* org-link */
        color: #268bd2;
        font-weight: bold;
        text-decoration: underline;
      }
      .org-list-dt {
        /* org-list-dt */
        color: #268bd2;
      }
      .org-meta-line {
        /* org-meta-line */
        color: #35a69c;
      }
      .org-property-value {
        /* org-property-value */
        color: #35a69c;
      }
      .org-quote {
        /* org-quote */
        background-color: #F2E6CE;
        font-style: italic;
      }
      .org-special-keyword {
        /* org-special-keyword */
        color: #35a69c;
      }
      .org-table {
        /* org-table */
        color: #6c71c4;
      }
      .org-tag {
        /* org-tag */
        color: #35a69c;
      }
      .org-target {
        /* org-target */
        text-decoration: underline;
      }
      .string {
        /* font-lock-string-face */
        color: #2aa198;
      }
      .type {
        /* font-lock-type-face */
        color: #b58900;
        font-style: italic;
      }
      .underline {
        /* underline */
        text-decoration: underline;
      }
      .warning {
        /* font-lock-warning-face */
        color: #b58900;
      }
      .writegood-duplicates {
        /* writegood-duplicates-face */
        text-decoration: underline;
      }
      .writegood-passive-voice {
        /* writegood-passive-voice-face */
        text-decoration: underline;
      }
      .writegood-weasels {
        /* writegood-weasels-face */
        text-decoration: underline;
      }

      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
<span class="org-document-info-keyword">#+Title:</span> <span class="org-document-title">Typed Lisp, A Primer
</span><span class="comment"># AlBasmala does not allow &#8220;:&#8221; in a title.</span>
<span class="comment"># AlBasmala allows a subtitle or an image, not both.</span>
<span class="org-meta-line">#+Description: Exploring Lisp's fine-grained type hierarchy.</span>
<span class="org-document-info-keyword">#+DATE:</span> <span class="org-document-info">&lt;2019-08-21 19:29&gt;
</span><span class="org-document-info-keyword">#+AUTHOR:</span> <span class="org-document-info">Musa Al-hassy
</span><span class="org-document-info-keyword">#+EMAIL:</span> <span class="org-document-info">alhassy@gmail.com
</span><span class="org-meta-line">#+fileimage: emacs-birthday-present.png</span>
<span class="org-meta-line">#+IMAGEHEIGHT: 350</span>
<span class="org-meta-line">#+IMAGEWIDTH: 350</span>
<span class="org-meta-line">#+filetags: types lisp program-proving emacs</span>

<span class="org-level-1">* Abstract </span><span class="org-level-1"><span class="org-tag">:ignore:</span></span>
<span class="org-drawer">  :PROPERTIES:...
</span>
<span class="org-meta-line">#+TOC: headlines 2</span>

Let's explore Lisp's fine-grained type hierarchy!

We begin with a shallow comparison to Haskell, a rapid tour of type theory,
try in vain to defend dynamic approaches, give a somewhat humorous account of history,
note that you've <span class="writegood-passive-voice">been bamboozled</span> ---type's have always been there---,
then go into technical details of <span class="writegood-weasels">some</span> Lisp types, and finally conclude by showing
how <span class="italic">macros permit typing</span>.

<span class="comment"># Lisp types are fine-grained; e.g., rather than int we may use a spefied range of numbers,</span>
<span class="comment"># or a set of specfiied elements, intersections, unions, and complements of types, and</span>
<span class="comment"># even arbitrary predicates!</span>

Goals for this article:

1. Multiple examples of type constructions in Lisp.
2. Comparing Lisp type systems with modern languages, such as Haskell.
3. Show how algebraic <span class="org-link">polymorphic</span> types like <span class="org-code">Pair</span> and <span class="org-code">Maybe</span> can <span class="writegood-passive-voice">be defined</span> in Lisp.
   Including heterogeneously typed lists!
4. Convey a passion for an elegant language.
5. Augment Lisp with functional Haskell-like type declarations ;-)

Unless suggested otherwise, the phrase &#8220;Lisp&#8221; refers to
<span class="org-link"><a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#index-cl_002ddeftype-14">Common Lisp as supported by Emacs Lisp</a></span>. As such, the resulting discussion
is applicable to a number of Lisp dialects
---I'm ignoring editing types such as buffers and keymaps, for now.

<span class="org-level-1">* LaTeX stuffs </span><span class="org-level-1"><span class="org-tag">:ignore:</span></span>
<span class="org-drawer">  :PROPERTIES:...
</span>
<span class="org-meta-line">#+LATEX_HEADER: \usepackage{multicol,xparse,newunicodechar}</span>
<span class="org-meta-line">#+LATEX_HEADER: \newunicodechar{&#8623;}{ !! }</span>
<span class="org-meta-line">#+LATEX_HEADER: \newunicodechar{&#10003;}{ !! }</span>
<span class="org-meta-line">#+LATEX_HEADER: \newunicodechar{&#8645;}{ !! }</span>

<span class="org-meta-line">#+LATEX_HEADER: \newunicodechar{&#8230;}{ \ensuremath{\ldots} }</span>
<span class="org-meta-line">#+LATEX_HEADER: \newunicodechar{&#8943;}{ \ensuremath{\cdots} }</span>

<span class="org-meta-line">#+LATEX_HEADER: \newunicodechar{&#8242;}{ \ensuremath{'} }</span>
<span class="org-meta-line">#+LATEX_HEADER: \newunicodechar{&#8776;}{ \ensuremath{\approx} }</span>
<span class="org-meta-line">#+LATEX_HEADER: \newunicodechar{&#8320;}{ \ensuremath{_0} }</span>
<span class="org-meta-line">#+LATEX_HEADER: \newunicodechar{&#8321;}{ \ensuremath{_1} }</span>
<span class="org-meta-line">#+LATEX_HEADER: \newunicodechar{&#8345;}{ \ensuremath{_n} }</span>
<span class="org-meta-line">#+LATEX_HEADER: \newunicodechar{&#7522;}{ \ensuremath{_i} }</span>
<span class="org-meta-line">#+LATEX_HEADER: \newunicodechar{&#8743;}{ \ensuremath{\land} }</span>
<span class="org-meta-line">#+LATEX_HEADER: \newunicodechar{&#8658;}{ \ensuremath{\Rightarrow} }</span>
<span class="org-meta-line">#+LATEX_HEADER: \newunicodechar{&#964;}{ \ensuremath{\tau} }</span>
<span class="org-meta-line">#+LATEX_HEADER: \newunicodechar{&#963;}{ \ensuremath{\sigma} }</span>
<span class="org-meta-line">#+LATEX_HEADER: \newunicodechar{&#945;}{ \ensuremath{\alpha} }</span>
<span class="org-meta-line">#+LATEX_HEADER: \newunicodechar{&#946;}{ \ensuremath{\beta} }</span>

<span class="comment"># (&#3591;&#3232;_&#3232;)&#3591;</span>
<span class="org-meta-line">#+LATEX_HEADER: \newunicodechar{&#3232;}{ }</span>
<span class="org-meta-line">#+LATEX_HEADER: \newunicodechar{&#3591;}{ }</span>

<span class="comment"># &#9829;&#8255;&#9829;</span>
<span class="org-meta-line">#+LATEX_HEADER: \newunicodechar{&#9829;}{ }</span>
<span class="org-meta-line">#+LATEX_HEADER: \newunicodechar{&#8255;}{ }</span>
<span class="org-level-1">* Photograph Credit                                                  </span><span class="org-level-1"><span class="org-tag">:ignore:</span></span>
<span class="org-drawer">  :PROPERTIES:...
</span><span class="org-meta-line">#+LaTeX: \iffalse</span>
<span class="org-meta-line">#+HTML: &lt;small&gt; &lt;center&gt;</span>
( Original print by Baneen Al-hassy as a birthday present to me. )
<span class="org-meta-line">#+HTML: &lt;/center&gt; &lt;/small&gt;</span>
<span class="org-meta-line">#+LaTeX: \fi</span>
<span class="org-level-1">* HTML stuffs </span><span class="org-level-1"><span class="org-tag">:ignore:</span></span>
<span class="org-drawer">  :PROPERTIES:...
</span>
<span class="comment"># Apparently HTML comments cannot be in style tags.</span>

<span class="comment"># &lt;!-- No &#8220;Figure n:&#8221; for figures and stuff --&gt;</span>
<span class="org-block-begin-line">#+BEGIN_export html
</span><span class="org-block">&lt;</span><span class="org-block"><span class="function-name">style</span></span><span class="org-block">&gt;

.figure-number {
    display: none;
}

.table-number {
    display: none;
}

/* Using source blocks &#8220;math&#8221; as aliaas for haskell */
pre.src-math:before { content: 'Mathematical! Algebraic! Axiomatic!'; }
/* Execute this for alias: (add-to-list 'org-src-lang-modes '("math" . haskell)) */

&lt;/</span><span class="org-block"><span class="function-name">style</span></span><span class="org-block">&gt;
</span><span class="org-block-end-line">#+END_export
</span>
<span class="comment"># Execute this for alias: (add-to-list 'org-src-lang-modes '("math" . haskell))</span>
<span class="org-meta-line">#
# This essentially lets us make an alias for the minted backend.</span>

<span class="org-level-1">* &#8220;Loving Haskell &amp; Lisp is Inconsistent&#8221;</span>
<span class="org-drawer">:PROPERTIES:...
</span>I have convinced a number of my peers to use Emacs/Spacemacs/Doom-emacs,
but my efforts to get them to even consider trying Lisp have <span class="writegood-passive-voice">been met</span> with
staunch rejection. These peers are familiar with Haskell, and almost all know Agda,
so you'd think they'd be willing to try Lisp ---it's there, part of their editor---
but the superficial chasm in terms of syntax and types is more than enough apparently.
In this article, I aim to explore the type system of (Emacs) Lisp and occasionally
make comparisons to Haskell. Perhaps in the end <span class="writegood-weasels">some</span> of my Haskell peers would be
willing to try it out.

<span class="org-meta-line">#+CAPTION:</span> <span class="org-block">xkcd - Lisp is a language of timeless elegance</span>
<span class="org-link"><a href="https://imgs.xkcd.com/comics/lisp_cycles.png">https://imgs.xkcd.com/comics/lisp_cycles.png</a></span>

+ &#8623; I almost never use Haskell for any day-to-day dealings.
<span class="comment">       # ( I'm consulted about Haskell way more than I've written it. )</span>

   &#10003; The ideas expressed by its community are why I try
          to keep updated on the language.

+ &#8623; No one around me knows anything about Lisp,
       but they dislike it due to the parens.

   &#10003; I love it and use it for Emacs configuration and recently
          to prototype my PhD research.
+ &#8645; I love that I can express a complicated procedure compactly in both
       by using zips, unzips, filters, and maps <span class="org-code">(&#3591;&#3232;_&#3232;)&#3591;</span>
       - Lately, in Lisp, I'll write a nested loop (gasp!)
         then, for fun, try to make it a one-liner!
         Sometimes, I actually think the loop formulation is clearer
         and I leave it as a loop ---Breaking news: Two Haskell readers just died.

<span class="org-meta-line">         #+caption:</span> <span class="org-block">From the awesome &#8220;Land of Lisp&#8221; book</span>
         <span class="org-link"><a href="https://i.stack.imgur.com/jvSOG.png">https://i.stack.imgur.com/jvSOG.png</a></span>

<span class="org-drawer">:Unrelated:...
</span>
+ <span class="bold">What I like and why:</span>
  <span class="org-table">| Haskell | &#8658; | Executable category theory; compact &amp; eloquent  |</span>
  <span class="org-table">| Lisp    | &#8658; | Extensible language; malleable, uniform, beautiful |</span>

+ <span class="bold">Documentation?</span>
  <span class="org-table">| Haskell    | &#8658; | Hoogle; can search by type alone! |</span>
  <span class="org-table">| Emacs Lisp | &#8658; | Self-documenting; </span><span class="org-table"><span class="org-code">M-x apropos</span></span><span class="org-table">     |</span>

+ <span class="bold">How has using the language affected me?</span>
  <span class="org-table">| Haskell | I almost always think in-terms compoistionality, functors, &amp; currying     |</span>
  <span class="org-table">| Lisp    | Documentation strings, units tests, and metaprogramming are second nature |</span>

It may not be entirely accurate to say that
Lisp's type system is more expressive than Haskell's
as it's orthogonal in <span class="writegood-weasels">many</span> respects; although it is closer to that of <span class="org-link"><a href="https://liquid.kosmikus.org/01-intro.html#/what-is-liquid-haskell">Liquid Haskell</a></span>.

<span class="org-level-1">* Why Bother with Types? A Terse Tutorial on Type Systems</span>
<span class="org-drawer">:PROPERTIES:...
</span><span class="italic">Types allow us to treat objects according a similar structure
or interface.</span>
Unlike Haskell and other statically typed systems, in Lisp we have
that types can overlap.
As such, here's our working definition.
<span class="org-block-begin-line">#+begin_center org
</span><span class="org-block">A </span><span class="org-block"><span class="bold">type</span></span><span class="org-block"> is a collection of possible objects.

To say </span><span class="org-block"><span class="org-latex-and-related">&#8220;$e$ </span></span><span class="org-block">has type</span><span class="org-block"><span class="org-latex-and-related"> $&#964;$&#8221;</span></span><span class="org-block"> one writes</span><span class="org-block"><span class="org-latex-and-related"> $e : &#964;$,</span></span><span class="org-block"> or in Lisp: </span><span class="org-block"><span class="org-code">(typep e '&#964;)</span></span><span class="org-block">.
</span><span class="org-block-end-line">#+end_center
</span>
Haskellers and others may append to this definition the following,
which we will not bother with:
<span class="italic">Type membership </span><span class="italic"><span class="writegood-passive-voice">is determined</span></span><span class="italic"> by inspecting
syntactic structure and so is decidable.</span>

<span class="org-block-begin-line">#+begin_quote org
</span><span class="org-block">&#10003; Typing is one of the simplest forms of &#8220;assertion-comments&#8221;:
Documenting a property of your code in a way that the machine can verify.

If you're gonna comment on what kind of thing you're working with, why not have the
comment checked by the machine.
</span><span class="org-block-end-line">#+end_quote
</span>
<span class="org-meta-line">#+caption:</span> <span class="org-block">Lisp's type hierarchy is a &#8220;complemented lattice&#8221; &#9829;&#8255;&#9829;</span>
<span class="org-table">| Common types  | </span><span class="org-table"><span class="org-code">integer, number, string, keyword, array, cons, list, vector, macro, function, atom</span></span><span class="org-table"> |</span>
<span class="org-table">| Top           | </span><span class="org-table"><span class="org-code">t</span></span><span class="org-table"> has everything as an element                                                     |</span>
<span class="org-table">| Unit          | </span><span class="org-table"><span class="org-code">null</span></span><span class="org-table"> has one element named </span><span class="org-table"><span class="org-code">nil</span></span><span class="org-table">                                                     |</span>
<span class="org-table">| Bottom        | </span><span class="org-table"><span class="org-code">nil</span></span><span class="org-table"> has no elements at all                                                         |</span>
<span class="org-table">| Union         | </span><span class="org-table"><span class="org-code">(or &#964;&#8320; &#964;&#8321; &#8230; &#964;&#8345;)</span></span><span class="org-table">  has elements any element in any type </span><span class="org-table"><span class="org-code">&#964;&#7522;</span></span><span class="org-table">                           |</span>
<span class="org-table">| Intersection  | </span><span class="org-table"><span class="org-code">(and &#964;&#8320; &#964;&#8321; &#8230; &#964;&#8345;)</span></span><span class="org-table"> has elements that are in all the types </span><span class="org-table"><span class="org-code">&#964;&#7522;</span></span><span class="org-table">                         |</span>
<span class="org-table">| Complement    | </span><span class="org-table"><span class="org-code">(not &#964;)</span></span><span class="org-table"> has elements that are </span><span class="org-table"><span class="italic">not</span></span><span class="org-table"> of type </span><span class="org-table"><span class="org-code">&#964;</span></span><span class="org-table">                                        |</span>
<span class="org-table">| Enumeration   | </span><span class="org-table"><span class="org-code">(member x&#8320; &#8230; x&#8345;)</span></span><span class="org-table"> is the type consisting of only the elements </span><span class="org-table"><span class="org-code">x&#7522;</span></span><span class="org-table">                    |</span>
<span class="org-table">| Singleton     | </span><span class="org-table"><span class="org-code">(eql x)</span></span><span class="org-table"> is the type with only the element </span><span class="org-table"><span class="org-code">x</span></span><span class="org-table">                                        |</span>
<span class="org-table">| Comprehension | </span><span class="org-table"><span class="org-code">(satisfies p)</span></span><span class="org-table"> is the type of values that satisfy predicate </span><span class="org-table"><span class="org-code">p</span></span><span class="org-table">                       |</span>

Let's see <span class="writegood-weasels">some</span> examples:
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">The universal type &#8220;t&#8221;, has everything as its value.
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 'x '</span><span class="org-block"><span class="highlight-defined-variable-name">t</span></span><span class="org-block">) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 12 '</span><span class="org-block"><span class="highlight-defined-variable-name">t</span></span><span class="org-block">) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">The empty type: nil
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 'x 'nil) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; false; nil has no values.
</span></span><span class="org-block">
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">The type &#8220;null&#8221; contains the one value &#8220;nil&#8221;.
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> nil '</span><span class="org-block"><span class="highlight-defined-builtin-function-name">null</span></span><span class="org-block">) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> () '</span><span class="org-block"><span class="highlight-defined-builtin-function-name">null</span></span><span class="org-block">)  </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8220;(eql x)&#8221; is the singelton type consisting of only x.
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 3 '(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">eql</span></span><span class="org-block"> 3)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 4 '(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">eql</span></span><span class="org-block"> 3)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; false
</span></span><span class="org-block">
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8220;(member x&#8320; &#8230; x&#8345;)&#8221; denotes the enumerated type consisting of only the x&#7522;.
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 3 '(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">member</span></span><span class="org-block"> 3 x </span><span class="org-block"><span class="string">"c"</span></span><span class="org-block">))  </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 'x '(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">member</span></span><span class="org-block"> 3 x </span><span class="org-block"><span class="string">"c"</span></span><span class="org-block">)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 'y '(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">member</span></span><span class="org-block"> 3 x </span><span class="org-block"><span class="string">"c"</span></span><span class="org-block">)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; false
</span></span><span class="org-block">
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8220;(satisfies p)&#8221; is the type of values that satisfy predicate p.
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 12 '(satisfies (</span><span class="org-block"><span class="keyword">lambda</span></span><span class="org-block"> (x) (</span><span class="org-block"><span class="highlight-defined-function-name">oddp</span></span><span class="org-block"> x)))) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; false
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 12 '(satisfies </span><span class="org-block"><span class="highlight-defined-function-name">evenp</span></span><span class="org-block">) )                </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Computation rule for comprehension types.
</span></span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">(typep x '(satisfies p)) &#8776; (if (p x) t nil)
</span></span><span class="org-block-end-line">#+END_SRC
</span>
Here's a convenient one: <span class="org-code">(booleanp x) &#8776; (typep x '(member t nil))</span>.
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">booleanp</span></span><span class="org-block"> 2)   </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; false
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">booleanp</span></span><span class="org-block"> nil) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block-end-line">#+END_SRC
</span>
Strongly typed languages like Haskell allow only a number of the type formers listed
above. For example, Haskell does not allow unions but instead offers so-called sum
types. Moreover, unlike Haskell, Lisp is non-parametric:
We may pick a branch of computation according to the type of a value.
Such case analysis is available in languages such as C# ---c.f.,
<span class="org-link"><span class="writegood-duplicates"><a href="https://blogs.msdn.microsoft.com/ericlippert/2010/09/16/is-is-as-or-is-as-is/">is is</a></span></span><span class="org-link"><a href="https://blogs.msdn.microsoft.com/ericlippert/2010/09/16/is-is-as-or-is-as-is/"> as or is as is</a></span>. Finally, it is important to realise that <span class="org-code">cons</span> is a monomorphic
type
---it just means an (arbitrary) element consisting of two parts called <span class="org-code">car</span> and <span class="org-code">cdr</span>---
we show how to form a <span class="org-link">polymorphic</span> product type below.

We may ask for <span class="italic">the</span> &#8216;primitive type&#8217; of an object;
which is the simplest built-in type that it belongs to,
such as integer, string, cons, symbol, record, subr, and a <span class="writegood-weasels">few</span> others.
As such, <span class="italic">Lisp objects come with an intrinsic primitive type</span>;
e.g., <span class="org-code">'(1 "2" 'three)</span> is a list and can only <span class="writegood-passive-voice">be treated</span> as a value of
another type if an explicit coercion <span class="writegood-passive-voice">is used</span>.
In Lisp, rather than variables, it is values that <span class="writegood-passive-voice">are associated</span> with a type.
One may optionally declare the types of variables, like in OCaml.
<span class="org-block-begin-line">#+begin_center org
</span><span class="org-block"><span class="italic">Lisp (primitive) types </span></span><span class="org-block"><span class="italic"><span class="writegood-passive-voice"><span class="writegood-passive-voice">are inferred</span></span></span></span><span class="org-block"><span class="italic">!</span></span><span class="org-block">

&#8220;Values have types, not variables.&#8221; ---Paul Graham, ANSI Common Lisp
</span><span class="org-block-end-line">#+end_center
</span>
Let's review <span class="writegood-weasels">some</span> important features of type systems and how they manifest themselves
in Lisp.

<span class="org-hide">*</span><span class="org-level-2">* Obtaining &amp; Checking Types</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
The typing relationship &#8220;:&#8221; is usually deterministic in its second argument for
static languages: <span class="org-code">e : &#964;  &#8743;  e : &#964;&#8242;  &#8658;  &#964; &#8776; &#964;&#8242;</span>. However this is not the case with
Lisp's <span class="org-code">typep</span>.

<span class="org-meta-line">#+caption:</span> <span class="org-block">Where are the types &amp; /when/ are they checked?</span>
<span class="org-table">| Style   | Definition                                | Examples         |</span>
<span class="org-table">|---------+-------------------------------------------+------------------|</span>
<span class="org-table">| Static  | Variables have a fixed type; compile time | Haskell &amp; C#     |</span>
<span class="org-table">| Dynamic | Values have a fixed type; runtime         | Lisp &amp; Smalltalk |</span>

In <span class="writegood-weasels">some</span> sense, dynamic languages make it <span class="writegood-weasels">easy</span> to produce <span class="org-link">polymorphic</span> functions.
Ironically, the previous sentences is only meaningful if you acknowledge the importance
of types and type variables.

In Lisp, types <span class="writegood-passive-voice">are inferred</span> and needn't <span class="writegood-passive-voice">be declared</span>.
However, the declaration serves as a nice documentation to further readers ;-)
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="keyword">setq</span></span><span class="org-block"> ellew 314)
(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">type-of</span></span><span class="org-block"> ellew) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; integer
</span></span><span class="org-block">
(</span><span class="org-block"><span class="keyword">setq</span></span><span class="org-block"> ellew </span><span class="org-block"><span class="string">"oh my"</span></span><span class="org-block">)
(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">type-of</span></span><span class="org-block"> ellew) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; string
</span></span><span class="org-block-end-line">#+END_SRC
</span>+ The <span class="org-code">type-of</span> function returns the type of a given object.
+ Re variables: Static &#8658; only values can change; dynamic &#8658; both values and types change.

We may check the type of an item using <span class="org-code">typep</span>, whose second argument
is a &#8220;type specifiers&#8221;
 ---an expressions whose value denotes a type; e.g., the <span class="org-code">or</span> expression below
 forms a &#8216;union type&#8217;.

There's also <span class="org-code">check-type</span>: It's like <span class="org-code">typep</span> but instead of yielding true or
false, it stays quiet in the former and signals a type error in the latter.

<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="keyword">check-type</span></span><span class="org-block"> 12 integer)               </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; nil, i.e., no error
</span></span><span class="org-block">(</span><span class="org-block"><span class="keyword">check-type</span></span><span class="org-block"> 12   (</span><span class="org-block"><span class="keyword">or</span></span><span class="org-block"> symbol integer)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">nil; i.e., no error
</span></span><span class="org-block">(</span><span class="org-block"><span class="keyword">check-type</span></span><span class="org-block"> </span><span class="org-block"><span class="string">"12"</span></span><span class="org-block"> (</span><span class="org-block"><span class="keyword">or</span></span><span class="org-block"> symbol integer)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Crash: Type error!
</span></span><span class="org-block-end-line">#+END_SRC
</span>
In summary:
<span class="org-table">| </span><span class="org-table"><span class="org-code">(equal &#964; (type-of e))</span></span><span class="org-table"> | </span><span class="org-table"><span class="org-code">&#8776;</span></span><span class="org-table"> | </span><span class="org-table"><span class="org-code">(typep e &#964;)</span></span><span class="org-table">                       |</span>
<span class="org-table">| </span><span class="org-table"><span class="org-code">(check-type e &#964;)</span></span><span class="org-table">      | </span><span class="org-table"><span class="org-code">&#8776;</span></span><span class="org-table"> | </span><span class="org-table"><span class="org-code">(unless (typep e '&#964;) (error "&#8943;"))</span></span><span class="org-table"> |</span>

( Note: (<span class="org-code">unless x y) &#8776; (when (not x) y)</span> .)
<span class="org-hide">*</span><span class="org-level-2">* Statics &amp; Dynamics of Lisp</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
<span class="org-block-begin-line"> #+BEGIN_quote
</span><span class="org-quote"> Types are the central organising principle of the theory of programming languages.
 Language features are manifestations of type structure.
 The syntax of a language </span><span class="org-quote"><span class="writegood-passive-voice">is governed</span></span><span class="org-quote"> by the constructs that define its types, and
 its semantics </span><span class="org-quote"><span class="writegood-passive-voice">is determined</span></span><span class="org-quote"> by the interactions among those constructs.

 --- Robert Harper, Practical Foundations for Programming Languages
</span><span class="org-block-end-line"> #+END_quote
</span>
 Besides atoms like numbers and strings,
 the only way to form new terms in Lisp is using &#8220;modus ponens&#8221;,
 or &#8220;function application&#8221;. Here's a first approximation:
<span class="org-block-begin-line"> #+BEGIN_SRC math
</span>f : &#964;&#8321; &#8594; &#8943; &#8594; &#964;&#8345; &#8594; &#964;   e&#8321; : &#964;&#8321;  &#8230;  e&#8345; : &#964;&#8345;
-----------------------------------------------------------------------------------------
           (f e&#8321; &#8230; e&#8345;) : &#964;
<span class="org-block-end-line"> #+END_SRC
</span>One reads such a fraction as follows: If each part of the numerator ---the &#8216;hypothesises&#8217;--- is true, then so is the denominator ---the &#8216;conclusion&#8217;.

 An <span class="italic">abstract syntax tree</span>, or &#8216;AST&#8217;, is a tree with operators for branches
 and arguments for children. A tree is of kind &#964; if the topmost branching operator has &#964; as its resulting type. Here's an improved rule:
<span class="org-block-begin-line"> #+BEGIN_SRC math
</span>f : &#964;&#8321; &#8594; &#8943; &#8594; &#964;&#8345; &#8594; &#964;   e&#8321; : AST &#964;&#8321;  &#8230;  e&#8345; : AST &#964;&#8345;
-----------------------------------------------------------------------------------------
              (f e&#8321; &#8230; e&#8345;) : AST &#964;
<span class="org-block-end-line"> #+END_SRC
</span>
 A Lisp top-level then may execute or interpret such a form to obtain a value:
 When we write <span class="org-code">e</span> at a top-level, it is essentially <span class="org-code">(eval e)</span> that <span class="writegood-passive-voice">is invoked</span>.
<span class="org-block-begin-line"> #+BEGIN_SRC math
</span>   e : AST &#964;
-----------------------------------------------------------------------------------------
  (eval e) : &#964;
<span class="org-block-end-line"> #+END_SRC
</span>
 However, we may also protect against evaluation.
<span class="org-block-begin-line"> #+BEGIN_SRC math
</span>     e : AST &#964;
-----------------------------------------------------------------------------------------
  (quote e) : AST &#964;
<span class="org-block-end-line"> #+END_SRC
</span>
 We have the following execution rules, where &#8216;&#10239;&#8217; denotes &#8220;reduces to&#8221;.
<span class="org-block-begin-line"> #+BEGIN_SRC math
</span>(eval a)         &#10239; a                        ;; for atom &#8216;a&#8217;
(eval (quote e))   &#10239; e
(eval (f e&#8321; &#8230; e&#8345;)) &#10239; (f (eval e&#8321;) &#8943; (eval e&#8345;)) ;; Actually invoke &#8216;f&#8217;
<span class="org-block-end-line"> #+END_SRC
</span>
<span class="org-block-begin-line"> #+begin_center
</span> <span class="italic">A conceptual model of Lisp is </span><span class="italic"><span class="org-code">eval</span></span><span class="italic">.</span>
<span class="org-block-end-line"> #+end_center
</span>
<span class="org-hide">*</span><span class="org-level-2">* Variable Scope</span>
<span class="org-drawer">:PROPERTIES:...
</span>
There's also the matter of &#8220;scope&#8221;, or &#8216;life time&#8217;, of a variable.

<span class="org-meta-line">#+caption:</span> <span class="org-block">Local variables temporarily mask global names &#8230;</span>
<span class="org-table">| Style   | Definition               | Examples                               |</span>
<span class="org-table">|---------+--------------------------+----------------------------------------|</span>
<span class="org-table">| Lexical | &#8230; only in visible code   | Nearly every language!                 |</span>
<span class="org-table">| Dynamic | &#8230; every place imaginable | Bash, Perl, &amp; allowable in </span><span class="org-table"><span class="writegood-weasels">some</span></span><span class="org-table"> Lisps |</span>

That is, dynamic scope means a local variable not only acts as a global variable
for the rest of the scope but it does so even in the definitions of pre-defined methods
<span class="writegood-passive-voice">being invoked</span> in the scope.
<span class="org-block-begin-line">#+BEGIN_SRC elisp
</span><span class="org-block">(</span><span class="org-block"><span class="keyword">setq</span></span><span class="org-block"> it </span><span class="org-block"><span class="string">"bye"</span></span><span class="org-block">)
(</span><span class="org-block"><span class="keyword">defun</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">go</span></span><span class="org-block"> () it)
(</span><span class="org-block"><span class="keyword">let</span></span><span class="org-block"> ((it 3)) (go)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; 3; even though &#8220;it&#8221; does not occur textually!
</span></span><span class="org-block">
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Temporarily enable lexical binding in Emacs Lisp
</span></span><span class="org-block">(</span><span class="org-block"><span class="keyword">setq</span></span><span class="org-block"> </span><span class="org-block"><span class="highlight-defined-variable-name">lexical-binding</span></span><span class="org-block"> </span><span class="org-block"><span class="highlight-defined-variable-name">t</span></span><span class="org-block">)
(</span><span class="org-block"><span class="keyword">let</span></span><span class="org-block"> ((it 3)) (go)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; bye; as most languages would act
</span></span><span class="org-block-end-line">#+END_SRC
</span>
<span class="org-block-begin-line">#+begin_center org
</span><span class="org-block"><span class="italic">Dynamic scope lets bindings leak down into all constituents in its wake.</span></span><span class="org-block">
</span><span class="org-block-end-line">#+end_center
</span>
That is fantastic when we want to do <span class="org-link"><a href="https://nullprogram.com/blog/2012/08/15/">unit tests</a></span> involving utilities with side-effects:
We <span class="writegood-weasels">simply</span> locally re-define the side-effect component to, say, do nothing. (&#9472;&#8255;&#8255;&#9472;)

<span class="org-hide">*</span><span class="org-level-2">* Casts &amp; Coercions</span>
<span class="org-drawer">:PROPERTIES:...
</span>
<span class="org-meta-line">#+caption:</span> <span class="org-block">The frequency of implicit type coercions</span>
<span class="org-table">| Style  | Definition              | Examples       |</span>
<span class="org-table">|--------+-------------------------+----------------|</span>
<span class="org-table">| Strong | Almost never            | Lisp &amp; Haskell |</span>
<span class="org-table">| Weak   | Try as best as possible | JavaScript &amp; C |</span>

<span class="italic">Strong systems will not accidentally coerce terms.</span>

Lisp has a <span class="org-link"><a href="http://www.lispworks.com/documentation/lw51/CLHS/Body/f_coerce.htm#coerce">coerce</a></span> form; but coercion semantics is generally unsound
in any language and so should <span class="writegood-passive-voice">be used</span> with tremendous caution.
( Though Haskell has <span class="writegood-weasels">some</span> sensible coercions as well as unsafe one. )
<span class="org-block-begin-line">#+BEGIN_SRC math
</span>     e : &#945;
----------------------------------------------------------------------------------------
(coerce e &#946;) : &#946;
<span class="org-block-end-line">#+END_SRC
</span>We have a magical way to turn elements of type &#945; to elements of type &#946;.
<span class="writegood-weasels">Some</span> languages call this <span class="italic">type casting</span>.

Here's a cute example.
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">coerce</span></span><span class="org-block"> '(76 105 115 112) '</span><span class="org-block"><span class="highlight-defined-builtin-function-name">string</span></span><span class="org-block">) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; Lisp
</span></span><span class="org-block-end-line">#+END_SRC
</span><span class="org-hide">*</span><span class="org-level-2">* Type Annotations</span>
<span class="org-drawer">:PROPERTIES:...
</span>
We may perform type annotations using the form <span class="org-code">the</span>; e.g.,
the Haskell expression <span class="org-code">(1 :: Int) + 2</span> checks the type annotation,
and, if it passes, yields the value and the expression <span class="writegood-passive-voice">is computed</span>.
Likewise, <span class="org-code">(the type name)</span> yields <span class="org-code">name</span> provided it has type <span class="org-code">type</span>.

<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">+</span></span><span class="org-block"> (</span><span class="org-block"><span class="keyword">the</span></span><span class="org-block"> integer 1)
   (</span><span class="org-block"><span class="keyword">the</span></span><span class="org-block"> integer 2)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; 3
</span></span><span class="org-block">
(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">+</span></span><span class="org-block"> (</span><span class="org-block"><span class="keyword">the</span></span><span class="org-block"> integer 1)
   (</span><span class="org-block"><span class="keyword">the</span></span><span class="org-block"> integer </span><span class="org-block"><span class="string">"2"</span></span><span class="org-block">)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; Type error.
</span></span><span class="org-block-end-line">#+END_SRC
</span>
Computationally, using <span class="org-code">or</span> as a control structure for lazy sequencing with left-unit <span class="org-code">nil</span>:
<span class="org-table">| </span><span class="org-table"><span class="org-code">(the &#964; e) &#8776; (or (check-type e &#964;) e)</span></span><span class="org-table"> |</span>

<span class="org-hide">*</span><span class="org-level-2">* Type-directed Computations</span>
<span class="org-drawer">:PROPERTIES:...
</span>
   Sometimes a value can be one of <span class="writegood-weasels">several</span> types.
   This <span class="writegood-passive-voice">is specified</span> using union types; nested unions are essentially flattened
   ---which is a property of &#8216;or&#8217;, as we shall come to see.

<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 12 'integer)  </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 'a 'symbol)   </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">
(</span><span class="org-block"><span class="keyword">setq</span></span><span class="org-block"> woah 12)
(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> woah '(</span><span class="org-block"><span class="keyword">or</span></span><span class="org-block"> integer symbol)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">
(</span><span class="org-block"><span class="keyword">setq</span></span><span class="org-block"> woah 'nice)
(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> woah '(</span><span class="org-block"><span class="keyword">or</span></span><span class="org-block"> integer symbol)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block-end-line">#+END_SRC
</span>
When given a union type, we may want to <span class="italic">compute according to the type of a value.</span>
+ Case along the possible types using <span class="org-code">typecase</span>.
+ This returns a <span class="org-code">nil</span> when no case fits; use <span class="org-code">etypecase</span> to have an error instead of <span class="org-code">nil</span>.

<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="keyword">typecase</span></span><span class="org-block"> woah
  (integer  (+1 woah))
  (symbol  'cool)
  (</span><span class="org-block"><span class="highlight-defined-variable-name">t</span></span><span class="org-block">       </span><span class="org-block"><span class="string">"yikes"</span></span><span class="org-block">))
</span><span class="org-block-end-line">#+END_SRC
</span>
<span class="org-hide">*</span><span class="org-level-2">* Type Specifiers: On the nature of types in Lisp</span>
<span class="org-drawer">:PROPERTIES:...
</span>
<span class="org-block-begin-line">#+begin_quote
</span><span class="org-quote">Types are not objects in Common Lisp. There is no object that corresponds to the type
</span><span class="org-quote"><span class="org-code">integer</span></span><span class="org-quote">, for example. What we get from a function like </span><span class="org-quote"><span class="org-code">type-of</span></span><span class="org-quote">, and give as an argument
to a function like </span><span class="org-quote"><span class="org-code">typep</span></span><span class="org-quote">, is not a type, but a type specifier.
A type specifier is the name of a type. ---Paul Graham, ANSI Common Lisp
</span><span class="org-block-end-line">#+end_quote
</span>
Type specifiers are essentially transformed into predicates as follows.
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> x '&#964;)                &#8776; (&#964;p x)  </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">E.g., &#964; &#8776; integer
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> x '(</span><span class="org-block"><span class="keyword">and</span></span><span class="org-block"> &#964;&#8321; &#8230; &#964;&#8345;))    &#8776; (</span><span class="org-block"><span class="keyword">and</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> x &#964;&#8321;) &#8230; (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> x &#964;&#8345;))
(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> x '(</span><span class="org-block"><span class="keyword">or</span></span><span class="org-block"> &#964;&#8321; &#8230; &#964;&#8345;))     &#8776; (</span><span class="org-block"><span class="keyword">or</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> x &#964;&#8321;) &#8230; (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> x &#964;&#8345;))
(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> x '(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">not</span></span><span class="org-block"> &#964;))          &#8776; (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">not</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> x &#964;))
(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> x '(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">member</span></span><span class="org-block"> e&#8321; &#8230; e&#8345;)) &#8776; (</span><span class="org-block"><span class="keyword">or</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">eql</span></span><span class="org-block"> x e&#8321;) &#8230; (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">eql</span></span><span class="org-block"> x e&#8345;))
(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> x '(satisfies p))    &#8776; (p x)
</span><span class="org-block-end-line">#+END_SRC
</span>
Type specifiers are thus essentially &#8216;characteristic functions&#8217; from mathematics.

<span class="org-hide">*</span><span class="org-level-2">* Making New Types with </span><span class="org-level-2"><span class="org-code">deftype</span></span>
<span class="org-drawer">:PROPERTIES:...
</span>
If we use a type specifier <span class="writegood-weasels">often</span>, we may wish to abbreviate it using
the <span class="org-link"><a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#index-cl_002ddeftype-14">deftype</a></span> macro ---it is like <span class="org-code">defmacro</span> but expands into a type specifier
instead of an expression.
<span class="comment"># Alternatively, we obtain type specifiers by defining</span>
<span class="comment"># new structures using the defstruct mechanism.</span>

We can define new types that will then work with <span class="org-code">typecase</span> and friends
as follows:
1. Define a predicate <span class="org-code">my-type-p</span>.
2. Test it out to ensure only the elements you want satisfy it.
3. Register it using <span class="org-link"><a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#index-cl_002ddeftype-14">deftype</a></span>.

   You could just do number 3 directly, but it's useful to have the
   predicate form of a <span class="org-link">type descriptor</span>.

<span class="org-link"><a href="https://lispcookbook.github.io/cl-cookbook/type.html">For example,</a></span> here's the three steps for a type of lists of numbers drawn from <span class="org-code">(-&#8734;..9]</span>.
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Make the predicate
</span></span><span class="org-block">(</span><span class="org-block"><span class="keyword">defun</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">small-number-seq-p</span></span><span class="org-block"> (thing)
  (</span><span class="org-block"><span class="keyword">and</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">sequencep</span></span><span class="org-block"> thing)
       (</span><span class="org-block"><span class="highlight-defined-function-name">every</span></span><span class="org-block"> #'</span><span class="org-block"><span class="highlight-defined-builtin-function-name">numberp</span></span><span class="org-block"> thing)
       (</span><span class="org-block"><span class="highlight-defined-function-name">every</span></span><span class="org-block"> (</span><span class="org-block"><span class="keyword">lambda</span></span><span class="org-block"> (x) (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">&lt;</span></span><span class="org-block"> x 10)) thing)))

</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Test it
</span></span><span class="org-block">(</span><span class="org-block"><span class="keyword">setq</span></span><span class="org-block"> yes '(1 2  4))
(</span><span class="org-block"><span class="keyword">setq</span></span><span class="org-block"> no  '(1 20 4))
(small-number-seq-p yes) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Register it
</span></span><span class="org-block">(</span><span class="org-block"><span class="keyword">deftype</span></span><span class="org-block"> small-number-seq ()
  '(satisfies small-number-seq-p))

</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Use it
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> yes 'small-number-seq) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> no 'small-number-seq)  </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; false
</span></span><span class="org-block-end-line">#+END_SRC
</span>
 Arguments <span class="writegood-passive-voice">are processed</span> the same as for <span class="org-code">defmacro</span> except that optional
 arguments without explicit defaults use <span class="org-code">*</span> instead of <span class="org-code">nil</span> as the default value.
 <span class="org-link"><a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#index-cl_002ddeftype-14">From the deftype docs, here are </a></span><span class="org-link"><span class="writegood-weasels"><a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#index-cl_002ddeftype-14">some</a></span></span><span class="org-link"><a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#index-cl_002ddeftype-14"> examples:</a></span>
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="keyword">cl-deftype</span></span><span class="org-block"> </span><span class="org-block"><span class="type">null</span></span><span class="org-block"> () '(satisfies </span><span class="org-block"><span class="highlight-defined-builtin-function-name">null</span></span><span class="org-block">))    </span><span class="org-block"><span class="comment-delimiter">; </span></span><span class="org-block"><span class="comment">predefined
</span></span><span class="org-block">(</span><span class="org-block"><span class="keyword">cl-deftype</span></span><span class="org-block"> </span><span class="org-block"><span class="type">list</span></span><span class="org-block"> () '(</span><span class="org-block"><span class="keyword">or</span></span><span class="org-block"> </span><span class="org-block"><span class="highlight-defined-builtin-function-name">null</span></span><span class="org-block"> </span><span class="org-block"><span class="highlight-defined-builtin-function-name">cons</span></span><span class="org-block">))      </span><span class="org-block"><span class="comment-delimiter">; </span></span><span class="org-block"><span class="comment">predefined
</span></span><span class="org-block">
(</span><span class="org-block"><span class="keyword">cl-deftype</span></span><span class="org-block"> </span><span class="org-block"><span class="type">unsigned-byte</span></span><span class="org-block"> (</span><span class="org-block"><span class="type">&amp;optional</span></span><span class="org-block"> bits)
  (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">list</span></span><span class="org-block"> 'integer 0 (</span><span class="org-block"><span class="keyword">if</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">eq</span></span><span class="org-block"> bits '</span><span class="org-block"><span class="highlight-defined-builtin-function-name">*</span></span><span class="org-block">) bits (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">1-</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-function-name">lsh</span></span><span class="org-block"> 1 bits)))))

</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment"><span class="writegood-weasels">Some</span></span></span><span class="org-block"><span class="comment"> equivalences
</span></span><span class="org-block">(unsigned-byte 8)  &#8801;  (integer 0 255)
(unsigned-byte)    &#8801;  (integer 0 </span><span class="org-block"><span class="highlight-defined-builtin-function-name">*</span></span><span class="org-block">)
unsigned-byte      &#8801;  (integer 0 </span><span class="org-block"><span class="highlight-defined-builtin-function-name">*</span></span><span class="org-block">)
</span><span class="org-block-end-line">#+END_SRC
</span>
+ Notice that type specifiers essentially live in their own namespace; e.g., <span class="org-code">null</span> is the
  predicate that checks if a list is empty yet <span class="org-code">null</span> is the type specifying such lists.
<span class="comment">  # (null nil) (typep nil 'null) (endp nil) (endp '(1))</span>

Let's form a type of pairs directly ---which is not ideal!
This is a <span class="org-target">&lt;&lt;&lt;polymorphic&gt;&gt;&gt;</span> datatype: It takes two type arguments, called <span class="org-code">a</span> and <span class="org-code">b</span> below.
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="keyword">deftype</span></span><span class="org-block"> pair (a b </span><span class="org-block"><span class="type">&amp;optional</span></span><span class="org-block"> type)
  `(satisfies (</span><span class="org-block"><span class="keyword">lambda</span></span><span class="org-block"> (x) (</span><span class="org-block"><span class="keyword">and</span></span><span class="org-block">
      (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">consp</span></span><span class="org-block"> x)
      (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">car</span></span><span class="org-block"> x) (</span><span class="org-block"><span class="keyword">quote</span></span><span class="org-block"> ,a))
      (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">cdr</span></span><span class="org-block"> x) (</span><span class="org-block"><span class="keyword">quote</span></span><span class="org-block"> ,b))))))

(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> '(</span><span class="org-block"><span class="string">"x"</span></span><span class="org-block"> . 2) '(pair </span><span class="org-block"><span class="highlight-defined-builtin-function-name">string</span></span><span class="org-block"> integer)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> '(</span><span class="org-block"><span class="string">"x"</span></span><span class="org-block"> . 2) '(pair symbol integer)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; false
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> nil '(pair </span><span class="org-block"><span class="writegood-duplicates">integer integer</span></span><span class="org-block">))       </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; false
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 23 '(pair </span><span class="org-block"><span class="writegood-duplicates">integer integer</span></span><span class="org-block">))        </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; false
</span></span><span class="org-block">
(</span><span class="org-block"><span class="keyword">setq</span></span><span class="org-block"> ss </span><span class="org-block"><span class="string">"nice"</span></span><span class="org-block"> nn 114)
(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> `(,ss . ,nn) '(pair </span><span class="org-block"><span class="highlight-defined-builtin-function-name">string</span></span><span class="org-block"> integer)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">cons</span></span><span class="org-block"> ss nn) '(pair </span><span class="org-block"><span class="highlight-defined-builtin-function-name">string</span></span><span class="org-block"> integer)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">The following are false since ss and nn </span></span><span class="org-block"><span class="comment"><span class="writegood-passive-voice">are quoted</span></span></span><span class="org-block"><span class="comment"> symbols!
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> '(ss . nn)    '(pair </span><span class="org-block"><span class="highlight-defined-builtin-function-name">string</span></span><span class="org-block"> integer)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; false
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> `(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">cons</span></span><span class="org-block"> ss nn) '(pair </span><span class="org-block"><span class="highlight-defined-builtin-function-name">string</span></span><span class="org-block"> integer)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; false
</span></span><span class="org-block-end-line">#+END_SRC
</span>
<span class="bold">Exercise:</span> Define the <span class="org-link">polymorphic</span> <span class="org-code">maybe</span> type
such that <span class="org-code">(maybe &#964;)</span> has elements being either <span class="org-code">nil</span> or a value of <span class="org-code">&#964;</span>.
<span class="org-drawer">:Hide:...
</span>
<span class="org-meta-line">#
# Recursive types are types whose definitions refer to themselves.</span>
<span class="org-meta-line">#
Let's define type ~list-of~ such that ~(list-of &#964;)~ is the type of lists</span>
whose elements are all values of type <span class="org-code">&#964;</span>.
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Make the predicate
</span></span><span class="org-block">(</span><span class="org-block"><span class="keyword">defun</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">list-of-p</span></span><span class="org-block"> (&#964; thing)
  (</span><span class="org-block"><span class="keyword">and</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">listp</span></span><span class="org-block"> thing) (</span><span class="org-block"><span class="highlight-defined-function-name">every</span></span><span class="org-block"> (</span><span class="org-block"><span class="keyword">lambda</span></span><span class="org-block"> (x) (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> x &#964;)) thing)))

</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Test it
</span></span><span class="org-block">(list-of-p 'integer '(1 2   3)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">(list-of-p 'integer '(1 two 3)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; false
</span></span><span class="org-block">(list-of-p '</span><span class="org-block"><span class="highlight-defined-builtin-function-name">string</span></span><span class="org-block"> '())         </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">(list-of-p '</span><span class="org-block"><span class="highlight-defined-builtin-function-name">string</span></span><span class="org-block"> '(no))       </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; false
</span></span><span class="org-block">
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Register it
</span></span><span class="org-block">(</span><span class="org-block"><span class="keyword">deftype</span></span><span class="org-block"> list-of (&#964;)
  `(satisfies (</span><span class="org-block"><span class="keyword">lambda</span></span><span class="org-block"> (thing) (list-of-p (</span><span class="org-block"><span class="keyword">quote</span></span><span class="org-block"> ,&#964;) thing))))

</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Use it
</span></span><span class="org-block">
(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> '(1 2  ) '</span><span class="org-block"><span class="highlight-defined-builtin-function-name">list</span></span><span class="org-block">) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> '(1 two) '</span><span class="org-block"><span class="highlight-defined-builtin-function-name">list</span></span><span class="org-block">) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">
(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> '(1 2)   '(list-of integer)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> '(1 </span><span class="org-block"><span class="string">"2"</span></span><span class="org-block">) '(list-of </span><span class="org-block"><span class="highlight-defined-builtin-function-name">string</span></span><span class="org-block">))  </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; false
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> '(1 </span><span class="org-block"><span class="string">"2"</span></span><span class="org-block">) '(list-of (</span><span class="org-block"><span class="keyword">or</span></span><span class="org-block"> integer </span><span class="org-block"><span class="highlight-defined-builtin-function-name">string</span></span><span class="org-block">)))  </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block-end-line">#+END_SRC
</span>
Notice that by the last example we can <span class="bold">control the degree of heterogeneity</span> in our lists!
So cool!

Here's <span class="writegood-weasels">some</span> more exercises. The first should be nearly trivial, the second a bit more
work, and the last two have made me #sad.

1. Define a type <span class="org-code">(rose &#964;)</span> whose elements are either &#964; values or rose trees of type &#964;.

2. Define a type <span class="org-code">record</span> so that <span class="org-code">(record &#964;&#8321; &#8230; &#964;&#8345;)</span> denotes a record type whose i&#7511;&#688;
   component has type <span class="org-code">&#964;&#7522;</span>.

3. Define a type constructor <span class="org-code">&#8707;</span> such that, for example, <span class="org-code">(&#8707; &#964; (pair integer &#964;)</span>
   denotes the type of pairs where the first components are integers and the second
   components all have the same type <span class="org-code">&#964;</span>, but we do not know which one.

   My idea was to let <span class="org-code">&#964;</span> denote the type of the first occurrence of a value
   at that location, then all subsequent checks now refer to this value of <span class="org-code">&#964;</span>.

   Sadly, I could not define this type :'(

   Upon further reading, this may be doable using a <span class="org-link"><a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Watching-Variables.html#Watching-Variables">variable watcher</a></span>.

4. Produce a record for monoids and keep-track of the monoid instances produced.
   Define a the predicate <span class="org-code">(monoid &#964;)</span> to check if any of the monoid instances
   has <span class="org-code">&#964;</span> as its carrier type. In this way we could simulate Haskell typeclasses.

<span class="org-drawer">   :getting_started:...
</span>
Let me know if you do cool things!
<span class="org-hide">*</span><span class="org-level-2">* Algebraic Data Types a la Haskell</span>
<span class="org-drawer">:PROPERTIES:...
</span>   Consider the Haskell expression type, example, and integer evaluator.
<span class="org-block-begin-line">#+BEGIN_SRC haskell :tangle expr.hs
</span><span class="org-block"><span class="haskell-keyword">data</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">Expr</span></span><span class="org-block"> a </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Var</span></span><span class="org-block"> a </span><span class="org-block"><span class="haskell-operator">|</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Expr</span></span><span class="org-block"> a </span><span class="org-block"><span class="haskell-constructor">:+:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Expr</span></span><span class="org-block"> a </span><span class="org-block"><span class="haskell-operator">|</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Neg</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">Expr</span></span><span class="org-block"> a) </span><span class="org-block"><span class="haskell-keyword">deriving</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Show</span></span><span class="org-block">

</span><span class="org-block"><span class="haskell-definition">ex</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">::</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">Expr</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">Int</span></span><span class="org-block">
</span><span class="org-block"><span class="haskell-definition">ex</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Var</span></span><span class="org-block"> 5 </span><span class="org-block"><span class="haskell-constructor">:+:</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">Var</span></span><span class="org-block"> 6 </span><span class="org-block"><span class="haskell-constructor">:+:</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-constructor">Neg</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">Var</span></span><span class="org-block"> 7))

</span><span class="org-block"><span class="haskell-definition">int</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">::</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">Expr</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">Int</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">-&gt;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type"><span class="writegood-duplicates">Int</span></span></span><span class="org-block"><span class="writegood-duplicates">
</span></span><span class="org-block"><span class="haskell-definition"><span class="writegood-duplicates">int</span></span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">Var</span></span><span class="org-block"> n)    </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> n
</span><span class="org-block"><span class="haskell-definition">int</span></span><span class="org-block"> (l </span><span class="org-block"><span class="haskell-constructor">:+:</span></span><span class="org-block"> r)  </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> int l </span><span class="org-block"><span class="haskell-operator">+</span></span><span class="org-block"> int r
</span><span class="org-block"><span class="haskell-definition">int</span></span><span class="org-block"> (</span><span class="org-block"><span class="haskell-constructor">Neg</span></span><span class="org-block"> e)    </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">-</span></span><span class="org-block"> (int e)

</span><span class="org-block"><span class="comment-delimiter">{- </span></span><span class="org-block"><span class="comment">int ex &#8658; 4 -}</span></span><span class="org-block">
</span><span class="org-block-end-line">#+END_SRC
</span>
If we view a constructor declaration <span class="org-code">C a&#8321; &#8230; a&#8345;</span> with superfluous parenthesis
as <span class="org-code">(C a&#8321; &#8230; a&#8345;)</span>, then a translation to Lisp immediately suggests itself:
<span class="org-block-begin-line">#+begin_center
</span><span class="italic">Haskell constructors &#8773; Lisp lists whose </span><span class="italic"><span class="org-code">car</span></span><span class="italic"> are constructor names</span>
<span class="org-block-end-line">#+end_center
</span>
A nearly direct translation follows.
<span class="org-block-begin-line">#+BEGIN_SRC lisp
</span><span class="org-block">(</span><span class="org-block"><span class="keyword">defun</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">exprp</span></span><span class="org-block"> (&#964; thing)
    (pcase thing
       (`(var ,n)    (typep n &#964;))
       (`(add ,l ,r) (and (exprp &#964; l) (exprp &#964; r)))
       (`(neg ,e)    (exprp &#964; e))))

(setq ex '(add (var 5) (add (var 6) (neg (var 7)))))
(exprp 'integer ex) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">
</span><span class="org-block"><span class="comment-delimiter">; </span></span><span class="org-block"><span class="comment">This declarion &#8220;declare-type&#8221; </span></span><span class="org-block"><span class="comment"><span class="writegood-passive-voice">is defined</span></span></span><span class="org-block"><span class="comment"> near the end of this article.
</span></span><span class="org-block">(declare-type int : (expr-of integer) integer)
(</span><span class="org-block"><span class="keyword">defun</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">int</span></span><span class="org-block"> (thing)
    (pcase thing
       (`(var ,n)    n)
       (`(add ,l ,r) (+ (int l) (int r)))
       (`(neg ,e)    (- (int e)))))

(int ex) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; 4
</span></span><span class="org-block-end-line">#+END_SRC
</span>
There are of-course much better ways to do this in Lisp; e.g.,
use <span class="org-code">identity, +, -</span> in-place of the <span class="org-code">var, add, neg</span> tags
to produce &#8220;syntax that carries its semantics&#8221;
or express the interpreter <span class="org-code">int</span> as a one liner
by replacing the formal tags with their interpretations then
invoking Lisps <span class="org-code">eval</span>. I doubt either of these are new ideas,
but the merit of the former seems neat ---at a first glance, at least.

Support for ADTs in Common Lisp along with seemingly less clunky pattern matching
can <span class="writegood-passive-voice">be found</span> <span class="org-link"><a href="https://github.com/stylewarning/cl-algebraic-data-type">here</a></span> ---which I have only briefly looked at.

The Haskell presentation has type-checking baked into it, yet our
Lisp interpreter <span class="org-code">int</span> does not! This seems terribly worrying, but
that <span class="org-link"><span class="org-code">declare-type</span></span> declaration actually handles type checking for us!
<span class="org-block-begin-line">#+BEGIN_SRC lisp
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Register the type
</span></span><span class="org-block">(</span><span class="org-block"><span class="keyword">deftype</span></span><span class="org-block"> </span><span class="org-block"><span class="type">expr-of</span></span><span class="org-block"> (&#964;)
  `(satisfies (</span><span class="org-block"><span class="keyword">lambda</span></span><span class="org-block"> (thing) (exprp (quote ,&#964;) thing))))

</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Try it out
</span></span><span class="org-block">(typep '(1 2)   '(expr-of integer)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; nil
</span></span><span class="org-block">(typep ex   '(expr-of integer))     </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">This invocation, for example, now yields a helpful error message.
</span></span><span class="org-block">(int '(var 6 4))
</span><span class="org-block"><span class="comment-delimiter">;;</span></span><span class="org-block"><span class="comment">
</span></span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; int: Type mismatch! Expected (expr-of integer) for argument 0 &#8800; Given cons (var 6 4).
</span></span><span class="org-block"><span class="comment-delimiter">;;</span></span><span class="org-block"><span class="comment">
</span></span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Which is reasonable since the &#8216;</span></span><span class="org-block"><span class="comment"><span class="constant">var</span></span></span><span class="org-block"><span class="comment">&#8217; constructor only takes a single argument.
</span></span><span class="org-block-end-line">#+END_SRC
</span>Notice that invalid cases yield a helpful (run-time) error message!

<span class="org-level-1">* In Defence of Being Dynamically Checked</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
<span class="org-block-begin-line">#+begin_center org
</span><span class="org-block"><span class="italic">Lisp gets a bad rap for </span></span><span class="org-block"><span class="italic"><span class="writegood-passive-voice"><span class="writegood-passive-voice">being untyped</span></span></span></span><span class="org-block"><span class="italic">; let's clarify this issue further!</span></span><span class="org-block">
</span><span class="org-block-end-line">#+end_center
</span>
It is important to realise that nearly every language <span class="writegood-passive-voice">is typed</span> ---albeit the checking
may happen at different stages--- and so, as <span class="org-link"><a href="http://www.cis.upenn.edu/~bcpierce/tapl/index.html">Benjamin Pierce</a></span> says:
<span class="italic">Terms like &#8220;dynamically typed&#8221; are arguably misnomers and should </span><span class="italic"><span class="writegood-weasels">probably</span></span><span class="italic"> </span><span class="italic"><span class="writegood-passive-voice">be replaced</span></span><span class="italic"> by &#8220;dynamically checked,&#8221; but the usage is standard.</span>

In particular, dynamically typed is <span class="italic">not</span> synonymous with untyped, though <span class="writegood-weasels">some</span> people use
it that way since nearly <span class="org-link"><a href="https://www.williamjbowman.com/blog/2018/01/19/untyped-programs-don-t-exist/#related">every language </a></span><span class="org-link"><span class="writegood-passive-voice"><a href="https://www.williamjbowman.com/blog/2018/01/19/untyped-programs-don-t-exist/#related">is typed</a></span></span> ---possibly with a single anonymous
type.
<span class="org-meta-line">#
# I dont feel this anymore.</span>
<span class="org-meta-line">#
# Examples of languages that don't carry dynamic type tags and so may </span><span class="org-meta-line"><span class="writegood-passive-voice">be considered</span></span>
<span class="comment"># untyped include Fortran, Bash, and assembly code.</span>

<span class="writegood-weasels">Some</span> people in the Haskell community, which I love, say things like
<span class="italic">&#8220;if it typechecks, ship it&#8221;</span> which is true more <span class="writegood-weasels">often</span> than not, but it leads <span class="writegood-weasels">some</span>
people to avoid producing unit tests. For example, the following type checks but
should be unit tested.
<span class="org-block-begin-line">#+BEGIN_SRC haskell
</span><span class="org-block"><span class="haskell-definition">mcbride</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-operator">::</span></span><span class="org-block"> [</span><span class="org-block"><span class="haskell-type">Int</span></span><span class="org-block">] </span><span class="org-block"><span class="haskell-operator">-&gt;</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-type">Int</span></span><span class="org-block">
</span><span class="org-block"><span class="haskell-definition">mcbride</span></span><span class="org-block"> xs </span><span class="org-block"><span class="haskell-operator">=</span></span><span class="org-block"> </span><span class="org-block"><span class="haskell-keyword">if</span></span><span class="org-block"> null xs </span><span class="org-block"><span class="haskell-keyword">then</span></span><span class="org-block"> head xs </span><span class="org-block"><span class="haskell-keyword">else</span></span><span class="org-block"> 666
</span><span class="org-block-end-line">#+END_SRC
</span>
Regardless, I love static type checking and static analysis in general.
However, the shift to a dynamically checked setting has resulted in greater
interest in unit testing. For example, Haskell's solution to effectful computation
<span class="writegood-passive-voice">is delimited</span> by types, as any Haskeller will proudly say (myself included);
but ask how are such computations unit tested and the room is
silent (myself included).

<span class="writegood-weasels">Interestingly</span> <span class="writegood-weasels">some</span> unit tests check the typing of inputs and output, which is
a mechanical process with no unknowns and so it should be possible to produce a syntax
for it using Lisp macros. This is one of the goals of this article and we'll return to
it later.

Even though I like Lisp, I'm not sure why dynamic typing is the way to go
---c.f. <span class="org-link"><a href="https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/">Dynamic Languages are Static Languages</a></span> which mentions the unjust tyranny of
unityped systems.
Below are two reasons why people may dislike static types.

<span class="comment"># I've also heard that static types &#8220;get in the way&#8221; which makes sense: Engineers should</span>
<span class="comment"># also just build things without any prior planning too!</span>
<span class="org-meta-line">#
*First*: The de-facto typing rule do binary choice is usually:</span>
<span class="org-block-begin-line">#+BEGIN_SRC math
</span>     T : &#120121;     E : &#945;     B : &#945; -----------------------------------------------------------------------------------------
     if T then E else B : &#945;
<span class="org-block-end-line">#+END_SRC
</span>
That means valid programs such as <span class="org-code">if True then 1 else "two"</span> <span class="writegood-passive-voice">are rejected</span>;
even though the resulting type will always be an integer there is no way to know
that statically ---the choice needs to be rewritten, evaluated at run time.

Indeed, in Haskell, we would write
<span class="org-code">if True then Left 1 else Right "two"</span> which has type <span class="org-code">Either Int String</span>,
and to use the resulting value means we need to pattern match or use
the eliminator <span class="org-code">(|||</span>) ---from Haskell's <span class="org-code">Control.Arrow</span>.

<span class="bold">Second:</span>
<span class="writegood-weasels">Some</span> statically typed languages have super weak type systems and ruin the rep
for everyone else.
For example, <span class="org-code">C</span> is great and we all love it of-course, but it's a shame that we can only
express the <span class="org-link">polymorphic</span> identity function<span class="org-latex-and-related"> $id : &#8704;{&#945;}. &#945; &#8594; &#945; \;=\; &#955; x &#8594; x$,</span>
by using the C-preprocessor ---or dismiss the types by casting pointers around.

Maybe this video is helpful, maybe not:
<span class="org-link"><a href="https://games.greggman.com/game/dynamic-typing-static-typing/">The Unreasonable Effectiveness of Dynamic Typing for Practical Programs</a></span>

<span class="org-block-begin-line">#+begin_quote org
</span><span class="org-block">  ( For the algebraist: Dynamic typing is like working in a monoid whose
  composition operation is partial and may abruptly crash; whereas static typing
  is working in a category whose composition is proudly typed. )
</span><span class="org-block-end-line">#+end_quote
</span>
Overall I haven't presented a good defence for being dynamically checked, but you
should ignore my blunder and consider trying Lisp yourself to see how awesome it is.

<span class="org-level-1">* With its hierarchy of types, why isn't Lisp statically typed?</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
<span class="org-block-begin-line">  #+begin_center org
</span><span class="org-block">  </span><span class="org-block"><span class="italic">I haven't a clue. Here are two conjectures.</span></span><span class="org-block">
</span><span class="org-block-end-line">  #+end_center
</span>
  <span class="bold">First</span>: Code that manipulates code is difficult to type.

  Is the type of <span class="org-code">'(+ x 2)</span> a numeric code expression?
  Or just an arbitrary code expression? Am I allowed to &#8220;look inside&#8221;
  to inspect its structure or is it a black box? What about the nature of
  its constituents? If I'm allowed to look at them, can I ask if they're even defined?

  What if <span class="org-code">c</span> is a code element that introduces an identifier, say <span class="org-code">it</span>.
  What is type of <span class="org-code">c</span>? What if it doesn't introduce and thus avoids accidentally
  capturing identifiers? Are we allowed only one form or both? Which do we select
  and why?

  I may be <span class="writegood-weasels">completely</span> wrong, but below I mention a <span class="org-link">bunch of papers</span> that suggest
  it's kind hard to type this stuff.

  <span class="bold">Second</span>: The type theory just wasn't in place at the time Lisp <span class="writegood-passive-voice">was created</span>.

  Here's a <span class="writegood-weasels">probably</span> wrong account of how it went down.

     + <span class="org-list-dt">1913ish ::</span> Bertrand Russel introduces a hierarchy of types to avoid barber trouble;
                  e.g., <span class="org-code">Type&#7522; : Type&#7522;&#8330;&#8321;</span>.
     + <span class="org-list-dt">1920s ::</span> A Polish guy &amp; British guy think that's dumb and collapse the hierarchy.
     + <span class="org-list-dt">1940s ::</span> Alonzo Church says arrows are cool.
     + <span class="org-list-dt">1958  ::</span> With his awesome hairdo, John McCarthy gifts the world an elegant
                piece of art: Lisp (&#8226;&#768;&#7447;&#8226;&#769;)&#1608;
       - Lisp is currently the 2&#8319;&#7496; oldest high-level language still
         in use after Fortran.
       - Maxwell's equations <span class="org-link"><a href="https://queue.acm.org/detail.cfm?id=1039523">get</a></span> <span class="org-link"><a href="http://www.michaelnielsen.org/ddi/lisp-as-the-maxwells-equations-of-software/">jealous</a></span>.

       Lisp introduces a bunch of zany ideas to CS:
       - Introduced if-then-else &#8220;McCarthy's Conditional&#8221;; 1&#738;&#7511; class functions &amp; recursion
       - macros &#8776; compiler plugins
       - symbols &#8776; raw names which needn't have values
       - variables &#8776; pointers
       - code &#8776; data; statements &#8776; expressions
       - <span class="org-code">read, eval, load, compile, print</span> are all functions!

     + <span class="org-list-dt">1959 ::</span> My man JM thinks manual memory is lame ---invents garbage collection!
       - Later, 2001, he writes <span class="org-link"><a href="https://web.archive.org/web/20130814213421/http://www-formal.stanford.edu/jmc/robotandbaby/robotandbaby.html">The Robot &amp; The Baby</a></span>.
     + <span class="org-list-dt">1960s ::</span> Simula says OOPs!
     + <span class="org-list-dt">1970s ::</span> Smalltalk popularises the phrase &#8220;oop&#8221;. ( B has a child named C. )
     + <span class="org-list-dt">1970s ::</span> <span class="writegood-weasels">Simple</span> &#955;-calculus is a fashion model for sets and functions.
     + <span class="org-list-dt">1970s ::</span> Milner and friends demand
                 <span class="italic">variables are for types too, not just terms!</span>
     + <span class="org-list-dt">1970s ::</span> Per Martin-Lo&#776;f tells us it's okay to depend on one another; <span class="org-code">&#928;, &#931;</span> types.
     + <span class="org-list-dt">1982  ::</span> A Lisp <span class="org-link"><a href="https://en.wikipedia.org/wiki/Ummah">ummah</a></span> <span class="writegood-passive-voice">is formed</span>: <span class="org-link"><a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node1.html">&#8220;Common Lisp the Language&#8221;</a></span> &#9829;&#8255;&#9829;
       - In order to be hip &amp; modern, it's got <span class="org-link"><a href="https://extravagaria.com/Files/LASC-Overview.pdf">class</a></span> with <span class="org-link"><a href="https://en.wikipedia.org/wiki/Common_Lisp_Object_System">CLOS</a></span>.
       - Other shenanigans: Scheme 1975, Elisp 1985, Racket 1995, Clojure 2007
     + <span class="org-list-dt">1984 ::</span> A script of sorcerous schemes lords lisp over mere mortals
     + <span class="org-list-dt">1990s ::</span> A committee makes a sexy <span class="org-link"><a href="https://en.wiktionary.org/wiki/a_camel_is_a_horse_designed_by_a_committee">camel</a></span> named Haskell; Professor X's school make their own camel.
       - Their kids get on steroids and fight to this day; Agda &#8623;&#8623;&#8623; Coq.
     + <span class="org-list-dt">2000s ::</span> X's camel .&lt;becomes .~(self .&lt;aware&gt;.)&gt;.
                ---the other camel [does| the same].
       + In 2015, the cam ls married Lisp and <span class="org-link"><a href="https://luxlang.gitbooks.io/the-lux-programming-language/content/">Lux</a></span> <span class="writegood-passive-voice">was born</span>.
       + In 2016, Haskell &amp; Lisp get involved with Prolog; <span class="org-link"><a href="https://shen-language.github.io/">Shen</a></span> <span class="writegood-passive-voice">is born</span>.

       2019: Coq is <span class="org-link"><a href="https://github.com/MetaCoq/metacoq">self-aware</a></span>; Agda is <span class="org-link"><a href="https://github.com/alhassy/gentle-intro-to-reflection">playing</a></span> <span class="org-link"><a href="https://alhassy.github.io/next-700-module-systems-proposal/prototype/PackageFormer.html">catch-up</a></span>.

  A more informative historical account of Lisp &amp; its universal reverence can <span class="writegood-passive-voice">be read</span> at:
  <span class="org-link"><a href="https://twobithistory.org/2018/10/14/lisp.html">How Lisp Became God's Own Programming Language</a></span>.
<span class="org-meta-line">  #+caption:</span> <span class="org-block">xkcd</span>
  <span class="org-link"><a href="https://imgs.xkcd.com/comics/lisp.jpg">https://imgs.xkcd.com/comics/lisp.jpg</a></span>

<span class="org-level-1">* Lisp Actually Admits Static Typing!</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
  Besides Common Lisp, &#8220;Typed Lisps&#8221; include <span class="org-link"><a href="https://github.com/clojure/core.typed">an optional type system for Clojure</a></span>
  ---see also <span class="org-link"><a href="https://circleci.com/blog/why-were-no-longer-using-core-typed/">Why we're no longer using Core.typed</a></span>---
  <span class="org-link"><a href="https://docs.racket-lang.org/ts-guide/">Typed Racket</a></span>, and, more recently, <span class="org-link"><a href="https://github.com/LuxLang/lux">Lux</a></span> &#8776; Haskell + ML + Lisp
  and  <span class="org-link"><a href="https://shen-language.github.io/">Shen</a></span> &#8776; Haskell + Prolog + Lisp.

  <span class="org-link"><a href="https://news.ycombinator.com/item?id=8593261">For example,</a></span> Common Lisp admits strong static typing, in <span class="org-link"><a href="http://www.lispforum.com/viewtopic.php?f=2&amp;t=191">SBCL</a></span>, as follows.
<span class="org-block-begin-line">#+BEGIN_SRC common-lisp
</span><span class="org-block">  </span><span class="org-block"><span class="comment">; Type declaration then definition.
</span></span><span class="org-block">  (</span><span class="org-block"><span class="keyword">declaim</span></span><span class="org-block"> (ftype (function (fixnum)) num-id))
  (</span><span class="org-block"><span class="keyword">defun</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">num-id</span></span><span class="org-block"> (n) n)

  (</span><span class="org-block"><span class="keyword">defun</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">string-id</span></span><span class="org-block"> (s) (</span><span class="org-block"><span class="keyword">declare</span></span><span class="org-block"> (string s)) (num-id s))
  </span><span class="org-block"><span class="comment">; in: DEFUN STRING-ID
</span></span><span class="org-block">  </span><span class="org-block"><span class="comment">;     (NUM-ID S)
</span></span><span class="org-block">  </span><span class="org-block"><span class="comment">;
</span></span><span class="org-block">  </span><span class="org-block"><span class="comment">; caught WARNING:
</span></span><span class="org-block">  </span><span class="org-block"><span class="comment">;   Derived type of S is
</span></span><span class="org-block">  </span><span class="org-block"><span class="comment">;     (VALUES STRING &amp;OPTIONAL),
</span></span><span class="org-block">  </span><span class="org-block"><span class="comment">;   conflicting with its asserted type
</span></span><span class="org-block">  </span><span class="org-block"><span class="comment">;     FIXNUM.
</span></span><span class="org-block-end-line">#+END_SRC
</span>
Such annotations <span class="writegood-weasels">mostly</span> serve as compiler optimisation annotations and,
unfortunately, Emacs Lisp <span class="org-link"><a href="https://www.gnu.org/software/emacs/manual/html_node/cl/Declarations.html">silently ignores Common Lisp declarations such as ftype</a></span>
---which provides <span class="org-link"><a href="http://www.lispworks.com/documentation/lw51/CLHS/Body/d_ftype.htm#ftype">function type</a></span> declarations.
However,
Emacs Lisp does provide a method of <span class="org-link"><a href="http://www.p-cos.net/documents/filtered-dispatch.pdf">dispatch</a></span> filtered by <span class="org-link"><a href="http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html">classes</a></span> rather than by
<span class="writegood-weasels">simple</span> types. <span class="writegood-weasels">Interestingly</span>, Lisp methods are more like Haskell typeclass constituents
or C# extensible methods
rather than like Java object methods ---in that, <span class="italic">Lisp methods specialise on classes</span>
whereas Java's approach is <span class="italic">classes have methods</span>.

Here's an example.
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="keyword">defmethod</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">doit</span></span><span class="org-block"> ((n integer)) </span><span class="org-block"><span class="doc">"I'm an integer!"</span></span><span class="org-block">)
(</span><span class="org-block"><span class="keyword">defmethod</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">doit</span></span><span class="org-block"> ((s </span><span class="org-block"><span class="highlight-defined-builtin-function-name">string</span></span><span class="org-block">)) </span><span class="org-block"><span class="doc">"I'm a string!"</span></span><span class="org-block">)
(</span><span class="org-block"><span class="keyword">defmethod</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">doit</span></span><span class="org-block"> ((type (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">eql</span></span><span class="org-block"> </span><span class="org-block"><span class="builtin">:hero</span></span><span class="org-block">)) thing) </span><span class="org-block"><span class="doc">"I'm a superhero!"</span></span><span class="org-block">)

(doit 2)             </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; I'm an integer!
</span></span><span class="org-block">(doit </span><span class="org-block"><span class="string">"2"</span></span><span class="org-block">)           </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; I'm a string!
</span></span><span class="org-block">(doit 'x)            </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; Error: No applicable method
</span></span><span class="org-block">(doit </span><span class="org-block"><span class="builtin">:hero</span></span><span class="org-block"> 'bobert) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; I'm a superhero!
</span></span><span class="org-block">
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">C-h o cl-defmethod &#8658; see extensible list of specialisers Elisp supports.
</span></span><span class="org-block-end-line">#+END_SRC
</span>
We can of-course make our own classes:
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="keyword">defclass</span></span><span class="org-block"> </span><span class="org-block"><span class="type">person</span></span><span class="org-block">  () ((name)))
(</span><span class="org-block"><span class="keyword">defmethod</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">speak</span></span><span class="org-block"> ((x person)) (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">format</span></span><span class="org-block"> </span><span class="org-block"><span class="string">"My name is %s."</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-function-name">slot-value</span></span><span class="org-block"> x 'name)))
(</span><span class="org-block"><span class="keyword">setq</span></span><span class="org-block"> p (</span><span class="org-block"><span class="highlight-defined-function-name">make-instance</span></span><span class="org-block"> 'person))
(</span><span class="org-block"><span class="keyword">setf</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-function-name">slot-value</span></span><span class="org-block"> p 'name) </span><span class="org-block"><span class="string">"bobert"</span></span><span class="org-block">)
(speak p) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; My name is bobert.
</span></span><span class="org-block">
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Inherits from &#8216;</span></span><span class="org-block"><span class="comment"><span class="constant">person</span></span></span><span class="org-block"><span class="comment">&#8217; and has accessor &amp; constructor methods for a new slot
</span></span><span class="org-block">(</span><span class="org-block"><span class="keyword">defclass</span></span><span class="org-block"> </span><span class="org-block"><span class="type">teacher</span></span><span class="org-block"> (person) ((topic </span><span class="org-block"><span class="builtin">:accessor</span></span><span class="org-block"> teacher-topic </span><span class="org-block"><span class="builtin">:initarg</span></span><span class="org-block"> </span><span class="org-block"><span class="builtin">:studying</span></span><span class="org-block">)))

(</span><span class="org-block"><span class="keyword">defmethod</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">speak</span></span><span class="org-block"> ((x teacher))
  (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">format</span></span><span class="org-block"> </span><span class="org-block"><span class="string">"My name is %s,and I study %s."</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-function-name">slot-value</span></span><span class="org-block"> x 'name) (teacher-topic x)))

(</span><span class="org-block"><span class="keyword">setq</span></span><span class="org-block"> ins (</span><span class="org-block"><span class="highlight-defined-function-name">make-instance</span></span><span class="org-block"> 'teacher </span><span class="org-block"><span class="builtin">:studying</span></span><span class="org-block"> </span><span class="org-block"><span class="string">"mathematics"</span></span><span class="org-block">))
(</span><span class="org-block"><span class="keyword">setf</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-function-name">slot-value</span></span><span class="org-block"> ins 'name) </span><span class="org-block"><span class="string">"Robert"</span></span><span class="org-block">)
(speak ins) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; My name is Robert, and I study mathematics.
</span></span><span class="org-block-end-line">#+END_SRC
</span>
Later in this article, we'll make something like the <span class="org-code">declaim</span> above
but have it be effectful at run-time. <span class="italic">Typing as Macros!</span>

<span class="org-block-begin-line">#+begin_quote org
</span><span class="org-block">(
If you happen to </span><span class="org-block"><span class="writegood-passive-voice"><span class="writegood-passive-voice">be interested</span></span></span><span class="org-block"> in looking under the hood to see what compiler generated
code looks like use </span><span class="org-block"><span class="org-code">disassemble</span></span><span class="org-block">. For example, declare </span><span class="org-block"><span class="org-code">(defun go (x) (+ 1 x) 'bye)</span></span><span class="org-block">
then invoke </span><span class="org-block"><span class="org-code">(disassemble 'go)</span></span><span class="org-block"> to see something like
</span><span class="org-block"><span class="org-code">varref x&#10814; add1&#10814; discard &#10814; constant bye&#10814; return</span></span><span class="org-block">.
)
</span><span class="org-block-end-line">#+end_quote
</span>
<span class="org-level-1">* ELisp's Type Hierarchy</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
&#8680; Each primitive type has a corresponding Lisp function that checks whether an object is a
  member of that type. Usually, these are the type name appended with <span class="org-code">-p</span>, for multi-word
  names, and <span class="org-code">p</span> for single word names. E.g., <span class="org-code">string</span> type has the predicate <span class="org-code">stringp</span>.

+ <span class="org-target"><span class="org-list-dt">&lt;&lt;&lt;Type Descriptor&gt;&gt;&gt;</span></span><span class="org-list-dt"> ::</span> Objects holding information about types.

     This is a <span class="org-code">record</span>; the <span class="org-code">type-of</span> function returns the first slot of records.

This section <span class="writegood-passive-voice">is based</span> <span class="org-link"><a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Lisp-Data-Types.html#Lisp-Data-Types">GNU Emacs Lisp Reference Manual</a></span>, &#167;2.3 &#8220;Programming Types&#8221;.

<span class="org-hide">*</span><span class="org-level-2">* Number</span>
<span class="org-drawer">   :PROPERTIES:...
</span><span class="italic">Numbers, including fractional and non-fractional types.</span>

             <span class="org-table">| </span><span class="org-table"><span class="org-code">integer</span></span><span class="org-table"> | </span><span class="org-table"><span class="org-code">float</span></span><span class="org-table"> | </span><span class="org-table"><span class="org-code">number</span></span><span class="org-table"> | </span><span class="org-table"><span class="org-code">natnum</span></span><span class="org-table"> | </span><span class="org-table"><span class="org-code">zero</span></span><span class="org-table"> | </span><span class="org-table"><span class="org-code">plus</span></span><span class="org-table"> | </span><span class="org-table"><span class="org-code">minus</span></span><span class="org-table"> | </span><span class="org-table"><span class="org-code">odd</span></span><span class="org-table"> | </span><span class="org-table"><span class="org-code">even</span></span><span class="org-table"> |</span>

The relationships between these types are as follows:
     <span class="org-table">| </span><span class="org-table"><span class="org-code">(numberp x) &#8776; (or (integerp x) (floatp x))</span></span><span class="org-table"> |</span>
     <span class="org-table">| </span><span class="org-table"><span class="org-code">(natnump x) &#8776; (and (integerp x) (&#8804; 0 x))</span></span><span class="org-table">   |</span>
     <span class="org-table">| </span><span class="org-table"><span class="org-code">(zerop   x) &#8776; (equal 0 x)</span></span><span class="org-table">                  |</span>
     <span class="org-table">| </span><span class="org-table"><span class="org-code">(plusp   x) &#8776; (&lt; 0 x)</span></span><span class="org-table">                      |</span>
     <span class="org-table">| </span><span class="org-table"><span class="org-code">(minusp  x) &#8776; (&gt; 0 x)</span></span><span class="org-table">                      |</span>
     <span class="org-table">| </span><span class="org-table"><span class="org-code">(evenp    x) &#8776; (zerop (mod x 2))</span></span><span class="org-table">           |</span>
     <span class="org-table">| </span><span class="org-table"><span class="org-code">(oddp     x) &#8776; (not (oddp x))</span></span><span class="org-table">              |</span>

+ <span class="bold">Integer</span>: Numbers without fractional parts.

   There is no overflow checking.
<span class="org-block-begin-line">   #+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">expt</span></span><span class="org-block"> 2 60) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; 1,152,921,504,606,846,976
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">expt</span></span><span class="org-block"> 2 61) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; -2,305,843,009,213,693,952
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">expt</span></span><span class="org-block"> 2 62) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; 0
</span></span><span class="org-block-end-line">#+END_SRC
</span>
  Numbers <span class="writegood-passive-voice">are written</span> with an optional sign &#8216;+&#8217; or &#8216;-&#8217; at the beginning and
    an optional period at the end.
    <span class="org-table">| </span><span class="org-table"><span class="org-code">-1 &#8776; -1.</span></span><span class="org-table"> | </span><span class="org-table"><span class="org-code">1 &#8776; +1 &#8776; 1.</span></span><span class="org-table"> |</span>

    They may also take <span class="italic">inclusive</span> (and exclusive) ranges:
    The type list <span class="org-code">(integer LOW HIGH)</span> represents all integers between
     <span class="org-code">LOW</span> and <span class="org-code">HIGH</span>, inclusive.  Either bound may be a list of a single
     integer to specify an exclusive limit, or a <span class="org-code">*</span> to specify no
     limit.  The type <span class="org-code">(integer * *)</span> is thus equivalent to <span class="org-code">integer</span>.
     Likewise, lists beginning with <span class="org-code">float</span>, <span class="org-code">real</span>, or <span class="org-code">number</span>
     represent numbers of that type falling in a particular range.
     ( <span class="org-link"><a href="https://www.gnu.org/software/emacs/manual/html_mono/cl.html#Predicates">The Emacs Common Lisp Documentation</a></span> )
<span class="comment">    # (integer low high) &#8776; (satisfies (lambda (n) (and (integerp n) (&lt;= low n high)))))</span>
<span class="org-block-begin-line">    #+BEGIN_SRC emacs-lisp
</span><span class="org-block">    (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 4 '(integer 1 5)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true since 1 &#8804; 4 &#8804; 5.
</span></span><span class="org-block">    (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 4 '(integer 1 3)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; nil  since 1 &#8804; 4 &#8816; 3.
</span></span><span class="org-block">
    (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 12 'integer) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">    (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 12 'number) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">
    (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 23 'odd)  </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">
    (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 12 '(integer </span><span class="org-block"><span class="highlight-defined-builtin-function-name">*</span></span><span class="org-block"> 14)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t, since 12 &#8804; 14, but no lower bound.
</span></span><span class="org-block">    (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 12 '(integer 0 </span><span class="org-block"><span class="highlight-defined-builtin-function-name">*</span></span><span class="org-block">)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t; the &#8216;*&#8217; denotes a wild-card; anything.
</span></span><span class="org-block">
   (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> -1 '(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">not</span></span><span class="org-block"> (integer 0 </span><span class="org-block"><span class="highlight-defined-builtin-function-name">*</span></span><span class="org-block">))) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">   (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block">  1 '(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">not</span></span><span class="org-block"> (integer 0 </span><span class="org-block"><span class="highlight-defined-builtin-function-name">*</span></span><span class="org-block">))) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; nil
</span></span><span class="org-block">
   (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 1 '(integer  1 2))   </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t, including lower bound
</span></span><span class="org-block">   (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 1 '(integer (1) 2))  </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; nil, excluding lower bound
</span></span><span class="org-block">
   (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 1.23 '(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">float</span></span><span class="org-block"> 1.20 1.24)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">
   </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Here's a slighly organised demonstration:
</span></span><span class="org-block">
   (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 1.23 'number) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">   (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 123  'number) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">   (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 1.23 'real) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">   (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 123  'real) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">
   (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 1.23 'integer) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; nil
</span></span><span class="org-block">   (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 123  'integer) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">   (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 1.23 'fixnum) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; nil
</span></span><span class="org-block">   (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 123  'fixnum) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">
   (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 1.23 '</span><span class="org-block"><span class="highlight-defined-builtin-function-name">float</span></span><span class="org-block">) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">   (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 123 '</span><span class="org-block"><span class="highlight-defined-builtin-function-name">float</span></span><span class="org-block">) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; nil
</span></span><span class="org-block">   (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 123.0 '</span><span class="org-block"><span class="highlight-defined-builtin-function-name">float</span></span><span class="org-block">) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block-end-line">#+END_SRC
</span>
+ <span class="bold">Floating-Point</span>: Numbers with fractional parts; expressible using scientific notation.
                      For example, <span class="org-code">15.0e+2 &#8776; 1500.0</span> and <span class="org-code">-1.0e+INF</span> for negative infinity.

+ <span class="bold">Aliases:</span>
    The type symbol <span class="org-code">real</span> is a synonym for <span class="org-code">number</span>, <span class="org-code">fixnum</span> is a
     synonym for <span class="org-code">integer</span>, and <span class="org-code">wholenum</span> is a synonym for <span class="org-code">natnum</span>.

+ The smallest and largest values <span class="italic">representable</span> in a Lisp integer are in the
  constants <span class="org-code">most-negative-fixnum</span> and <span class="org-code">most-postive-fixnum</span>

<span class="org-block-begin-line">  #+BEGIN_SRC emacs-lisp
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Relationship with infinities
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">&lt;</span></span><span class="org-block"> -1e+INF </span><span class="org-block"><span class="highlight-defined-variable-name">most-negative-fixnum</span></span><span class="org-block"> </span><span class="org-block"><span class="highlight-defined-variable-name">most-positive-fixnum</span></span><span class="org-block"> 1e+INF) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block-end-line">#+END_SRC
</span>
<span class="org-hide">*</span><span class="org-level-2">* Character</span>
<span class="org-drawer">   :PROPERTIES:...
</span><span class="italic">Representation of letters, numbers, and control characters.</span>

   A character is just a small integers, up to 22 bits;
   e.g., character <span class="org-code">A</span> <span class="writegood-passive-voice">is represented</span> as the integer 65.

   One writes the character &#8216;A&#8217; as <span class="org-code">?A</span>, which is identical to 65.
   Punctuations <span class="org-code">()[]\;"|'`#</span> must be \-escaped; e.g.,
   <span class="org-table">| </span><span class="org-table"><span class="org-code">?\( &#8776; 40</span></span><span class="org-table"> | </span><span class="org-table"><span class="org-code">?\\ &#8776; 92</span></span><span class="org-table"> |</span>
   Whereas <span class="org-code">?. &#8776; 46</span>.

<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">characterp</span></span><span class="org-block"> ?f) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">characterp</span></span><span class="org-block"> </span><span class="org-block"><span class="highlight-defined-variable-name">t</span></span><span class="org-block">)  </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; nil
</span></span><span class="org-block-end-line">#+END_SRC
</span>
   Emacs specfic characters control-g <span class="org-code">C-g</span>, backspace <span class="org-code">C-h</span>, tab <span class="org-code">C-i</span>, newline <span class="org-code">C-j</span>, space,
   return, del, and escape <span class="writegood-passive-voice">are expressed</span> by ?\a, ?\b, ?\t, ?\n, ?\s, ?\r, ?\d, ?\e.

   Generally, control characters can <span class="writegood-passive-voice">be expressed</span> as <span class="org-code">?\^&#120013; &#8776; ?\C-&#120013;</span>,
   and meta characters by <span class="org-code">?\M-&#120013;</span>; e.g., <span class="org-code">C-M-b</span> <span class="writegood-passive-voice">is expressed</span>
   <span class="org-code">?\M-\C-b &#8776; ?\C-\M-b</span>.

   Finally, <span class="org-code">?\S-&#120013;</span> denotes shifted-&#120013; characters.
   There are also <span class="org-code">?\H-&#120013;, ?\A-&#120013;, ?\s-&#120013;</span> to denote Hyper- Alt- or Super-modified keys;
   note that lower case &#8216;s&#8217; is for super whereas capital is for shift,
   and lower case with no dash is a space character.

<span class="org-hide">*</span><span class="org-level-2">* Symbol</span>
<span class="org-drawer">   :PROPERTIES:...
</span><span class="italic">A multi-use object that refers to functions and variables, and more.</span>

A symbol is an object with a name; different objects have different names.
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 'yes 'symbol) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">symbolp</span></span><span class="org-block"> 'yes)       </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">
(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 12   'symbol) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; false
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">symbolp</span></span><span class="org-block"> 12)         </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; false
</span></span><span class="org-block-end-line">#+END_SRC
</span>
<span class="org-table">| </span><span class="org-table"><span class="org-code">symbol</span></span><span class="org-table"> &#8776; Is it a symbol?            |</span>
<span class="org-table">| </span><span class="org-table"><span class="org-code">bound</span></span><span class="org-table">  &#8776; Does it refer to anything? |</span>

<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 'xyz 'bound) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; nil
</span></span><span class="org-block">
(</span><span class="org-block"><span class="keyword">setq</span></span><span class="org-block"> xyz 123)
(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 'xyz 'bound) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block-end-line">#+END_SRC
</span>See this short <span class="org-link"><a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Void-Variables.html#Void-Variables">docs</a></span> page for more info on when a variable is void.

<span class="underline">Names have a tremendously flexible syntax.</span>
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="keyword">setq</span></span><span class="org-block"> +*/-_~!</span><span class="org-block"><span class="warning">@$%^&amp;</span></span><span class="org-block">:&lt;&gt;{}? 23)
(</span><span class="org-block"><span class="keyword">setq</span></span><span class="org-block"> \+1            23) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Note +1 &#8776; 1, a number.
</span></span><span class="org-block">(</span><span class="org-block"><span class="keyword">setq</span></span><span class="org-block"> \12            23)
(</span><span class="org-block"><span class="keyword">setq</span></span><span class="org-block"> this\ is\ woah 23) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Escaping each space!
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">+</span></span><span class="org-block"> this\ is\ woah 1)     </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; 24
</span></span><span class="org-block-end-line">#+END_SRC
</span>
If the symbbol name starts with a colon &#8216;:&#8217;, it's called a keyword symbol
     and automatically acts as a constant.

<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> </span><span class="org-block"><span class="builtin">:hello</span></span><span class="org-block"> 'keyword) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block-end-line">#+END_SRC
</span>
Symbols generally act as names for variables and functions, however there are
<span class="writegood-weasels">some</span> names that have <span class="org-link"><a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Variables-with-Restricted-Values.html#Variables-with-Restricted-Values">fixed values</a></span> and any attempt to reset their values signals an error.
Most notably, these include <span class="org-code">t</span> for true or the top-most type,
<span class="org-code">nil</span> for false or the bottom-most type, and keywords.
These three evaluate to themselves.
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block"><span class="highlight-defined-variable-name">t</span></span><span class="org-block">      </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">nil    </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; nil
</span></span><span class="org-block"><span class="builtin">:hello</span></span><span class="org-block"> </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; :hello
</span></span><span class="org-block">
(</span><span class="org-block"><span class="keyword">setq</span></span><span class="org-block"> </span><span class="org-block"><span class="highlight-defined-variable-name">t</span></span><span class="org-block">   12) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; Error: Attempt to set a constant symbol
</span></span><span class="org-block">(</span><span class="org-block"><span class="keyword">setq</span></span><span class="org-block"> nil 12) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; Error: Attempt to set a constant symbol
</span></span><span class="org-block">(</span><span class="org-block"><span class="keyword">setq</span></span><span class="org-block"> </span><span class="org-block"><span class="builtin">:x</span></span><span class="org-block">  12) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; Error: Attempt to set a constant symbol
</span></span><span class="org-block">
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">:x &#8800; 'x
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">set</span></span><span class="org-block"> 'x 12) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; 12
</span></span><span class="org-block">x           </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; 12
</span></span><span class="org-block">
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">They're self-evaluating
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">equal</span></span><span class="org-block"> </span><span class="org-block"><span class="highlight-defined-variable-name">t</span></span><span class="org-block">   '</span><span class="org-block"><span class="highlight-defined-variable-name">t</span></span><span class="org-block">)   </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">equal</span></span><span class="org-block"> nil 'nil) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">equal</span></span><span class="org-block"> </span><span class="org-block"><span class="builtin">:x</span></span><span class="org-block">  '</span><span class="org-block"><span class="builtin">:x</span></span><span class="org-block">)  </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">
(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">equal</span></span><span class="org-block"> </span><span class="org-block"><span class="builtin">:x</span></span><span class="org-block"> 'x)  </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; nil
</span></span><span class="org-block-end-line">#+END_SRC
</span>
In particular, <span class="org-code">:x &#8800; 'x</span>!

<span class="org-hide">*</span><span class="org-level-2">* Sequence</span>
<span class="org-drawer">   :PROPERTIES:...
</span><span class="italic">The interface for ordered collections</span>; e.g.,
the <span class="org-code">(elt sequence index)</span> function can <span class="writegood-passive-voice">be applied</span> to any sequence
to extract an element at the given index.

<span class="org-block-begin-line">#+begin_center org
</span><span class="org-block"><span class="org-table">| </span></span><span class="org-block"><span class="org-table"><span class="org-code">sequence</span></span></span><span class="org-block"><span class="org-table"> | </span></span><span class="org-block"><span class="org-table"><span class="org-code">seq</span></span></span><span class="org-block"><span class="org-table">  |</span></span><span class="org-block">
</span><span class="org-block-end-line">#+end_center
</span>
The latter is an extensible variant of the former
---for when we declare our own sequential data types.

<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> '(1 2 3) 'sequence) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block-end-line">#+END_SRC
</span>
There are two immediate subtypes: <span class="org-code">array</span> and <span class="org-code">cons</span>, the latter has <span class="org-code">list</span>
as a subtype.

<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block">  [1 2 3] 'array)       </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> '(1 2 3) '</span><span class="org-block"><span class="highlight-defined-builtin-function-name">cons</span></span><span class="org-block">)        </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> '(1 </span><span class="org-block"><span class="string">"2"</span></span><span class="org-block"> 'three) '</span><span class="org-block"><span class="highlight-defined-builtin-function-name">list</span></span><span class="org-block">) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block-end-line">#+END_SRC
</span>
  - <span class="org-list-dt">Array ::</span> Arrays include strings and vectors.
    * <span class="org-list-dt">Vector ::</span> One-dimensional arrays.
    * <span class="org-list-dt">Char-Table ::</span> One-dimensional sparse arrays indexed by characters.
    * <span class="org-list-dt">Bool-Vector ::</span> One-dimensional arrays of <span class="org-code">t</span> or <span class="org-code">nil</span>.
    * <span class="org-list-dt">Hash Table ::</span> Super-fast lookup tables.

<span class="org-block-begin-line">    #+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> </span><span class="org-block"><span class="string">"hi"</span></span><span class="org-block"> '</span><span class="org-block"><span class="highlight-defined-builtin-function-name">string</span></span><span class="org-block">) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 'hi  '</span><span class="org-block"><span class="highlight-defined-builtin-function-name">string</span></span><span class="org-block">) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; false
</span></span><span class="org-block-end-line">#+END_SRC
</span>
  - <span class="org-list-dt">Cons cell type ::</span> Cons cells and lists, which are chains of cons cells.

    These are objects consisting of two Lisp objects, called <span class="org-code">car</span> and <span class="org-code">cdr</span>.
    That is they are pairs of Lisp objects.

<span class="org-block-begin-line">    #+BEGIN_SRC math
</span>      '(x&#8320; x&#8321; x&#8322;)
    &#8776; '(x&#8320; . (x&#8321; . (x&#8322; . nil)))
    &#8800; '(x&#8320; x&#8321; . x&#8322;)
    &#8776; '(x&#8320; . (x&#8321; . x&#8322;))
<span class="org-block-end-line">#+END_SRC
</span>
    Notice that when there is no &#8216;.&#8217;, then a list
    is just a nested cons chain ending in &#8216;nil&#8217;.
    Note that <span class="org-code">'(x&#8320; . x&#8321; . x&#8322;)</span> is meaningless.

    Cons cells are central to Lisp and so objects which are not a cons
    cell <span class="writegood-passive-voice">are called</span> <span class="italic">atoms</span>.

<span class="org-block-begin-line">     #+BEGIN_SRC emacs-lisp
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">An atom is not a cons.
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 123 '</span><span class="org-block"><span class="highlight-defined-builtin-function-name">atom</span></span><span class="org-block">) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 'ni '</span><span class="org-block"><span class="highlight-defined-builtin-function-name">atom</span></span><span class="org-block">) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block-end-line">#+END_SRC
</span>
    Computationally:
    <span class="org-table">|   | </span><span class="org-table"><span class="org-code">(atom x)</span></span><span class="org-table">              |</span>
    <span class="org-table">| &#8776; | </span><span class="org-table"><span class="org-code">(typep x 'atom)</span></span><span class="org-table">       |</span>
    <span class="org-table">| &#8776; | </span><span class="org-table"><span class="org-code">(not (consp x))</span></span><span class="org-table">       |</span>
    <span class="org-table">| &#8776; | </span><span class="org-table"><span class="org-code">(not (typep x 'cons))</span></span><span class="org-table"> |</span>
    <span class="org-table">| &#8776; | </span><span class="org-table"><span class="org-code">(typep x '(not cons))</span></span><span class="org-table"> |</span>

    <span class="writegood-weasels">Interestingly</span>, one writes <span class="org-code">atom</span>, not <span class="org-code">atomp</span>.

<span class="org-hide">*</span><span class="org-level-2">* Function</span>
<span class="org-drawer">   :PROPERTIES:...
</span><span class="italic">Piece of executable code.</span>

  A non-compiled function in Lisp is a lambda expression: A list whose
  first element is the symbol <span class="org-code">lambda</span>.

<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">consp</span></span><span class="org-block">     (</span><span class="org-block"><span class="keyword">lambda</span></span><span class="org-block"> (x) x))        </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">functionp</span></span><span class="org-block"> (</span><span class="org-block"><span class="keyword">lambda</span></span><span class="org-block"> (x) x))        </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">
(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">functionp</span></span><span class="org-block"> (</span><span class="org-block"><span class="keyword">lambda</span></span><span class="org-block"> is </span><span class="org-block"><span class="highlight-defined-macro-name">the</span></span><span class="org-block"> </span><span class="org-block"><span class="highlight-defined-builtin-function-name">first</span></span><span class="org-block">)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> (</span><span class="org-block"><span class="keyword">lambda</span></span><span class="org-block"> stuff) '</span><span class="org-block"><span class="highlight-defined-special-form-name">function</span></span><span class="org-block">)  </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block-end-line">#+END_SRC
</span>
It may help to know that a <span class="org-code">defun</span> just produces an alias for a function:
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">  (</span><span class="org-block"><span class="keyword">defun</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">name</span></span><span class="org-block"> (args) </span><span class="org-block"><span class="doc">"docs"</span></span><span class="org-block"> body)
&#8776; (</span><span class="org-block"><span class="keyword">defalias</span></span><span class="org-block"> (</span><span class="org-block"><span class="keyword">quote</span></span><span class="org-block"> name) (</span><span class="org-block"><span class="keyword">function</span></span><span class="org-block"> (</span><span class="org-block"><span class="keyword">lambda</span></span><span class="org-block"> (args) docs body)))
</span><span class="org-block-end-line">#+END_SRC
</span>
Here's <span class="writegood-weasels">some</span> more examples.
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> #'</span><span class="org-block"><span class="highlight-defined-builtin-function-name">+</span></span><span class="org-block">   '</span><span class="org-block"><span class="highlight-defined-special-form-name">function</span></span><span class="org-block">) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> 'nice '</span><span class="org-block"><span class="highlight-defined-special-form-name">function</span></span><span class="org-block">) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; false
</span></span><span class="org-block">
(</span><span class="org-block"><span class="keyword">defun</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">it</span></span><span class="org-block"> (x) (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">format</span></span><span class="org-block"> </span><span class="org-block"><span class="string">"%s"</span></span><span class="org-block"> (+1 x)))
(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> #'it   '</span><span class="org-block"><span class="highlight-defined-special-form-name">function</span></span><span class="org-block">) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">functionp</span></span><span class="org-block"> #'it)         </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block-end-line">#+END_SRC
</span>
<span class="org-hide">*</span><span class="org-level-2">* Macro</span>
<span class="org-drawer">   :PROPERTIES:...
</span><span class="italic">A method of expanding an expression into another expression.</span>

  Like functions, any list that begins with <span class="org-code">macro</span>, and whose <span class="org-code">cdr</span>
  is a function, <span class="writegood-passive-voice">is considered</span> a macro as long as Emacs Lisp <span class="writegood-passive-voice">is concerned</span>.

<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-function-name">macrop</span></span><span class="org-block"> '(macro (</span><span class="org-block"><span class="keyword">lambda</span></span><span class="org-block"> (x) x))) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block-end-line">#+END_SRC
</span>
Since <span class="org-code">defmacro</span> produces an alias, as follows,
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">  (</span><span class="org-block"><span class="keyword">defmacro</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">name</span></span><span class="org-block"> (args) </span><span class="org-block"><span class="doc">"docs"</span></span><span class="org-block"> body)
&#8776; (</span><span class="org-block"><span class="keyword">defalias</span></span><span class="org-block"> (</span><span class="org-block"><span class="keyword">quote</span></span><span class="org-block"> name) (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">cons</span></span><span class="org-block"> (</span><span class="org-block"><span class="keyword">quote</span></span><span class="org-block"> macro) (</span><span class="org-block"><span class="keyword">function</span></span><span class="org-block"> (</span><span class="org-block"><span class="keyword">lambda</span></span><span class="org-block"> (args) docs body))))
</span><span class="org-block-end-line">#+END_SRC
</span>
You may <span class="writegood-passive-voice">be concerned</span> that <span class="org-code">(macrop x) &#8799; (equal 'macro (car x))</span>, and so if a user
gives you a macro you might think its a cons cell of data.
Fortunately this is not the case:
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="keyword">defmacro</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">no-op</span></span><span class="org-block"> () )

(</span><span class="org-block"><span class="highlight-defined-function-name">macrop</span></span><span class="org-block"> #'no-op)    </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; true
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">consp</span></span><span class="org-block">  #'no-op)    </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; false; whence it's also not a list.
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">functionp</span></span><span class="org-block"> #'no-op) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; false
</span></span><span class="org-block">
(</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> #'no-op '
       (satisfies (</span><span class="org-block"><span class="keyword">lambda</span></span><span class="org-block"> (x) (</span><span class="org-block"><span class="keyword">and</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">listp</span></span><span class="org-block"> x) (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">equal</span></span><span class="org-block"> 'macro (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">car</span></span><span class="org-block"> x)))))) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; false
</span></span><span class="org-block-end-line">#+END_SRC
</span>
Why not? Well, you could think of a macro as a &#8216;record&#8217; whose label is <span class="org-code">macro</span> and
its only element is the associated function.

<span class="org-hide">*</span><span class="org-level-2">* Record</span>
<span class="org-drawer">   :PROPERTIES:...
</span><span class="italic">Compound objects with programmer-defined types.</span>

They are the underlying representation of <span class="org-code">defstruct</span> and <span class="org-code">defclass</span> instances.

For example:
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="keyword">defstruct</span></span><span class="org-block"> person
  name age)
</span><span class="org-block-end-line">#+END_SRC
</span>
The <span class="org-code">type-of</span> operator yields the <span class="org-code">car</span> of instances of such declartions.
<span class="org-table">| </span><span class="org-table"><span class="org-code">(record &#964; e&#8320; &#8230; e&#8345;) &#8776; #s(&#964; e&#8320; &#8230; e&#8345;)</span></span><span class="org-table"> |</span>

<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="keyword">setq</span></span><span class="org-block"> bobert (make-person </span><span class="org-block"><span class="builtin">:name</span></span><span class="org-block"> </span><span class="org-block"><span class="string">"bobby"</span></span><span class="org-block"> </span><span class="org-block"><span class="builtin">:age</span></span><span class="org-block"> 'too-much))
(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">type-of</span></span><span class="org-block"> bobert) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; person
</span></span><span class="org-block-end-line">#+END_SRC
</span>
Componenets may <span class="writegood-passive-voice">be indexed</span> with <span class="org-code">aref</span>.
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">aref</span></span><span class="org-block"> bobert 1)      </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; bobby
</span></span><span class="org-block">(person-name bobert) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; bobby
</span></span><span class="org-block-end-line">#+END_SRC
</span>
A record <span class="writegood-passive-voice">is considered</span> a constant for evaulation: Evaluating it yields itself.
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">type-of</span></span><span class="org-block"> #s(person </span><span class="org-block"><span class="string">"mark"</span></span><span class="org-block"> twelve)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; person
</span></span><span class="org-block">(</span><span class="org-block"><span class="highlight-defined-builtin-function-name">recordp</span></span><span class="org-block"> #s(nice))                 </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; t
</span></span><span class="org-block-end-line">#+END_SRC
</span>
<span class="org-level-1">* Typing via Macros &amp; Advice</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
Checking the type of inputs is tedious and so I <span class="org-link"><a href="https://www.reddit.com/r/emacs/comments/cct5hp/functional_type_declarations_in_elisp/">guessed</a></span> it could <span class="writegood-passive-voice">be done</span> using
macros and advice. Looking at <span class="org-link"><a href="https://docs.racket-lang.org/ts-guide/types.html">Typed Racket</a></span> for inspiration, the following
fictitious syntax would add advice to <span class="org-code">f</span> that checks the optional arguments <span class="org-code">x&#7522;</span>
have type <span class="org-code">&#963;&#7522;</span> and the mandatory positional arguments have type <span class="org-code">&#964;&#7522;</span> according
to position, and the result of the computation is of type <span class="org-code">&#964;</span>.
To the best of my knowledge, no one had done this for Emacs Lisp ---I don't know why.
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block">(declare-type 'f ((</span><span class="org-block"><span class="builtin">:x&#8321;</span></span><span class="org-block"> &#963;&#8321;) &#8230; (</span><span class="org-block"><span class="builtin">:x&#8344;</span></span><span class="org-block"> &#963;&#8344;)) (&#964;&#8321; &#8230; &#964;&#8345; &#964;))
</span><span class="org-block-end-line">#+END_SRC
</span>
To modify a variable, or function, we may <span class="writegood-weasels">simply</span> redefine it; but a much more elegant and powerful
approach is to <span class="org-link"><a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Advising-Functions.html">&#8220;advise&#8221;</a></span> the current entity with <span class="writegood-weasels">some</span> new behaviour. In our case of interest, we will
<span class="italic">advise functions to check their arguments before executing their bodies</span>.

Below is my attempt: <span class="org-target">&lt;&lt;&lt;~declare-type~&gt;&gt;&gt;</span>. Before you get scared or think it's horrendous, be charitable and
note that about a third of the following is documentation and a third is local declarations.
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp :tangle yes
</span><span class="org-block">(</span><span class="org-block"><span class="keyword">cl-defmacro</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">declare-type</span></span><span class="org-block"> (f key-types </span><span class="org-block"><span class="type">&amp;rest</span></span><span class="org-block"> types)
  </span><span class="org-block"><span class="doc">"Attach the given list of types to the function &#8216;f&#8217;
   by advising the function to check its arguments&#8217; types
   are equal to the list of given types.

   We name the advice &#8216;&#10218;f&#10219;-typing-advice&#8217; so that further
   invocations to this macro overwrite the same advice function
   rather than introducing additional, unintended, constraints.

   Using type specifiers we accommodate for unions of types
   and subtypes, etc &#9829;&#8255;&#9829;.

   &#8216;</span></span><span class="org-block"><span class="doc"><span class="constant">key-types</span></span></span><span class="org-block"><span class="doc">&#8217; should be of the shape (:x&#8320; t&#8320; &#8943; :x&#8345; t&#8345;);
    when there are no optional types, use symbol &#8220;:&#8221;.

    E.g., (declare-type my-func (:z string :w integer) integer symbol string)
  "</span></span><span class="org-block">

  </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Basic coherency checks. When there aren't optional types, key-types is the &#8220;:&#8221; symbol.
</span></span><span class="org-block">  (should (</span><span class="org-block"><span class="keyword">and</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">listp</span></span><span class="org-block"> types) (</span><span class="org-block"><span class="keyword">or</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">listp</span></span><span class="org-block"> key-types) (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">symbolp</span></span><span class="org-block"> key-types))))

  (</span><span class="org-block"><span class="keyword">letf*</span></span><span class="org-block"> ((pairify (</span><span class="org-block"><span class="keyword">lambda</span></span><span class="org-block"> (xs) (</span><span class="org-block"><span class="keyword">loop</span></span><span class="org-block"> for i in xs by #'</span><span class="org-block"><span class="highlight-defined-function-name">cddr</span></span><span class="org-block">         </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Turn a list of flattenned pairs
</span></span><span class="org-block">                                      for j in (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">cdr</span></span><span class="org-block"> xs) by #'</span><span class="org-block"><span class="highlight-defined-function-name">cddr</span></span><span class="org-block">   </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">into a list of explicit pairs.
</span></span><span class="org-block">                                      collect (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">cons</span></span><span class="org-block"> i j))))         </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block">MA</span><span class="org-block"><span class="comment">: No Lisp method for this!?
</span></span><span class="org-block">         (result-type  (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">car</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-function-name">-take-last</span></span><span class="org-block"> 1 types)))
         (types        (</span><span class="org-block"><span class="highlight-defined-function-name">-drop-last</span></span><span class="org-block"> 1 types))
         (num-of-types (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">length</span></span><span class="org-block"> types))
         (key-types-og (</span><span class="org-block"><span class="keyword">unless</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">symbolp</span></span><span class="org-block"> key-types) key-types))
         (key-types    (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">funcall</span></span><span class="org-block"> pairify key-types-og))
         (advice-name  (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">intern</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">format</span></span><span class="org-block"> </span><span class="org-block"><span class="string">"%s-typing-advice"</span></span><span class="org-block"> f)))
         (notify-user  (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">format</span></span><span class="org-block"> </span><span class="org-block"><span class="string">"%s now typed %s &#8594; %s &#8594; %s."</span></span><span class="org-block">
                               `,f key-types-og types result-type)))

      `(</span><span class="org-block"><span class="keyword">progn</span></span><span class="org-block">
         (</span><span class="org-block"><span class="keyword">defun</span></span><span class="org-block"> ,advice-name (orig-fun </span><span class="org-block"><span class="type">&amp;rest</span></span><span class="org-block"> args)

           </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Split into positional and key args; optionals not yet considered.
</span></span><span class="org-block">           (</span><span class="org-block"><span class="keyword">letf*</span></span><span class="org-block"> ((all-args
                     (</span><span class="org-block"><span class="highlight-defined-function-name">-split-at</span></span><span class="org-block">
                       (</span><span class="org-block"><span class="keyword">or</span></span><span class="org-block"> (</span><span class="org-block"><span class="keyword">--find-index</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">not</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-function-name">s-blank?</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-function-name">s-shared-start</span></span><span class="org-block"> </span><span class="org-block"><span class="string">":"</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">format</span></span><span class="org-block"> </span><span class="org-block"><span class="string">"%s"</span></span><span class="org-block"> it)))) args) ,num-of-types)
                        args)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">The &#8220;or&#8221; is for when there are no keywords provided.
</span></span><span class="org-block">                  (pos-args  (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">car</span></span><span class="org-block"> all-args))
                  (key-args  (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">funcall</span></span><span class="org-block"> ,pairify (</span><span class="org-block"><span class="highlight-defined-function-name">cadr</span></span><span class="org-block"> all-args)))
                  (fun-result nil)
                  ((</span><span class="org-block"><span class="highlight-defined-builtin-function-name">symbol-function</span></span><span class="org-block"> 'shucks)
                     (</span><span class="org-block"><span class="keyword">lambda</span></span><span class="org-block"> (e&#964; e g)
                       (</span><span class="org-block"><span class="keyword">unless</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-function-name">typep</span></span><span class="org-block"> g e&#964;)
                         (</span><span class="org-block"><span class="warning">error</span></span><span class="org-block"> </span><span class="org-block"><span class="string">"%s: Type mismatch! Expected </span></span><span class="org-block"><span class="string"><span class="writegood-duplicates">%s %s</span></span></span><span class="org-block"><span class="string"> &#8800; Given </span></span><span class="org-block"><span class="string"><span class="writegood-duplicates">%s %s</span></span></span><span class="org-block"><span class="string">."</span></span><span class="org-block">
                                (</span><span class="org-block"><span class="keyword">function</span></span><span class="org-block"> ,f) e&#964; e (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">type-of</span></span><span class="org-block"> g) (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">prin1-to-string</span></span><span class="org-block"> g))))))

         </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Check the types of positional arguments.
</span></span><span class="org-block">         (</span><span class="org-block"><span class="keyword">unless</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">equal</span></span><span class="org-block"> ,num-of-types (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">length</span></span><span class="org-block"> pos-args))
           (</span><span class="org-block"><span class="warning">error</span></span><span class="org-block"> </span><span class="org-block"><span class="string">"%s: Insufficient number of arguments; given %s, %s, but %s </span></span><span class="org-block"><span class="string"><span class="writegood-passive-voice">are needed</span></span></span><span class="org-block"><span class="string">."</span></span><span class="org-block">
                  (</span><span class="org-block"><span class="keyword">function</span></span><span class="org-block"> ,f) (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">length</span></span><span class="org-block"> pos-args) pos-args ,num-of-types))
         (</span><span class="org-block"><span class="keyword">loop</span></span><span class="org-block"> for (ar ty pos) in (</span><span class="org-block"><span class="highlight-defined-function-name">-zip</span></span><span class="org-block"> pos-args (</span><span class="org-block"><span class="keyword">quote</span></span><span class="org-block"> ,types) (</span><span class="org-block"><span class="highlight-defined-function-name">number-sequence</span></span><span class="org-block"> 0 ,num-of-types))
               </span><span class="org-block"><span class="highlight-defined-macro-name">do</span></span><span class="org-block"> (shucks ty (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">format</span></span><span class="org-block"> </span><span class="org-block"><span class="string">"for argument %s"</span></span><span class="org-block"> pos) ar))

         </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Check the types of *present* keys.
</span></span><span class="org-block">         (</span><span class="org-block"><span class="keyword">loop</span></span><span class="org-block"> for (k . v) in key-args
               </span><span class="org-block"><span class="highlight-defined-macro-name">do</span></span><span class="org-block"> (shucks (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">cdr</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">assoc</span></span><span class="org-block"> k (</span><span class="org-block"><span class="keyword">quote</span></span><span class="org-block"> ,key-types))) k v))

         </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Actually execute the orginal function on the provided arguments.
</span></span><span class="org-block">         (</span><span class="org-block"><span class="keyword">setq</span></span><span class="org-block"> fun-result (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">apply</span></span><span class="org-block"> orig-fun args))
         (shucks (</span><span class="org-block"><span class="keyword">quote</span></span><span class="org-block"> ,result-type) </span><span class="org-block"><span class="string">"for the result type (!)"</span></span><span class="org-block"> fun-result)

         </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Return-value should </span></span><span class="org-block"><span class="comment"><span class="writegood-passive-voice">be given</span></span></span><span class="org-block"><span class="comment"> to caller.
</span></span><span class="org-block">         fun-result))

      </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">Register the typing advice and notify user of what </span></span><span class="org-block"><span class="comment"><span class="writegood-passive-voice">was added</span></span></span><span class="org-block"><span class="comment">.
</span></span><span class="org-block">      (</span><span class="org-block"><span class="highlight-defined-function-name">advice-add</span></span><span class="org-block"> (</span><span class="org-block"><span class="keyword">function</span></span><span class="org-block"> ,f) </span><span class="org-block"><span class="builtin">:around</span></span><span class="org-block"> (</span><span class="org-block"><span class="keyword">function</span></span><span class="org-block"> ,advice-name))
      ,notify-user )))
</span><span class="org-block-end-line">#+END_SRC
</span>
<span class="org-meta-line">#+RESULTS:</span>
<span class="org-code">: declare-type
</span>
There are <span class="writegood-weasels">some</span> notable shortcomings: Lack of support for type variables and, for now, no support for
optional arguments. Nonetheless, I like it ---of course.
( Using <span class="org-link"><a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Watching-Variables.html#Watching-Variables">variable watchers</a></span> we could likely add support for type variables as well as
function-types. )

<span class="org-drawer">:Hide:...
</span>
<span class="bold">We accidentally forgot to consider an argument.</span>
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp :tangle yes
</span><span class="org-block">(declare-type f&#8321; (</span><span class="org-block"><span class="builtin">:z</span></span><span class="org-block"> </span><span class="org-block"><span class="highlight-defined-builtin-function-name">string</span></span><span class="org-block"> </span><span class="org-block"><span class="builtin">:w</span></span><span class="org-block"> </span><span class="org-block"><span class="highlight-defined-builtin-function-name">list</span></span><span class="org-block">) integer symbol </span><span class="org-block"><span class="highlight-defined-builtin-function-name">string</span></span><span class="org-block">)
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; f&#8321; now typed (:z string :w integer) &#8594; (integer symbol) &#8594; string.
</span></span><span class="org-block">
(</span><span class="org-block"><span class="keyword">cl-defun</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">f&#8321;</span></span><span class="org-block"> (x y </span><span class="org-block"><span class="type">&amp;key</span></span><span class="org-block"> z w) (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">format</span></span><span class="org-block"> </span><span class="org-block"><span class="string">"%s"</span></span><span class="org-block"> x))
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; f&#8321; now defined
</span></span><span class="org-block">
(f&#8321; 'x) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; f&#8321;: Insufficient number of arguments; given 2, (x), but 3 </span></span><span class="org-block"><span class="comment"><span class="writegood-passive-voice">are needed</span></span></span><span class="org-block"><span class="comment">.
</span></span><span class="org-block-end-line">#+END_SRC
</span>The type declaration said we needed 3 arguments, but we did not consider one of them.

<span class="bold">We accidentally returned the wrong value.</span>
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp :tangle yes
</span><span class="org-block">(declare-type f&#8322; (</span><span class="org-block"><span class="builtin">:z</span></span><span class="org-block"> </span><span class="org-block"><span class="highlight-defined-builtin-function-name">string</span></span><span class="org-block"> </span><span class="org-block"><span class="builtin">:w</span></span><span class="org-block"> </span><span class="org-block"><span class="highlight-defined-builtin-function-name">list</span></span><span class="org-block">) integer symbol </span><span class="org-block"><span class="highlight-defined-builtin-function-name">string</span></span><span class="org-block">)
(</span><span class="org-block"><span class="keyword">cl-defun</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">f&#8322;</span></span><span class="org-block"> (x y </span><span class="org-block"><span class="type">&amp;key</span></span><span class="org-block"> z w) x)

(f&#8322; 144 'two)
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; f&#8322;: Type mismatch! Expected string for the result type (!) &#8800; Given integer 144.
</span></span><span class="org-block-end-line">#+END_SRC
</span>
<span class="bold">We accidentally forgot to supply an argument.</span>
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp :tangle yes
</span><span class="org-block">(declare-type f&#8323; (</span><span class="org-block"><span class="builtin">:z</span></span><span class="org-block"> </span><span class="org-block"><span class="highlight-defined-builtin-function-name">string</span></span><span class="org-block"> </span><span class="org-block"><span class="builtin">:w</span></span><span class="org-block"> </span><span class="org-block"><span class="highlight-defined-builtin-function-name">list</span></span><span class="org-block">) integer symbol </span><span class="org-block"><span class="highlight-defined-builtin-function-name">string</span></span><span class="org-block">)
(</span><span class="org-block"><span class="keyword">cl-defun</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">f&#8323;</span></span><span class="org-block"> (x y </span><span class="org-block"><span class="type">&amp;key</span></span><span class="org-block"> z w) (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">format</span></span><span class="org-block"> </span><span class="org-block"><span class="string">"%s"</span></span><span class="org-block"> x))

(f&#8323; 144)
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; f&#8323;: Insufficient number of arguments; given 1, (144), but 2 </span></span><span class="org-block"><span class="comment"><span class="writegood-passive-voice">are needed</span></span></span><span class="org-block"><span class="comment">.
</span></span><span class="org-block-end-line">#+END_SRC
</span>
<span class="bold">A positional argument </span><span class="bold"><span class="writegood-passive-voice">is supplied</span></span><span class="bold"> of the wrong type.</span>
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp :tangle yes
</span><span class="org-block">(f&#8323; 'one </span><span class="org-block"><span class="string">"two"</span></span><span class="org-block">)
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658;  f&#8323;: Type mismatch! Expected integer for argument 0 &#8800; Given symbol one.
</span></span><span class="org-block">
(f&#8323; 144 </span><span class="org-block"><span class="string">"two"</span></span><span class="org-block">)
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; f&#8323;: Type mismatch! Expected symbol for argument 1 &#8800; Given string "two".
</span></span><span class="org-block-end-line">#+END_SRC
</span>Notice: When multiple positional arguments have type-errors, the errors <span class="writegood-passive-voice">are reported</span> one at a time.

<span class="bold">A keyword argument </span><span class="bold"><span class="writegood-passive-voice">is supplied</span></span><span class="bold"> of the wrong type.</span>
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp :tangle yes
</span><span class="org-block">(f&#8323; 1 'two </span><span class="org-block"><span class="builtin">:z</span></span><span class="org-block"> 'no&#8320; </span><span class="org-block"><span class="builtin">:w</span></span><span class="org-block"> 'no&#8321;)
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; f&#8323;: Type mismatch! Expected string :z &#8800; Given symbol no&#8320;.
</span></span><span class="org-block">
(f&#8323; 1 'two </span><span class="org-block"><span class="builtin">:z</span></span><span class="org-block"> </span><span class="org-block"><span class="string">"ok"</span></span><span class="org-block"> </span><span class="org-block"><span class="builtin">:w</span></span><span class="org-block"> 'no&#8321;)
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; f&#8323;: Type mismatch! Expected string :w &#8800; Given symbol no&#8321;.
</span></span><span class="org-block">
(f&#8323; 1 'two </span><span class="org-block"><span class="builtin">:z</span></span><span class="org-block"> </span><span class="org-block"><span class="string">"ok"</span></span><span class="org-block"> </span><span class="org-block"><span class="builtin">:w</span></span><span class="org-block"> 23)
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; f&#8323;: Type mismatch! Expected string :w &#8800; Given integer 23.
</span></span><span class="org-block">
(f&#8323; 1 'two </span><span class="org-block"><span class="builtin">:z</span></span><span class="org-block"> </span><span class="org-block"><span class="string">"ok"</span></span><span class="org-block"> </span><span class="org-block"><span class="builtin">:w</span></span><span class="org-block"> '(a b 1 2)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; okay; no type-error.
</span></span><span class="org-block-end-line">#+END_SRC
</span>
<span class="bold">We have no optional arguments.</span>
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp :tangle yes
</span><span class="org-block">(declare-type f&#8324; : integer symbol </span><span class="org-block"><span class="highlight-defined-builtin-function-name">string</span></span><span class="org-block">)
(</span><span class="org-block"><span class="keyword">cl-defun</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">f&#8324;</span></span><span class="org-block"> (x y </span><span class="org-block"><span class="type">&amp;key</span></span><span class="org-block"> z w) (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">format</span></span><span class="org-block"> </span><span class="org-block"><span class="string">"%s"</span></span><span class="org-block"> x))

(f&#8324; 144 'two </span><span class="org-block"><span class="builtin">:z</span></span><span class="org-block"> </span><span class="org-block"><span class="string">"bye"</span></span><span class="org-block">)
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658;  f&#8324;: Type mismatch! Expected nil :z &#8800; Given string "bye".
</span></span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">( We shouldn't have any keyword :z according to the type declaration! )
</span></span><span class="org-block">
(f&#8324; 144 'two) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; "144"
</span></span><span class="org-block-end-line">#+END_SRC
</span>
<span class="bold">We can incorporate type specfiers such as unions!</span>
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp :tangle yes
</span><span class="org-block">(declare-type f&#8325; : (</span><span class="org-block"><span class="keyword">or</span></span><span class="org-block"> integer </span><span class="org-block"><span class="highlight-defined-builtin-function-name">string</span></span><span class="org-block">) </span><span class="org-block"><span class="highlight-defined-builtin-function-name">string</span></span><span class="org-block">)
(</span><span class="org-block"><span class="keyword">cl-defun</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">f&#8325;</span></span><span class="org-block"> (x) (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">format</span></span><span class="org-block"> </span><span class="org-block"><span class="string">"%s"</span></span><span class="org-block"> x))

(f&#8325; 144)     </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; "144"
</span></span><span class="org-block">(f&#8325; </span><span class="org-block"><span class="string">"neato"</span></span><span class="org-block">) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; "neato"
</span></span><span class="org-block">
(f&#8325; 'shaka-when-the-walls-fell)
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; f&#8325;: Type mismatch! Expected (or integer string) for argument 0
</span></span><span class="org-block"><span class="comment-delimiter">;;       </span></span><span class="org-block"><span class="comment">&#8800; Given symbol shaka-when-the-walls-fell.
</span></span><span class="org-block-end-line">#+END_SRC
</span>
<span class="bold">No positional arguments but a complex optional argument!</span>
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp :tangle yes
</span><span class="org-block">(declare-type f&#8326; (</span><span class="org-block"><span class="builtin">:z</span></span><span class="org-block"> (satisfies (</span><span class="org-block"><span class="keyword">lambda</span></span><span class="org-block"> (it) (</span><span class="org-block"><span class="keyword">and</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">integerp</span></span><span class="org-block"> it) (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">=</span></span><span class="org-block"> 0 (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">mod</span></span><span class="org-block"> it 5))))))
                 character)
(</span><span class="org-block"><span class="keyword">cl-defun</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">f&#8326;</span></span><span class="org-block"> (</span><span class="org-block"><span class="type">&amp;key</span></span><span class="org-block"> z) ?A)

(f&#8326; 'hi)     </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658;  Keyword argument 144 not one of (:z)
</span></span><span class="org-block">(f&#8326;)         </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; 65; i.e., the character &#8216;A&#8217;
</span></span><span class="org-block">(f&#8326; </span><span class="org-block"><span class="builtin">:z</span></span><span class="org-block"> 6)
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658;  f&#8326;: Type mismatch!
</span></span><span class="org-block"><span class="comment-delimiter">;;    </span></span><span class="org-block"><span class="comment">Expected (satisfies (lambda (it) (and (integerp it) (= 0 (mod it 5))))) :z
</span></span><span class="org-block"><span class="comment-delimiter">;;    </span></span><span class="org-block"><span class="comment">&#8800; Given integer 6.
</span></span><span class="org-block">
(f&#8326; </span><span class="org-block"><span class="builtin">:z</span></span><span class="org-block"> 10) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; 65; i.e., the expected output since 10 mod 5 &#8776; 0 &amp; so 10 is valid input.
</span></span><span class="org-block-end-line">#+END_SRC
</span>
<span class="bold">Preconditions!</span> The previous example had a complex type on a keyword, but that was
essentially a pre-condition; we can do the same on positional arguments.
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp :tangle yes
</span><span class="org-block">(declare-type f&#8327; : (satisfies (</span><span class="org-block"><span class="keyword">lambda</span></span><span class="org-block"> (it) (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">=</span></span><span class="org-block"> it 5)))
                   integer)
(</span><span class="org-block"><span class="keyword">cl-defun</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">f&#8327;</span></span><span class="org-block"> (n) n)
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">The identity on 5 function; and undefined otherwise.
</span></span><span class="org-block">
(f&#8327; 4)
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; f&#8327;: Type mismatch! Expected (satisfies (lambda (it) (= it 5))) for argument 0
</span></span><span class="org-block"><span class="comment-delimiter">;;       </span></span><span class="org-block"><span class="comment">&#8800; Given integer 4.
</span></span><span class="org-block">
(f&#8327; 5) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; 5
</span></span><span class="org-block-end-line">#+END_SRC
</span>
<span class="bold">Postconditions!</span>
Given an integer greater than 5, we present an integer greater than 2; i.e.,
this is a constructive proof that<span class="org-latex-and-related"> $&#8704; n &#8226; n &gt; 5 &#8658; n &gt; 2$.</span>
<span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp :tangle yes
</span><span class="org-block">(declare-type f&#8328; : (satisfies (</span><span class="org-block"><span class="keyword">lambda</span></span><span class="org-block"> (in)  (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">&gt;</span></span><span class="org-block"> in 5)))
                   (satisfies (</span><span class="org-block"><span class="keyword">lambda</span></span><span class="org-block"> (out) (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">&gt;</span></span><span class="org-block"> out 2))))
(</span><span class="org-block"><span class="keyword">cl-defun</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">f&#8328;</span></span><span class="org-block"> (n) n)
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">The identity on 5 function; and undefined otherwise.
</span></span><span class="org-block">
(f&#8328; 4)
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658;  f&#8328;: Type mismatch! Expected (satisfies (lambda (in) (&gt; in 5))) for argument 0
</span></span><span class="org-block"><span class="comment-delimiter">;;        </span></span><span class="org-block"><span class="comment">&#8800; Given integer 4.
</span></span><span class="org-block">
(f&#8328; 72) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; 72; since indeed 72 &gt; 5 for the input, and </span></span><span class="org-block"><span class="comment"><span class="writegood-weasels">clearly</span></span></span><span class="org-block"><span class="comment"> 72 &gt; 2 for the output.
</span></span><span class="org-block-end-line">#+END_SRC
</span>
As it currently stands we cannot make any explicit references between the inputs
and the output, but that's an <span class="writegood-weasels">easy</span> fix: <span class="writegood-weasels">Simply</span> add a local function <span class="org-code">old</span> to the
<span class="org-link"><span class="org-code">declare-type</span></span> macro which is intentionally exposed so that it can <span class="writegood-passive-voice">be used</span> in the
type declarations to refer to the &#8216;old&#8217;, or initial, values provided to the function.
Additionally, one could also add keyword arguments <span class="org-code">:requires</span> and <span class="org-code">:ensures</span>
for a more sophisticated pre- and post-condition framework.
<span class="org-link"><a href="https://github.com/sellout/quid-pro-quo">Something</a></span> along these lines <span class="writegood-passive-voice">is implemented</span> for Common Lisp.

Here's a fun exercise: Recast the <span class="org-link"><a href="https://liquid.kosmikus.org/01-intro.html#/what-is-liquid-haskell">Liquid Haskell</a></span> examples in Lisp using this
<span class="org-link"><span class="org-code">declare-type</span></span> form.
<span class="org-drawer">:HideMe:...
</span>
<span class="org-level-1">* Closing</span>
<span class="org-drawer">  :PROPERTIES:...
</span>
<span class="org-block-begin-line">#+begin_quote org
</span><span class="org-block"><span class="italic">I have heard more than one LISP advocate state such subjective comments as, "LISP is the most powerful and elegant programming language in the world" and expect such comments to </span></span><span class="org-block"><span class="italic"><span class="writegood-passive-voice"><span class="writegood-passive-voice">be taken</span></span></span></span><span class="org-block"><span class="italic"> as objective truth. I have never heard a Java, C++, C, Perl, or Python advocate make the same claim about their own language of choice.</span></span><span class="org-block">

---</span><span class="org-block"><span class="org-link"><a href="http://www.paulgraham.com/quotes.html">A guy on slashdot</a></span></span><span class="org-block">
</span><span class="org-block-end-line">#+end_quote
</span>
I learned a lot of stuff, hope you did too ^_^

<span class="org-level-1">* References</span>
<span class="org-drawer">   :PROPERTIES:...
</span>
Neato web articles:
+ <span class="org-link"><a href="http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html">What to know before debating type systems</a></span>
  - Debunks a number of fallacies such as
    &#8220;dynamic typing provides no way to find bugs&#8221; and
    &#8220;static types need type declarations&#8221;.
+ <span class="org-link"><a href="http://steve-yegge.blogspot.com/2008/05/dynamic-languages-strike-back.html">Dynamic Languages Strike Back</a></span>
  - Everything you might wanna know about dynamically checked languages.
+ <span class="org-link"><a href="http://www.ai.sri.com/~delacaze/alu-site/alu/table/contents.htm">The Association of Lisp Users</a></span>
  - Abundant resource relating to Lisp.
+ <span class="org-link"><a href="https://www.williamjbowman.com/blog/2018/01/19/untyped-programs-don-t-exist/#related">Untyped Programs Don&#8217;t Exist</a></span>
  - It's not a matter of typing but of pragmatics.
+ <span class="org-link"><a href="http://homes.sice.indiana.edu/jsiek/what-is-gradual-typing/">What is Gradual Typing</a></span>:
  - Discusses how static and dynamic typing can <span class="writegood-passive-voice">be used</span> together hamroniously.
+ <span class="org-link"><a href="https://www.cliki.net/">CLiki --- The Common Lisp Wiki</a></span>
  - Contains resources for learning about
     and using the   programming language Common Lisp.
  - The humour section is delightful.
+ <span class="org-link"><a href="http://www.cs.utexas.edu/users/boyer/ftp/diss/akers.pdf">Strong Static Type Checking for Functional Common Lisp</a></span>
  - PhD thesis regarding strong static type checking in an applicative subset of CL.
+ <span class="org-link"><a href="http://www.paulgraham.com/avg.html">Beating the Averages</a></span>
  - Paul Graham discusses &#8220;the most powerful language available&#8221; ---Lisp.
  - Other articles he's written about Lisp can <span class="writegood-passive-voice">be found</span> <span class="org-link"><a href="http://www.paulgraham.com/lisp.html">here</a></span>.
+ <span class="org-link"><a href="http://www.marktarver.com/bipolar.html">The Bipolar Lisp Programmer</a></span>
  - &#8220;Lisp is, like life, what you make of it.&#8221;
       Lisps attract a certain kind of personality.

+ A <span class="org-target">&lt;&lt;&lt;bunch of papers&gt;&gt;&gt;</span> on <span class="org-link">polymorphic</span> (modal) type systems
  for Lisp-like multi-staged languages:
  <span class="org-link"><a href="http://ropas.snu.ac.kr/lib/dock/KiYiCa2005.pdf">This</a></span> is generic, <span class="org-link"><a href="https://www.iro.umontreal.ca/~monnier/typer-jfla2019.pdf">this</a></span> is ML + Scheme, <span class="org-link"><a href="https://link.springer.com/chapter/10.1007/978-1-4615-2836-4_8">this</a></span> for compile-time typing,
  and <span class="org-link"><a href="https://hal.archives-ouvertes.fr/hal-01380792/document">this</a></span> one &#8220;allows the programmer to declaratively express the types of
   heterogeneous sequences in a way which is natural in the Common Lisp language.&#8221;

+ <span class="org-link"><a href="http://lambda-the-ultimate.org/node/5426">Type Systems as Macros</a></span>
  - After defining <span class="org-link"><span class="org-code">declare-type</span></span> I thought the slogan &#8220;types by macros&#8221; sounded nifty;
    Googling it led me to this paper where the Racket <span class="writegood-passive-voice">is endowed</span> with types.

    Lisp is great lol.

+ <span class="org-link"><a href="https://twobithistory.org/2018/10/14/lisp.html">How Lisp Became God's Own Programming Language</a></span>
  - History and venerance of Lisp.

+ <span class="org-link"><a href="http://www.lispworks.com/documentation/lw51/CLHS/Body/04_bc.htm">Common Lisp HyperSpec</a></span> -- Type Specifiers
<span class="org-level-1">* </span><span class="org-special-keyword">COMMENT</span><span class="org-level-1"> How using </span><span class="org-level-1"><span class="org-code">compile</span></span><span class="org-level-1"> can increase speed </span><span class="org-level-1"><span class="org-tag">:experiment:</span></span>
<span class="org-drawer">  :PROPERTIES:...
</span><span class="org-block-begin-line">#+BEGIN_SRC emacs-lisp
</span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment"><a href="https://lists.gnu.org/archive/html/help-gnu-emacs/2008-06/msg00087.html">https://lists.gnu.org/archive/html/help-gnu-emacs/2008-06/msg00087.html</a>
</span></span><span class="org-block">(</span><span class="org-block"><span class="keyword">defmacro</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">measure-time</span></span><span class="org-block"> (</span><span class="org-block"><span class="type">&amp;rest</span></span><span class="org-block"> body)
  </span><span class="org-block"><span class="doc">"Measure the time it takes to evaluate BODY."</span></span><span class="org-block">
  `(</span><span class="org-block"><span class="keyword">let</span></span><span class="org-block"> ((time (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">current-time</span></span><span class="org-block">)))
     ,@body
     (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">message</span></span><span class="org-block"> </span><span class="org-block"><span class="string">"%.06f seconds"</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">float-time</span></span><span class="org-block"> (</span><span class="org-block"><span class="highlight-defined-function-name">time-since</span></span><span class="org-block"> time)))))

(</span><span class="org-block"><span class="keyword">setf</span></span><span class="org-block"> a (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">make-vector</span></span><span class="org-block"> 1000000 1.0))

(</span><span class="org-block"><span class="keyword">defun</span></span><span class="org-block"> </span><span class="org-block"><span class="function-name">sum-elts</span></span><span class="org-block"> (a)
  (</span><span class="org-block"><span class="keyword">let</span></span><span class="org-block"> ((sum 0.0))
    (</span><span class="org-block"><span class="keyword">dotimes</span></span><span class="org-block"> (r 1000000)
        (</span><span class="org-block"><span class="keyword">incf</span></span><span class="org-block"> sum (</span><span class="org-block"><span class="highlight-defined-builtin-function-name">aref</span></span><span class="org-block"> a r)))
    sum))

(measure-time (sum-elts a)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; 0.534579 seconds
</span></span><span class="org-block">
(</span><span class="org-block"><span class="highlight-defined-function-name">byte-compile</span></span><span class="org-block"> 'sum-elts)
(measure-time (sum-elts a)) </span><span class="org-block"><span class="comment-delimiter">;; </span></span><span class="org-block"><span class="comment">&#8658; 0.238634 seconds
</span></span><span class="org-block-end-line">#+END_SRC
</span>
<span class="org-meta-line">#+RESULTS:</span>
<span class="org-code">: 0.000002
</span>
So there is no way to "compile the same definition again."
<span class="org-link"><a href="https://ftp.gnu.org/old-gnu/Manuals/elisp-manual-20-2.5/html_node/elisp_197.html">https://ftp.gnu.org/old-gnu/Manuals/elisp-manual-20-2.5/html_node/elisp_197.html</a></span>
</pre>
  </body>
</html>
